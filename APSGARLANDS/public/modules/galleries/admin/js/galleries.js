/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./Modules/Galleries/node_modules/dropzone/dist/dropzone.js":
/*!******************************************************************!*\
  !*** ./Modules/Galleries/node_modules/dropzone/dist/dropzone.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n/*\r\n *\r\n * More info at [www.dropzonejs.com](http://www.dropzonejs.com)\r\n *\r\n * Copyright (c) 2012, Matias Meno\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n */\r\n\r\n// The Emitter class provides the ability to call `.on()` on Dropzone to listen\r\n// to events.\r\n// It is strongly based on component's emitter class, and I removed the\r\n// functionality because of the dependency hell with different frameworks.\r\nvar Emitter = function () {\r\n  function Emitter() {\r\n    _classCallCheck(this, Emitter);\r\n  }\r\n\r\n  _createClass(Emitter, [{\r\n    key: \"on\",\r\n\r\n    // Add an event listener for given event\r\n    value: function on(event, fn) {\r\n      this._callbacks = this._callbacks || {};\r\n      // Create namespace for this event\r\n      if (!this._callbacks[event]) {\r\n        this._callbacks[event] = [];\r\n      }\r\n      this._callbacks[event].push(fn);\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"emit\",\r\n    value: function emit(event) {\r\n      this._callbacks = this._callbacks || {};\r\n      var callbacks = this._callbacks[event];\r\n\r\n      if (callbacks) {\r\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n          args[_key - 1] = arguments[_key];\r\n        }\r\n\r\n        for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n          var _ref;\r\n\r\n          if (_isArray) {\r\n            if (_i >= _iterator.length) break;\r\n            _ref = _iterator[_i++];\r\n          } else {\r\n            _i = _iterator.next();\r\n            if (_i.done) break;\r\n            _ref = _i.value;\r\n          }\r\n\r\n          var callback = _ref;\r\n\r\n          callback.apply(this, args);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    // Remove event listener for given event. If fn is not provided, all event\r\n    // listeners for that event will be removed. If neither is provided, all\r\n    // event listeners will be removed.\r\n\r\n  }, {\r\n    key: \"off\",\r\n    value: function off(event, fn) {\r\n      if (!this._callbacks || arguments.length === 0) {\r\n        this._callbacks = {};\r\n        return this;\r\n      }\r\n\r\n      // specific event\r\n      var callbacks = this._callbacks[event];\r\n      if (!callbacks) {\r\n        return this;\r\n      }\r\n\r\n      // remove all handlers\r\n      if (arguments.length === 1) {\r\n        delete this._callbacks[event];\r\n        return this;\r\n      }\r\n\r\n      // remove specific handler\r\n      for (var i = 0; i < callbacks.length; i++) {\r\n        var callback = callbacks[i];\r\n        if (callback === fn) {\r\n          callbacks.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n\r\n      return this;\r\n    }\r\n  }]);\r\n\r\n  return Emitter;\r\n}();\r\n\r\nvar Dropzone = function (_Emitter) {\r\n  _inherits(Dropzone, _Emitter);\r\n\r\n  _createClass(Dropzone, null, [{\r\n    key: \"initClass\",\r\n    value: function initClass() {\r\n\r\n      // Exposing the emitter class, mainly for tests\r\n      this.prototype.Emitter = Emitter;\r\n\r\n      /*\r\n       This is a list of all available events you can register on a dropzone object.\r\n        You can register an event handler like this:\r\n        dropzone.on(\"dragEnter\", function() { });\r\n        */\r\n      this.prototype.events = [\"drop\", \"dragstart\", \"dragend\", \"dragenter\", \"dragover\", \"dragleave\", \"addedfile\", \"addedfiles\", \"removedfile\", \"thumbnail\", \"error\", \"errormultiple\", \"processing\", \"processingmultiple\", \"uploadprogress\", \"totaluploadprogress\", \"sending\", \"sendingmultiple\", \"success\", \"successmultiple\", \"canceled\", \"canceledmultiple\", \"complete\", \"completemultiple\", \"reset\", \"maxfilesexceeded\", \"maxfilesreached\", \"queuecomplete\"];\r\n\r\n      this.prototype.defaultOptions = {\r\n        /**\r\n         * Has to be specified on elements other than form (or when the form\r\n         * doesn't have an `action` attribute). You can also\r\n         * provide a function that will be called with `files` and\r\n         * must return the url (since `v3.12.0`)\r\n         */\r\n        url: null,\r\n\r\n        /**\r\n         * Can be changed to `\"put\"` if necessary. You can also provide a function\r\n         * that will be called with `files` and must return the method (since `v3.12.0`).\r\n         */\r\n        method: \"post\",\r\n\r\n        /**\r\n         * Will be set on the XHRequest.\r\n         */\r\n        withCredentials: false,\r\n\r\n        /**\r\n         * The timeout for the XHR requests in milliseconds (since `v4.4.0`).\r\n         */\r\n        timeout: 30000,\r\n\r\n        /**\r\n         * How many file uploads to process in parallel (See the\r\n         * Enqueuing file uploads* documentation section for more info)\r\n         */\r\n        parallelUploads: 2,\r\n\r\n        /**\r\n         * Whether to send multiple files in one request. If\r\n         * this it set to true, then the fallback file input element will\r\n         * have the `multiple` attribute as well. This option will\r\n         * also trigger additional events (like `processingmultiple`). See the events\r\n         * documentation section for more information.\r\n         */\r\n        uploadMultiple: false,\r\n\r\n        /**\r\n         * Whether you want files to be uploaded in chunks to your server. This can't be\r\n         * used in combination with `uploadMultiple`.\r\n         *\r\n         * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.\r\n         */\r\n        chunking: false,\r\n\r\n        /**\r\n         * If `chunking` is enabled, this defines whether **every** file should be chunked,\r\n         * even if the file size is below chunkSize. This means, that the additional chunk\r\n         * form data will be submitted and the `chunksUploaded` callback will be invoked.\r\n         */\r\n        forceChunking: false,\r\n\r\n        /**\r\n         * If `chunking` is `true`, then this defines the chunk size in bytes.\r\n         */\r\n        chunkSize: 2000000,\r\n\r\n        /**\r\n         * If `true`, the individual chunks of a file are being uploaded simultaneously.\r\n         */\r\n        parallelChunkUploads: false,\r\n\r\n        /**\r\n         * Whether a chunk should be retried if it fails.\r\n         */\r\n        retryChunks: false,\r\n\r\n        /**\r\n         * If `retryChunks` is true, how many times should it be retried.\r\n         */\r\n        retryChunksLimit: 3,\r\n\r\n        /**\r\n         * If not `null` defines how many files this Dropzone handles. If it exceeds,\r\n         * the event `maxfilesexceeded` will be called. The dropzone element gets the\r\n         * class `dz-max-files-reached` accordingly so you can provide visual feedback.\r\n         */\r\n        maxFilesize: 256,\r\n\r\n        /**\r\n         * The name of the file param that gets transferred.\r\n         * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then\r\n         * Dropzone will append `[]` to the name.\r\n         */\r\n        paramName: \"file\",\r\n\r\n        /**\r\n         * Whether thumbnails for images should be generated\r\n         */\r\n        createImageThumbnails: true,\r\n\r\n        /**\r\n         * In MB. When the filename exceeds this limit, the thumbnail will not be generated.\r\n         */\r\n        maxThumbnailFilesize: 10,\r\n\r\n        /**\r\n         * If `null`, the ratio of the image will be used to calculate it.\r\n         */\r\n        thumbnailWidth: 120,\r\n\r\n        /**\r\n         * The same as `thumbnailWidth`. If both are null, images will not be resized.\r\n         */\r\n        thumbnailHeight: 120,\r\n\r\n        /**\r\n         * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.\r\n         * Can be either `contain` or `crop`.\r\n         */\r\n        thumbnailMethod: 'crop',\r\n\r\n        /**\r\n         * If set, images will be resized to these dimensions before being **uploaded**.\r\n         * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect\r\n         * ratio of the file will be preserved.\r\n         *\r\n         * The `options.transformFile` function uses these options, so if the `transformFile` function\r\n         * is overridden, these options don't do anything.\r\n         */\r\n        resizeWidth: null,\r\n\r\n        /**\r\n         * See `resizeWidth`.\r\n         */\r\n        resizeHeight: null,\r\n\r\n        /**\r\n         * The mime type of the resized image (before it gets uploaded to the server).\r\n         * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.\r\n         * See `resizeWidth` for more information.\r\n         */\r\n        resizeMimeType: null,\r\n\r\n        /**\r\n         * The quality of the resized images. See `resizeWidth`.\r\n         */\r\n        resizeQuality: 0.8,\r\n\r\n        /**\r\n         * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.\r\n         * Can be either `contain` or `crop`.\r\n         */\r\n        resizeMethod: 'contain',\r\n\r\n        /**\r\n         * The base that is used to calculate the filesize. You can change this to\r\n         * 1024 if you would rather display kibibytes, mebibytes, etc...\r\n         * 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte` not `1 kilobyte`.\r\n         * You can change this to `1024` if you don't care about validity.\r\n         */\r\n        filesizeBase: 1000,\r\n\r\n        /**\r\n         * Can be used to limit the maximum number of files that will be handled by this Dropzone\r\n         */\r\n        maxFiles: null,\r\n\r\n        /**\r\n         * An optional object to send additional headers to the server. Eg:\r\n         * `{ \"My-Awesome-Header\": \"header value\" }`\r\n         */\r\n        headers: null,\r\n\r\n        /**\r\n         * If `true`, the dropzone element itself will be clickable, if `false`\r\n         * nothing will be clickable.\r\n         *\r\n         * You can also pass an HTML element, a CSS selector (for multiple elements)\r\n         * or an array of those. In that case, all of those elements will trigger an\r\n         * upload when clicked.\r\n         */\r\n        clickable: true,\r\n\r\n        /**\r\n         * Whether hidden files in directories should be ignored.\r\n         */\r\n        ignoreHiddenFiles: true,\r\n\r\n        /**\r\n         * The default implementation of `accept` checks the file's mime type or\r\n         * extension against this list. This is a comma separated list of mime\r\n         * types or file extensions.\r\n         *\r\n         * Eg.: `image/*,application/pdf,.psd`\r\n         *\r\n         * If the Dropzone is `clickable` this option will also be used as\r\n         * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)\r\n         * parameter on the hidden file input as well.\r\n         */\r\n        acceptedFiles: null,\r\n\r\n        /**\r\n         * **Deprecated!**\r\n         * Use acceptedFiles instead.\r\n         */\r\n        acceptedMimeTypes: null,\r\n\r\n        /**\r\n         * If false, files will be added to the queue but the queue will not be\r\n         * processed automatically.\r\n         * This can be useful if you need some additional user input before sending\r\n         * files (or if you want want all files sent at once).\r\n         * If you're ready to send the file simply call `myDropzone.processQueue()`.\r\n         *\r\n         * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation\r\n         * section for more information.\r\n         */\r\n        autoProcessQueue: true,\r\n\r\n        /**\r\n         * If false, files added to the dropzone will not be queued by default.\r\n         * You'll have to call `enqueueFile(file)` manually.\r\n         */\r\n        autoQueue: true,\r\n\r\n        /**\r\n         * If `true`, this will add a link to every file preview to remove or cancel (if\r\n         * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`\r\n         * and `dictRemoveFile` options are used for the wording.\r\n         */\r\n        addRemoveLinks: false,\r\n\r\n        /**\r\n         * Defines where to display the file previews â€“ if `null` the\r\n         * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS\r\n         * selector. The element should have the `dropzone-previews` class so\r\n         * the previews are displayed properly.\r\n         */\r\n        previewsContainer: null,\r\n\r\n        /**\r\n         * This is the element the hidden input field (which is used when clicking on the\r\n         * dropzone to trigger file selection) will be appended to. This might\r\n         * be important in case you use frameworks to switch the content of your page.\r\n         */\r\n        hiddenInputContainer: \"body\",\r\n\r\n        /**\r\n         * If null, no capture type will be specified\r\n         * If camera, mobile devices will skip the file selection and choose camera\r\n         * If microphone, mobile devices will skip the file selection and choose the microphone\r\n         * If camcorder, mobile devices will skip the file selection and choose the camera in video mode\r\n         * On apple devices multiple must be set to false.  AcceptedFiles may need to\r\n         * be set to an appropriate mime type (e.g. \"image/*\", \"audio/*\", or \"video/*\").\r\n         */\r\n        capture: null,\r\n\r\n        /**\r\n         * **Deprecated**. Use `renameFile` instead.\r\n         */\r\n        renameFilename: null,\r\n\r\n        /**\r\n         * A function that is invoked before the file is uploaded to the server and renames the file.\r\n         * This function gets the `File` as argument and can use the `file.name`. The actual name of the\r\n         * file that gets used during the upload can be accessed through `file.upload.filename`.\r\n         */\r\n        renameFile: null,\r\n\r\n        /**\r\n         * If `true` the fallback will be forced. This is very useful to test your server\r\n         * implementations first and make sure that everything works as\r\n         * expected without dropzone if you experience problems, and to test\r\n         * how your fallbacks will look.\r\n         */\r\n        forceFallback: false,\r\n\r\n        /**\r\n         * The text used before any files are dropped.\r\n         */\r\n        dictDefaultMessage: \"Drop files here to upload\",\r\n\r\n        /**\r\n         * The text that replaces the default message text it the browser is not supported.\r\n         */\r\n        dictFallbackMessage: \"Your browser does not support drag'n'drop file uploads.\",\r\n\r\n        /**\r\n         * The text that will be added before the fallback form.\r\n         * If you provide a  fallback element yourself, or if this option is `null` this will\r\n         * be ignored.\r\n         */\r\n        dictFallbackText: \"Please use the fallback form below to upload your files like in the olden days.\",\r\n\r\n        /**\r\n         * If the filesize is too big.\r\n         * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.\r\n         */\r\n        dictFileTooBig: \"File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.\",\r\n\r\n        /**\r\n         * If the file doesn't match the file type.\r\n         */\r\n        dictInvalidFileType: \"You can't upload files of this type.\",\r\n\r\n        /**\r\n         * If the server response was invalid.\r\n         * `{{statusCode}}` will be replaced with the servers status code.\r\n         */\r\n        dictResponseError: \"Server responded with {{statusCode}} code.\",\r\n\r\n        /**\r\n         * If `addRemoveLinks` is true, the text to be used for the cancel upload link.\r\n         */\r\n        dictCancelUpload: \"Cancel upload\",\r\n\r\n        /**\r\n         * The text that is displayed if an upload was manually canceled\r\n         */\r\n        dictUploadCanceled: \"Upload canceled.\",\r\n\r\n        /**\r\n         * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.\r\n         */\r\n        dictCancelUploadConfirmation: \"Are you sure you want to cancel this upload?\",\r\n\r\n        /**\r\n         * If `addRemoveLinks` is true, the text to be used to remove a file.\r\n         */\r\n        dictRemoveFile: \"Remove file\",\r\n\r\n        /**\r\n         * If this is not null, then the user will be prompted before removing a file.\r\n         */\r\n        dictRemoveFileConfirmation: null,\r\n\r\n        /**\r\n         * Displayed if `maxFiles` is st and exceeded.\r\n         * The string `{{maxFiles}}` will be replaced by the configuration value.\r\n         */\r\n        dictMaxFilesExceeded: \"You can not upload any more files.\",\r\n\r\n        /**\r\n         * Allows you to translate the different units. Starting with `tb` for terabytes and going down to\r\n         * `b` for bytes.\r\n         */\r\n        dictFileSizeUnits: { tb: \"TB\", gb: \"GB\", mb: \"MB\", kb: \"KB\", b: \"b\" },\r\n        /**\r\n         * Called when dropzone initialized\r\n         * You can add event listeners here\r\n         */\r\n        init: function init() {},\r\n\r\n\r\n        /**\r\n         * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`\r\n         * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case\r\n         * of a function, this needs to return a map.\r\n         *\r\n         * The default implementation does nothing for normal uploads, but adds relevant information for\r\n         * chunked uploads.\r\n         *\r\n         * This is the same as adding hidden input fields in the form element.\r\n         */\r\n        params: function params(files, xhr, chunk) {\r\n          if (chunk) {\r\n            return {\r\n              dzuuid: chunk.file.upload.uuid,\r\n              dzchunkindex: chunk.index,\r\n              dztotalfilesize: chunk.file.size,\r\n              dzchunksize: this.options.chunkSize,\r\n              dztotalchunkcount: chunk.file.upload.totalChunkCount,\r\n              dzchunkbyteoffset: chunk.index * this.options.chunkSize\r\n            };\r\n          }\r\n        },\r\n\r\n\r\n        /**\r\n         * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)\r\n         * and a `done` function as parameters.\r\n         *\r\n         * If the done function is invoked without arguments, the file is \"accepted\" and will\r\n         * be processed. If you pass an error message, the file is rejected, and the error\r\n         * message will be displayed.\r\n         * This function will not be called if the file is too big or doesn't match the mime types.\r\n         */\r\n        accept: function accept(file, done) {\r\n          return done();\r\n        },\r\n\r\n\r\n        /**\r\n         * The callback that will be invoked when all chunks have been uploaded for a file.\r\n         * It gets the file for which the chunks have been uploaded as the first parameter,\r\n         * and the `done` function as second. `done()` needs to be invoked when everything\r\n         * needed to finish the upload process is done.\r\n         */\r\n        chunksUploaded: function chunksUploaded(file, done) {\r\n          done();\r\n        },\r\n\r\n        /**\r\n         * Gets called when the browser is not supported.\r\n         * The default implementation shows the fallback input field and adds\r\n         * a text.\r\n         */\r\n        fallback: function fallback() {\r\n          // This code should pass in IE7... :(\r\n          var messageElement = void 0;\r\n          this.element.className = this.element.className + \" dz-browser-not-supported\";\r\n\r\n          for (var _iterator2 = this.element.getElementsByTagName(\"div\"), _isArray2 = true, _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n            var _ref2;\r\n\r\n            if (_isArray2) {\r\n              if (_i2 >= _iterator2.length) break;\r\n              _ref2 = _iterator2[_i2++];\r\n            } else {\r\n              _i2 = _iterator2.next();\r\n              if (_i2.done) break;\r\n              _ref2 = _i2.value;\r\n            }\r\n\r\n            var child = _ref2;\r\n\r\n            if (/(^| )dz-message($| )/.test(child.className)) {\r\n              messageElement = child;\r\n              child.className = \"dz-message\"; // Removes the 'dz-default' class\r\n              break;\r\n            }\r\n          }\r\n          if (!messageElement) {\r\n            messageElement = Dropzone.createElement(\"<div class=\\\"dz-message\\\"><span></span></div>\");\r\n            this.element.appendChild(messageElement);\r\n          }\r\n\r\n          var span = messageElement.getElementsByTagName(\"span\")[0];\r\n          if (span) {\r\n            if (span.textContent != null) {\r\n              span.textContent = this.options.dictFallbackMessage;\r\n            } else if (span.innerText != null) {\r\n              span.innerText = this.options.dictFallbackMessage;\r\n            }\r\n          }\r\n\r\n          return this.element.appendChild(this.getFallbackForm());\r\n        },\r\n\r\n\r\n        /**\r\n         * Gets called to calculate the thumbnail dimensions.\r\n         *\r\n         * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:\r\n         *\r\n         *  - `srcWidth` & `srcHeight` (required)\r\n         *  - `trgWidth` & `trgHeight` (required)\r\n         *  - `srcX` & `srcY` (optional, default `0`)\r\n         *  - `trgX` & `trgY` (optional, default `0`)\r\n         *\r\n         * Those values are going to be used by `ctx.drawImage()`.\r\n         */\r\n        resize: function resize(file, width, height, resizeMethod) {\r\n          var info = {\r\n            srcX: 0,\r\n            srcY: 0,\r\n            srcWidth: file.width,\r\n            srcHeight: file.height\r\n          };\r\n\r\n          var srcRatio = file.width / file.height;\r\n\r\n          // Automatically calculate dimensions if not specified\r\n          if (width == null && height == null) {\r\n            width = info.srcWidth;\r\n            height = info.srcHeight;\r\n          } else if (width == null) {\r\n            width = height * srcRatio;\r\n          } else if (height == null) {\r\n            height = width / srcRatio;\r\n          }\r\n\r\n          // Make sure images aren't upscaled\r\n          width = Math.min(width, info.srcWidth);\r\n          height = Math.min(height, info.srcHeight);\r\n\r\n          var trgRatio = width / height;\r\n\r\n          if (info.srcWidth > width || info.srcHeight > height) {\r\n            // Image is bigger and needs rescaling\r\n            if (resizeMethod === 'crop') {\r\n              if (srcRatio > trgRatio) {\r\n                info.srcHeight = file.height;\r\n                info.srcWidth = info.srcHeight * trgRatio;\r\n              } else {\r\n                info.srcWidth = file.width;\r\n                info.srcHeight = info.srcWidth / trgRatio;\r\n              }\r\n            } else if (resizeMethod === 'contain') {\r\n              // Method 'contain'\r\n              if (srcRatio > trgRatio) {\r\n                height = width / srcRatio;\r\n              } else {\r\n                width = height * srcRatio;\r\n              }\r\n            } else {\r\n              throw new Error(\"Unknown resizeMethod '\" + resizeMethod + \"'\");\r\n            }\r\n          }\r\n\r\n          info.srcX = (file.width - info.srcWidth) / 2;\r\n          info.srcY = (file.height - info.srcHeight) / 2;\r\n\r\n          info.trgWidth = width;\r\n          info.trgHeight = height;\r\n\r\n          return info;\r\n        },\r\n\r\n\r\n        /**\r\n         * Can be used to transform the file (for example, resize an image if necessary).\r\n         *\r\n         * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes\r\n         * images according to those dimensions.\r\n         *\r\n         * Gets the `file` as the first parameter, and a `done()` function as the second, that needs\r\n         * to be invoked with the file when the transformation is done.\r\n         */\r\n        transformFile: function transformFile(file, done) {\r\n          if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {\r\n            return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);\r\n          } else {\r\n            return done(file);\r\n          }\r\n        },\r\n\r\n\r\n        /**\r\n         * A string that contains the template used for each dropped\r\n         * file. Change it to fulfill your needs but make sure to properly\r\n         * provide all elements.\r\n         *\r\n         * If you want to use an actual HTML element instead of providing a String\r\n         * as a config option, you could create a div with the id `tpl`,\r\n         * put the template inside it and provide the element like this:\r\n         *\r\n         *     document\r\n         *       .querySelector('#tpl')\r\n         *       .innerHTML\r\n         *\r\n         */\r\n        previewTemplate: \"<div class=\\\"dz-preview dz-file-preview\\\">\\n  <div class=\\\"dz-image\\\"><img data-dz-thumbnail /></div>\\n  <div class=\\\"dz-details\\\">\\n    <div class=\\\"dz-size\\\"><span data-dz-size></span></div>\\n    <div class=\\\"dz-filename\\\"><span data-dz-name></span></div>\\n  </div>\\n  <div class=\\\"dz-progress\\\"><span class=\\\"dz-upload\\\" data-dz-uploadprogress></span></div>\\n  <div class=\\\"dz-error-message\\\"><span data-dz-errormessage></span></div>\\n  <div class=\\\"dz-success-mark\\\">\\n    <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\">\\n      <title>Check</title>\\n      <defs></defs>\\n      <g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" sketch:type=\\\"MSPage\\\">\\n        <path d=\\\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\" id=\\\"Oval-2\\\" stroke-opacity=\\\"0.198794158\\\" stroke=\\\"#747474\\\" fill-opacity=\\\"0.816519475\\\" fill=\\\"#FFFFFF\\\" sketch:type=\\\"MSShapeGroup\\\"></path>\\n      </g>\\n    </svg>\\n  </div>\\n  <div class=\\\"dz-error-mark\\\">\\n    <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\">\\n      <title>Error</title>\\n      <defs></defs>\\n      <g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" sketch:type=\\\"MSPage\\\">\\n        <g id=\\\"Check-+-Oval-2\\\" sketch:type=\\\"MSLayerGroup\\\" stroke=\\\"#747474\\\" stroke-opacity=\\\"0.198794158\\\" fill=\\\"#FFFFFF\\\" fill-opacity=\\\"0.816519475\\\">\\n          <path d=\\\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\" id=\\\"Oval-2\\\" sketch:type=\\\"MSShapeGroup\\\"></path>\\n        </g>\\n      </g>\\n    </svg>\\n  </div>\\n</div>\",\r\n\r\n        // END OPTIONS\r\n        // (Required by the dropzone documentation parser)\r\n\r\n\r\n        /*\r\n         Those functions register themselves to the events on init and handle all\r\n         the user interface specific stuff. Overwriting them won't break the upload\r\n         but can break the way it's displayed.\r\n         You can overwrite them if you don't like the default behavior. If you just\r\n         want to add an additional event handler, register it on the dropzone object\r\n         and don't overwrite those options.\r\n         */\r\n\r\n        // Those are self explanatory and simply concern the DragnDrop.\r\n        drop: function drop(e) {\r\n          return this.element.classList.remove(\"dz-drag-hover\");\r\n        },\r\n        dragstart: function dragstart(e) {},\r\n        dragend: function dragend(e) {\r\n          return this.element.classList.remove(\"dz-drag-hover\");\r\n        },\r\n        dragenter: function dragenter(e) {\r\n          return this.element.classList.add(\"dz-drag-hover\");\r\n        },\r\n        dragover: function dragover(e) {\r\n          return this.element.classList.add(\"dz-drag-hover\");\r\n        },\r\n        dragleave: function dragleave(e) {\r\n          return this.element.classList.remove(\"dz-drag-hover\");\r\n        },\r\n        paste: function paste(e) {},\r\n\r\n\r\n        // Called whenever there are no files left in the dropzone anymore, and the\r\n        // dropzone should be displayed as if in the initial state.\r\n        reset: function reset() {\r\n          return this.element.classList.remove(\"dz-started\");\r\n        },\r\n\r\n\r\n        // Called when a file is added to the queue\r\n        // Receives `file`\r\n        addedfile: function addedfile(file) {\r\n          var _this2 = this;\r\n\r\n          if (this.element === this.previewsContainer) {\r\n            this.element.classList.add(\"dz-started\");\r\n          }\r\n\r\n          if (this.previewsContainer) {\r\n            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());\r\n            file.previewTemplate = file.previewElement; // Backwards compatibility\r\n\r\n            this.previewsContainer.appendChild(file.previewElement);\r\n            for (var _iterator3 = file.previewElement.querySelectorAll(\"[data-dz-name]\"), _isArray3 = true, _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\r\n              var _ref3;\r\n\r\n              if (_isArray3) {\r\n                if (_i3 >= _iterator3.length) break;\r\n                _ref3 = _iterator3[_i3++];\r\n              } else {\r\n                _i3 = _iterator3.next();\r\n                if (_i3.done) break;\r\n                _ref3 = _i3.value;\r\n              }\r\n\r\n              var node = _ref3;\r\n\r\n              node.textContent = file.name;\r\n            }\r\n            for (var _iterator4 = file.previewElement.querySelectorAll(\"[data-dz-size]\"), _isArray4 = true, _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\r\n              if (_isArray4) {\r\n                if (_i4 >= _iterator4.length) break;\r\n                node = _iterator4[_i4++];\r\n              } else {\r\n                _i4 = _iterator4.next();\r\n                if (_i4.done) break;\r\n                node = _i4.value;\r\n              }\r\n\r\n              node.innerHTML = this.filesize(file.size);\r\n            }\r\n\r\n            if (this.options.addRemoveLinks) {\r\n              file._removeLink = Dropzone.createElement(\"<a class=\\\"dz-remove\\\" href=\\\"javascript:undefined;\\\" data-dz-remove>\" + this.options.dictRemoveFile + \"</a>\");\r\n              file.previewElement.appendChild(file._removeLink);\r\n            }\r\n\r\n            var removeFileEvent = function removeFileEvent(e) {\r\n              e.preventDefault();\r\n              e.stopPropagation();\r\n              if (file.status === Dropzone.UPLOADING) {\r\n                return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {\r\n                  return _this2.removeFile(file);\r\n                });\r\n              } else {\r\n                if (_this2.options.dictRemoveFileConfirmation) {\r\n                  return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {\r\n                    return _this2.removeFile(file);\r\n                  });\r\n                } else {\r\n                  return _this2.removeFile(file);\r\n                }\r\n              }\r\n            };\r\n\r\n            for (var _iterator5 = file.previewElement.querySelectorAll(\"[data-dz-remove]\"), _isArray5 = true, _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\r\n              var _ref4;\r\n\r\n              if (_isArray5) {\r\n                if (_i5 >= _iterator5.length) break;\r\n                _ref4 = _iterator5[_i5++];\r\n              } else {\r\n                _i5 = _iterator5.next();\r\n                if (_i5.done) break;\r\n                _ref4 = _i5.value;\r\n              }\r\n\r\n              var removeLink = _ref4;\r\n\r\n              removeLink.addEventListener(\"click\", removeFileEvent);\r\n            }\r\n          }\r\n        },\r\n\r\n\r\n        // Called whenever a file is removed.\r\n        removedfile: function removedfile(file) {\r\n          if (file.previewElement != null && file.previewElement.parentNode != null) {\r\n            file.previewElement.parentNode.removeChild(file.previewElement);\r\n          }\r\n          return this._updateMaxFilesReachedClass();\r\n        },\r\n\r\n\r\n        // Called when a thumbnail has been generated\r\n        // Receives `file` and `dataUrl`\r\n        thumbnail: function thumbnail(file, dataUrl) {\r\n          if (file.previewElement) {\r\n            file.previewElement.classList.remove(\"dz-file-preview\");\r\n            for (var _iterator6 = file.previewElement.querySelectorAll(\"[data-dz-thumbnail]\"), _isArray6 = true, _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\r\n              var _ref5;\r\n\r\n              if (_isArray6) {\r\n                if (_i6 >= _iterator6.length) break;\r\n                _ref5 = _iterator6[_i6++];\r\n              } else {\r\n                _i6 = _iterator6.next();\r\n                if (_i6.done) break;\r\n                _ref5 = _i6.value;\r\n              }\r\n\r\n              var thumbnailElement = _ref5;\r\n\r\n              thumbnailElement.alt = file.name;\r\n              thumbnailElement.src = dataUrl;\r\n            }\r\n\r\n            return setTimeout(function () {\r\n              return file.previewElement.classList.add(\"dz-image-preview\");\r\n            }, 1);\r\n          }\r\n        },\r\n\r\n\r\n        // Called whenever an error occurs\r\n        // Receives `file` and `message`\r\n        error: function error(file, message) {\r\n          if (file.previewElement) {\r\n            file.previewElement.classList.add(\"dz-error\");\r\n            if (typeof message !== \"String\" && message.error) {\r\n              message = message.error;\r\n            }\r\n            for (var _iterator7 = file.previewElement.querySelectorAll(\"[data-dz-errormessage]\"), _isArray7 = true, _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\r\n              var _ref6;\r\n\r\n              if (_isArray7) {\r\n                if (_i7 >= _iterator7.length) break;\r\n                _ref6 = _iterator7[_i7++];\r\n              } else {\r\n                _i7 = _iterator7.next();\r\n                if (_i7.done) break;\r\n                _ref6 = _i7.value;\r\n              }\r\n\r\n              var node = _ref6;\r\n\r\n              node.textContent = message;\r\n            }\r\n          }\r\n        },\r\n        errormultiple: function errormultiple() {},\r\n\r\n\r\n        // Called when a file gets processed. Since there is a cue, not all added\r\n        // files are processed immediately.\r\n        // Receives `file`\r\n        processing: function processing(file) {\r\n          if (file.previewElement) {\r\n            file.previewElement.classList.add(\"dz-processing\");\r\n            if (file._removeLink) {\r\n              return file._removeLink.textContent = this.options.dictCancelUpload;\r\n            }\r\n          }\r\n        },\r\n        processingmultiple: function processingmultiple() {},\r\n\r\n\r\n        // Called whenever the upload progress gets updated.\r\n        // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.\r\n        // To get the total number of bytes of the file, use `file.size`\r\n        uploadprogress: function uploadprogress(file, progress, bytesSent) {\r\n          if (file.previewElement) {\r\n            for (var _iterator8 = file.previewElement.querySelectorAll(\"[data-dz-uploadprogress]\"), _isArray8 = true, _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\r\n              var _ref7;\r\n\r\n              if (_isArray8) {\r\n                if (_i8 >= _iterator8.length) break;\r\n                _ref7 = _iterator8[_i8++];\r\n              } else {\r\n                _i8 = _iterator8.next();\r\n                if (_i8.done) break;\r\n                _ref7 = _i8.value;\r\n              }\r\n\r\n              var node = _ref7;\r\n\r\n              node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = progress + \"%\";\r\n            }\r\n          }\r\n        },\r\n\r\n\r\n        // Called whenever the total upload progress gets updated.\r\n        // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent\r\n        totaluploadprogress: function totaluploadprogress() {},\r\n\r\n\r\n        // Called just before the file is sent. Gets the `xhr` object as second\r\n        // parameter, so you can modify it (for example to add a CSRF token) and a\r\n        // `formData` object to add additional information.\r\n        sending: function sending() {},\r\n        sendingmultiple: function sendingmultiple() {},\r\n\r\n\r\n        // When the complete upload is finished and successful\r\n        // Receives `file`\r\n        success: function success(file) {\r\n          if (file.previewElement) {\r\n            return file.previewElement.classList.add(\"dz-success\");\r\n          }\r\n        },\r\n        successmultiple: function successmultiple() {},\r\n\r\n\r\n        // When the upload is canceled.\r\n        canceled: function canceled(file) {\r\n          return this.emit(\"error\", file, this.options.dictUploadCanceled);\r\n        },\r\n        canceledmultiple: function canceledmultiple() {},\r\n\r\n\r\n        // When the upload is finished, either with success or an error.\r\n        // Receives `file`\r\n        complete: function complete(file) {\r\n          if (file._removeLink) {\r\n            file._removeLink.textContent = this.options.dictRemoveFile;\r\n          }\r\n          if (file.previewElement) {\r\n            return file.previewElement.classList.add(\"dz-complete\");\r\n          }\r\n        },\r\n        completemultiple: function completemultiple() {},\r\n        maxfilesexceeded: function maxfilesexceeded() {},\r\n        maxfilesreached: function maxfilesreached() {},\r\n        queuecomplete: function queuecomplete() {},\r\n        addedfiles: function addedfiles() {}\r\n      };\r\n\r\n      this.prototype._thumbnailQueue = [];\r\n      this.prototype._processingThumbnail = false;\r\n    }\r\n\r\n    // global utility\r\n\r\n  }, {\r\n    key: \"extend\",\r\n    value: function extend(target) {\r\n      for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        objects[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      for (var _iterator9 = objects, _isArray9 = true, _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\r\n        var _ref8;\r\n\r\n        if (_isArray9) {\r\n          if (_i9 >= _iterator9.length) break;\r\n          _ref8 = _iterator9[_i9++];\r\n        } else {\r\n          _i9 = _iterator9.next();\r\n          if (_i9.done) break;\r\n          _ref8 = _i9.value;\r\n        }\r\n\r\n        var object = _ref8;\r\n\r\n        for (var key in object) {\r\n          var val = object[key];\r\n          target[key] = val;\r\n        }\r\n      }\r\n      return target;\r\n    }\r\n  }]);\r\n\r\n  function Dropzone(el, options) {\r\n    _classCallCheck(this, Dropzone);\r\n\r\n    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this));\r\n\r\n    var fallback = void 0,\r\n        left = void 0;\r\n    _this.element = el;\r\n    // For backwards compatibility since the version was in the prototype previously\r\n    _this.version = Dropzone.version;\r\n\r\n    _this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\\n*/g, \"\");\r\n\r\n    _this.clickableElements = [];\r\n    _this.listeners = [];\r\n    _this.files = []; // All files\r\n\r\n    if (typeof _this.element === \"string\") {\r\n      _this.element = document.querySelector(_this.element);\r\n    }\r\n\r\n    // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.\r\n    if (!_this.element || _this.element.nodeType == null) {\r\n      throw new Error(\"Invalid dropzone element.\");\r\n    }\r\n\r\n    if (_this.element.dropzone) {\r\n      throw new Error(\"Dropzone already attached.\");\r\n    }\r\n\r\n    // Now add this dropzone to the instances.\r\n    Dropzone.instances.push(_this);\r\n\r\n    // Put the dropzone inside the element itself.\r\n    _this.element.dropzone = _this;\r\n\r\n    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};\r\n\r\n    _this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {});\r\n\r\n    // If the browser failed, just call the fallback and leave\r\n    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {\r\n      var _ret;\r\n\r\n      return _ret = _this.options.fallback.call(_this), _possibleConstructorReturn(_this, _ret);\r\n    }\r\n\r\n    // @options.url = @element.getAttribute \"action\" unless @options.url?\r\n    if (_this.options.url == null) {\r\n      _this.options.url = _this.element.getAttribute(\"action\");\r\n    }\r\n\r\n    if (!_this.options.url) {\r\n      throw new Error(\"No URL provided.\");\r\n    }\r\n\r\n    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {\r\n      throw new Error(\"You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.\");\r\n    }\r\n\r\n    if (_this.options.uploadMultiple && _this.options.chunking) {\r\n      throw new Error('You cannot set both: uploadMultiple and chunking.');\r\n    }\r\n\r\n    // Backwards compatibility\r\n    if (_this.options.acceptedMimeTypes) {\r\n      _this.options.acceptedFiles = _this.options.acceptedMimeTypes;\r\n      delete _this.options.acceptedMimeTypes;\r\n    }\r\n\r\n    // Backwards compatibility\r\n    if (_this.options.renameFilename != null) {\r\n      _this.options.renameFile = function (file) {\r\n        return _this.options.renameFilename.call(_this, file.name, file);\r\n      };\r\n    }\r\n\r\n    _this.options.method = _this.options.method.toUpperCase();\r\n\r\n    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {\r\n      // Remove the fallback\r\n      fallback.parentNode.removeChild(fallback);\r\n    }\r\n\r\n    // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false\r\n    if (_this.options.previewsContainer !== false) {\r\n      if (_this.options.previewsContainer) {\r\n        _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, \"previewsContainer\");\r\n      } else {\r\n        _this.previewsContainer = _this.element;\r\n      }\r\n    }\r\n\r\n    if (_this.options.clickable) {\r\n      if (_this.options.clickable === true) {\r\n        _this.clickableElements = [_this.element];\r\n      } else {\r\n        _this.clickableElements = Dropzone.getElements(_this.options.clickable, \"clickable\");\r\n      }\r\n    }\r\n\r\n    _this.init();\r\n    return _this;\r\n  }\r\n\r\n  // Returns all files that have been accepted\r\n\r\n\r\n  _createClass(Dropzone, [{\r\n    key: \"getAcceptedFiles\",\r\n    value: function getAcceptedFiles() {\r\n      return this.files.filter(function (file) {\r\n        return file.accepted;\r\n      }).map(function (file) {\r\n        return file;\r\n      });\r\n    }\r\n\r\n    // Returns all files that have been rejected\r\n    // Not sure when that's going to be useful, but added for completeness.\r\n\r\n  }, {\r\n    key: \"getRejectedFiles\",\r\n    value: function getRejectedFiles() {\r\n      return this.files.filter(function (file) {\r\n        return !file.accepted;\r\n      }).map(function (file) {\r\n        return file;\r\n      });\r\n    }\r\n  }, {\r\n    key: \"getFilesWithStatus\",\r\n    value: function getFilesWithStatus(status) {\r\n      return this.files.filter(function (file) {\r\n        return file.status === status;\r\n      }).map(function (file) {\r\n        return file;\r\n      });\r\n    }\r\n\r\n    // Returns all files that are in the queue\r\n\r\n  }, {\r\n    key: \"getQueuedFiles\",\r\n    value: function getQueuedFiles() {\r\n      return this.getFilesWithStatus(Dropzone.QUEUED);\r\n    }\r\n  }, {\r\n    key: \"getUploadingFiles\",\r\n    value: function getUploadingFiles() {\r\n      return this.getFilesWithStatus(Dropzone.UPLOADING);\r\n    }\r\n  }, {\r\n    key: \"getAddedFiles\",\r\n    value: function getAddedFiles() {\r\n      return this.getFilesWithStatus(Dropzone.ADDED);\r\n    }\r\n\r\n    // Files that are either queued or uploading\r\n\r\n  }, {\r\n    key: \"getActiveFiles\",\r\n    value: function getActiveFiles() {\r\n      return this.files.filter(function (file) {\r\n        return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;\r\n      }).map(function (file) {\r\n        return file;\r\n      });\r\n    }\r\n\r\n    // The function that gets called when Dropzone is initialized. You\r\n    // can (and should) setup event listeners inside this function.\r\n\r\n  }, {\r\n    key: \"init\",\r\n    value: function init() {\r\n      var _this3 = this;\r\n\r\n      // In case it isn't set already\r\n      if (this.element.tagName === \"form\") {\r\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\r\n      }\r\n\r\n      if (this.element.classList.contains(\"dropzone\") && !this.element.querySelector(\".dz-message\")) {\r\n        this.element.appendChild(Dropzone.createElement(\"<div class=\\\"dz-default dz-message\\\"><span>\" + this.options.dictDefaultMessage + \"</span></div>\"));\r\n      }\r\n\r\n      if (this.clickableElements.length) {\r\n        var setupHiddenFileInput = function setupHiddenFileInput() {\r\n          if (_this3.hiddenFileInput) {\r\n            _this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);\r\n          }\r\n          _this3.hiddenFileInput = document.createElement(\"input\");\r\n          _this3.hiddenFileInput.setAttribute(\"type\", \"file\");\r\n          if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {\r\n            _this3.hiddenFileInput.setAttribute(\"multiple\", \"multiple\");\r\n          }\r\n          _this3.hiddenFileInput.className = \"dz-hidden-input\";\r\n\r\n          if (_this3.options.acceptedFiles !== null) {\r\n            _this3.hiddenFileInput.setAttribute(\"accept\", _this3.options.acceptedFiles);\r\n          }\r\n          if (_this3.options.capture !== null) {\r\n            _this3.hiddenFileInput.setAttribute(\"capture\", _this3.options.capture);\r\n          }\r\n\r\n          // Not setting `display=\"none\"` because some browsers don't accept clicks\r\n          // on elements that aren't displayed.\r\n          _this3.hiddenFileInput.style.visibility = \"hidden\";\r\n          _this3.hiddenFileInput.style.position = \"absolute\";\r\n          _this3.hiddenFileInput.style.top = \"0\";\r\n          _this3.hiddenFileInput.style.left = \"0\";\r\n          _this3.hiddenFileInput.style.height = \"0\";\r\n          _this3.hiddenFileInput.style.width = \"0\";\r\n          document.querySelector(_this3.options.hiddenInputContainer).appendChild(_this3.hiddenFileInput);\r\n          return _this3.hiddenFileInput.addEventListener(\"change\", function () {\r\n            var files = _this3.hiddenFileInput.files;\r\n\r\n            if (files.length) {\r\n              for (var _iterator10 = files, _isArray10 = true, _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\r\n                var _ref9;\r\n\r\n                if (_isArray10) {\r\n                  if (_i10 >= _iterator10.length) break;\r\n                  _ref9 = _iterator10[_i10++];\r\n                } else {\r\n                  _i10 = _iterator10.next();\r\n                  if (_i10.done) break;\r\n                  _ref9 = _i10.value;\r\n                }\r\n\r\n                var file = _ref9;\r\n\r\n                _this3.addFile(file);\r\n              }\r\n            }\r\n            _this3.emit(\"addedfiles\", files);\r\n            return setupHiddenFileInput();\r\n          });\r\n        };\r\n        setupHiddenFileInput();\r\n      }\r\n\r\n      this.URL = window.URL !== null ? window.URL : window.webkitURL;\r\n\r\n      // Setup all event listeners on the Dropzone object itself.\r\n      // They're not in @setupEventListeners() because they shouldn't be removed\r\n      // again when the dropzone gets disabled.\r\n      for (var _iterator11 = this.events, _isArray11 = true, _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {\r\n        var _ref10;\r\n\r\n        if (_isArray11) {\r\n          if (_i11 >= _iterator11.length) break;\r\n          _ref10 = _iterator11[_i11++];\r\n        } else {\r\n          _i11 = _iterator11.next();\r\n          if (_i11.done) break;\r\n          _ref10 = _i11.value;\r\n        }\r\n\r\n        var eventName = _ref10;\r\n\r\n        this.on(eventName, this.options[eventName]);\r\n      }\r\n\r\n      this.on(\"uploadprogress\", function () {\r\n        return _this3.updateTotalUploadProgress();\r\n      });\r\n\r\n      this.on(\"removedfile\", function () {\r\n        return _this3.updateTotalUploadProgress();\r\n      });\r\n\r\n      this.on(\"canceled\", function (file) {\r\n        return _this3.emit(\"complete\", file);\r\n      });\r\n\r\n      // Emit a `queuecomplete` event if all files finished uploading.\r\n      this.on(\"complete\", function (file) {\r\n        if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {\r\n          // This needs to be deferred so that `queuecomplete` really triggers after `complete`\r\n          return setTimeout(function () {\r\n            return _this3.emit(\"queuecomplete\");\r\n          }, 0);\r\n        }\r\n      });\r\n\r\n      var noPropagation = function noPropagation(e) {\r\n        e.stopPropagation();\r\n        if (e.preventDefault) {\r\n          return e.preventDefault();\r\n        } else {\r\n          return e.returnValue = false;\r\n        }\r\n      };\r\n\r\n      // Create the listeners\r\n      this.listeners = [{\r\n        element: this.element,\r\n        events: {\r\n          \"dragstart\": function dragstart(e) {\r\n            return _this3.emit(\"dragstart\", e);\r\n          },\r\n          \"dragenter\": function dragenter(e) {\r\n            noPropagation(e);\r\n            return _this3.emit(\"dragenter\", e);\r\n          },\r\n          \"dragover\": function dragover(e) {\r\n            // Makes it possible to drag files from chrome's download bar\r\n            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar\r\n            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)\r\n            var efct = void 0;\r\n            try {\r\n              efct = e.dataTransfer.effectAllowed;\r\n            } catch (error) {}\r\n            e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';\r\n\r\n            noPropagation(e);\r\n            return _this3.emit(\"dragover\", e);\r\n          },\r\n          \"dragleave\": function dragleave(e) {\r\n            return _this3.emit(\"dragleave\", e);\r\n          },\r\n          \"drop\": function drop(e) {\r\n            noPropagation(e);\r\n            return _this3.drop(e);\r\n          },\r\n          \"dragend\": function dragend(e) {\r\n            return _this3.emit(\"dragend\", e);\r\n          }\r\n\r\n          // This is disabled right now, because the browsers don't implement it properly.\r\n          // \"paste\": (e) =>\r\n          //   noPropagation e\r\n          //   @paste e\r\n        } }];\r\n\r\n      this.clickableElements.forEach(function (clickableElement) {\r\n        return _this3.listeners.push({\r\n          element: clickableElement,\r\n          events: {\r\n            \"click\": function click(evt) {\r\n              // Only the actual dropzone or the message element should trigger file selection\r\n              if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(\".dz-message\"))) {\r\n                _this3.hiddenFileInput.click(); // Forward the click\r\n              }\r\n              return true;\r\n            }\r\n          }\r\n        });\r\n      });\r\n\r\n      this.enable();\r\n\r\n      return this.options.init.call(this);\r\n    }\r\n\r\n    // Not fully tested yet\r\n\r\n  }, {\r\n    key: \"destroy\",\r\n    value: function destroy() {\r\n      this.disable();\r\n      this.removeAllFiles(true);\r\n      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {\r\n        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\r\n        this.hiddenFileInput = null;\r\n      }\r\n      delete this.element.dropzone;\r\n      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\r\n    }\r\n  }, {\r\n    key: \"updateTotalUploadProgress\",\r\n    value: function updateTotalUploadProgress() {\r\n      var totalUploadProgress = void 0;\r\n      var totalBytesSent = 0;\r\n      var totalBytes = 0;\r\n\r\n      var activeFiles = this.getActiveFiles();\r\n\r\n      if (activeFiles.length) {\r\n        for (var _iterator12 = this.getActiveFiles(), _isArray12 = true, _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {\r\n          var _ref11;\r\n\r\n          if (_isArray12) {\r\n            if (_i12 >= _iterator12.length) break;\r\n            _ref11 = _iterator12[_i12++];\r\n          } else {\r\n            _i12 = _iterator12.next();\r\n            if (_i12.done) break;\r\n            _ref11 = _i12.value;\r\n          }\r\n\r\n          var file = _ref11;\r\n\r\n          totalBytesSent += file.upload.bytesSent;\r\n          totalBytes += file.upload.total;\r\n        }\r\n        totalUploadProgress = 100 * totalBytesSent / totalBytes;\r\n      } else {\r\n        totalUploadProgress = 100;\r\n      }\r\n\r\n      return this.emit(\"totaluploadprogress\", totalUploadProgress, totalBytes, totalBytesSent);\r\n    }\r\n\r\n    // @options.paramName can be a function taking one parameter rather than a string.\r\n    // A parameter name for a file is obtained simply by calling this with an index number.\r\n\r\n  }, {\r\n    key: \"_getParamName\",\r\n    value: function _getParamName(n) {\r\n      if (typeof this.options.paramName === \"function\") {\r\n        return this.options.paramName(n);\r\n      } else {\r\n        return \"\" + this.options.paramName + (this.options.uploadMultiple ? \"[\" + n + \"]\" : \"\");\r\n      }\r\n    }\r\n\r\n    // If @options.renameFile is a function,\r\n    // the function will be used to rename the file.name before appending it to the formData\r\n\r\n  }, {\r\n    key: \"_renameFile\",\r\n    value: function _renameFile(file) {\r\n      if (typeof this.options.renameFile !== \"function\") {\r\n        return file.name;\r\n      }\r\n      return this.options.renameFile(file);\r\n    }\r\n\r\n    // Returns a form that can be used as fallback if the browser does not support DragnDrop\r\n    //\r\n    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.\r\n    // This code has to pass in IE7 :(\r\n\r\n  }, {\r\n    key: \"getFallbackForm\",\r\n    value: function getFallbackForm() {\r\n      var existingFallback = void 0,\r\n          form = void 0;\r\n      if (existingFallback = this.getExistingFallback()) {\r\n        return existingFallback;\r\n      }\r\n\r\n      var fieldsString = \"<div class=\\\"dz-fallback\\\">\";\r\n      if (this.options.dictFallbackText) {\r\n        fieldsString += \"<p>\" + this.options.dictFallbackText + \"</p>\";\r\n      }\r\n      fieldsString += \"<input type=\\\"file\\\" name=\\\"\" + this._getParamName(0) + \"\\\" \" + (this.options.uploadMultiple ? 'multiple=\"multiple\"' : undefined) + \" /><input type=\\\"submit\\\" value=\\\"Upload!\\\"></div>\";\r\n\r\n      var fields = Dropzone.createElement(fieldsString);\r\n      if (this.element.tagName !== \"FORM\") {\r\n        form = Dropzone.createElement(\"<form action=\\\"\" + this.options.url + \"\\\" enctype=\\\"multipart/form-data\\\" method=\\\"\" + this.options.method + \"\\\"></form>\");\r\n        form.appendChild(fields);\r\n      } else {\r\n        // Make sure that the enctype and method attributes are set properly\r\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\r\n        this.element.setAttribute(\"method\", this.options.method);\r\n      }\r\n      return form != null ? form : fields;\r\n    }\r\n\r\n    // Returns the fallback elements if they exist already\r\n    //\r\n    // This code has to pass in IE7 :(\r\n\r\n  }, {\r\n    key: \"getExistingFallback\",\r\n    value: function getExistingFallback() {\r\n      var getFallback = function getFallback(elements) {\r\n        for (var _iterator13 = elements, _isArray13 = true, _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {\r\n          var _ref12;\r\n\r\n          if (_isArray13) {\r\n            if (_i13 >= _iterator13.length) break;\r\n            _ref12 = _iterator13[_i13++];\r\n          } else {\r\n            _i13 = _iterator13.next();\r\n            if (_i13.done) break;\r\n            _ref12 = _i13.value;\r\n          }\r\n\r\n          var el = _ref12;\r\n\r\n          if (/(^| )fallback($| )/.test(el.className)) {\r\n            return el;\r\n          }\r\n        }\r\n      };\r\n\r\n      var _arr = [\"div\", \"form\"];\r\n      for (var _i14 = 0; _i14 < _arr.length; _i14++) {\r\n        var tagName = _arr[_i14];\r\n        var fallback;\r\n        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\r\n          return fallback;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Activates all listeners stored in @listeners\r\n\r\n  }, {\r\n    key: \"setupEventListeners\",\r\n    value: function setupEventListeners() {\r\n      return this.listeners.map(function (elementListeners) {\r\n        return function () {\r\n          var result = [];\r\n          for (var event in elementListeners.events) {\r\n            var listener = elementListeners.events[event];\r\n            result.push(elementListeners.element.addEventListener(event, listener, false));\r\n          }\r\n          return result;\r\n        }();\r\n      });\r\n    }\r\n\r\n    // Deactivates all listeners stored in @listeners\r\n\r\n  }, {\r\n    key: \"removeEventListeners\",\r\n    value: function removeEventListeners() {\r\n      return this.listeners.map(function (elementListeners) {\r\n        return function () {\r\n          var result = [];\r\n          for (var event in elementListeners.events) {\r\n            var listener = elementListeners.events[event];\r\n            result.push(elementListeners.element.removeEventListener(event, listener, false));\r\n          }\r\n          return result;\r\n        }();\r\n      });\r\n    }\r\n\r\n    // Removes all event listeners and cancels all files in the queue or being processed.\r\n\r\n  }, {\r\n    key: \"disable\",\r\n    value: function disable() {\r\n      var _this4 = this;\r\n\r\n      this.clickableElements.forEach(function (element) {\r\n        return element.classList.remove(\"dz-clickable\");\r\n      });\r\n      this.removeEventListeners();\r\n      this.disabled = true;\r\n\r\n      return this.files.map(function (file) {\r\n        return _this4.cancelUpload(file);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"enable\",\r\n    value: function enable() {\r\n      delete this.disabled;\r\n      this.clickableElements.forEach(function (element) {\r\n        return element.classList.add(\"dz-clickable\");\r\n      });\r\n      return this.setupEventListeners();\r\n    }\r\n\r\n    // Returns a nicely formatted filesize\r\n\r\n  }, {\r\n    key: \"filesize\",\r\n    value: function filesize(size) {\r\n      var selectedSize = 0;\r\n      var selectedUnit = \"b\";\r\n\r\n      if (size > 0) {\r\n        var units = ['tb', 'gb', 'mb', 'kb', 'b'];\r\n\r\n        for (var i = 0; i < units.length; i++) {\r\n          var unit = units[i];\r\n          var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\r\n\r\n          if (size >= cutoff) {\r\n            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\r\n            selectedUnit = unit;\r\n            break;\r\n          }\r\n        }\r\n\r\n        selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits\r\n      }\r\n\r\n      return \"<strong>\" + selectedSize + \"</strong> \" + this.options.dictFileSizeUnits[selectedUnit];\r\n    }\r\n\r\n    // Adds or removes the `dz-max-files-reached` class from the form.\r\n\r\n  }, {\r\n    key: \"_updateMaxFilesReachedClass\",\r\n    value: function _updateMaxFilesReachedClass() {\r\n      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\r\n        if (this.getAcceptedFiles().length === this.options.maxFiles) {\r\n          this.emit('maxfilesreached', this.files);\r\n        }\r\n        return this.element.classList.add(\"dz-max-files-reached\");\r\n      } else {\r\n        return this.element.classList.remove(\"dz-max-files-reached\");\r\n      }\r\n    }\r\n  }, {\r\n    key: \"drop\",\r\n    value: function drop(e) {\r\n      if (!e.dataTransfer) {\r\n        return;\r\n      }\r\n      this.emit(\"drop\", e);\r\n\r\n      // Convert the FileList to an Array\r\n      // This is necessary for IE11\r\n      var files = [];\r\n      for (var i = 0; i < e.dataTransfer.files.length; i++) {\r\n        files[i] = e.dataTransfer.files[i];\r\n      }\r\n\r\n      this.emit(\"addedfiles\", files);\r\n\r\n      // Even if it's a folder, files.length will contain the folders.\r\n      if (files.length) {\r\n        var items = e.dataTransfer.items;\r\n\r\n        if (items && items.length && items[0].webkitGetAsEntry != null) {\r\n          // The browser supports dropping of folders, so handle items instead of files\r\n          this._addFilesFromItems(items);\r\n        } else {\r\n          this.handleFiles(files);\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: \"paste\",\r\n    value: function paste(e) {\r\n      if (__guard__(e != null ? e.clipboardData : undefined, function (x) {\r\n        return x.items;\r\n      }) == null) {\r\n        return;\r\n      }\r\n\r\n      this.emit(\"paste\", e);\r\n      var items = e.clipboardData.items;\r\n\r\n\r\n      if (items.length) {\r\n        return this._addFilesFromItems(items);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"handleFiles\",\r\n    value: function handleFiles(files) {\r\n      for (var _iterator14 = files, _isArray14 = true, _i15 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {\r\n        var _ref13;\r\n\r\n        if (_isArray14) {\r\n          if (_i15 >= _iterator14.length) break;\r\n          _ref13 = _iterator14[_i15++];\r\n        } else {\r\n          _i15 = _iterator14.next();\r\n          if (_i15.done) break;\r\n          _ref13 = _i15.value;\r\n        }\r\n\r\n        var file = _ref13;\r\n\r\n        this.addFile(file);\r\n      }\r\n    }\r\n\r\n    // When a folder is dropped (or files are pasted), items must be handled\r\n    // instead of files.\r\n\r\n  }, {\r\n    key: \"_addFilesFromItems\",\r\n    value: function _addFilesFromItems(items) {\r\n      var _this5 = this;\r\n\r\n      return function () {\r\n        var result = [];\r\n        for (var _iterator15 = items, _isArray15 = true, _i16 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {\r\n          var _ref14;\r\n\r\n          if (_isArray15) {\r\n            if (_i16 >= _iterator15.length) break;\r\n            _ref14 = _iterator15[_i16++];\r\n          } else {\r\n            _i16 = _iterator15.next();\r\n            if (_i16.done) break;\r\n            _ref14 = _i16.value;\r\n          }\r\n\r\n          var item = _ref14;\r\n\r\n          var entry;\r\n          if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {\r\n            if (entry.isFile) {\r\n              result.push(_this5.addFile(item.getAsFile()));\r\n            } else if (entry.isDirectory) {\r\n              // Append all files from that directory to files\r\n              result.push(_this5._addFilesFromDirectory(entry, entry.name));\r\n            } else {\r\n              result.push(undefined);\r\n            }\r\n          } else if (item.getAsFile != null) {\r\n            if (item.kind == null || item.kind === \"file\") {\r\n              result.push(_this5.addFile(item.getAsFile()));\r\n            } else {\r\n              result.push(undefined);\r\n            }\r\n          } else {\r\n            result.push(undefined);\r\n          }\r\n        }\r\n        return result;\r\n      }();\r\n    }\r\n\r\n    // Goes through the directory, and adds each file it finds recursively\r\n\r\n  }, {\r\n    key: \"_addFilesFromDirectory\",\r\n    value: function _addFilesFromDirectory(directory, path) {\r\n      var _this6 = this;\r\n\r\n      var dirReader = directory.createReader();\r\n\r\n      var errorHandler = function errorHandler(error) {\r\n        return __guardMethod__(console, 'log', function (o) {\r\n          return o.log(error);\r\n        });\r\n      };\r\n\r\n      var readEntries = function readEntries() {\r\n        return dirReader.readEntries(function (entries) {\r\n          if (entries.length > 0) {\r\n            for (var _iterator16 = entries, _isArray16 = true, _i17 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {\r\n              var _ref15;\r\n\r\n              if (_isArray16) {\r\n                if (_i17 >= _iterator16.length) break;\r\n                _ref15 = _iterator16[_i17++];\r\n              } else {\r\n                _i17 = _iterator16.next();\r\n                if (_i17.done) break;\r\n                _ref15 = _i17.value;\r\n              }\r\n\r\n              var entry = _ref15;\r\n\r\n              if (entry.isFile) {\r\n                entry.file(function (file) {\r\n                  if (_this6.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {\r\n                    return;\r\n                  }\r\n                  file.fullPath = path + \"/\" + file.name;\r\n                  return _this6.addFile(file);\r\n                });\r\n              } else if (entry.isDirectory) {\r\n                _this6._addFilesFromDirectory(entry, path + \"/\" + entry.name);\r\n              }\r\n            }\r\n\r\n            // Recursively call readEntries() again, since browser only handle\r\n            // the first 100 entries.\r\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries\r\n            readEntries();\r\n          }\r\n          return null;\r\n        }, errorHandler);\r\n      };\r\n\r\n      return readEntries();\r\n    }\r\n\r\n    // If `done()` is called without argument the file is accepted\r\n    // If you call it with an error message, the file is rejected\r\n    // (This allows for asynchronous validation)\r\n    //\r\n    // This function checks the filesize, and if the file.type passes the\r\n    // `acceptedFiles` check.\r\n\r\n  }, {\r\n    key: \"accept\",\r\n    value: function accept(file, done) {\r\n      if (file.size > this.options.maxFilesize * 1024 * 1024) {\r\n        return done(this.options.dictFileTooBig.replace(\"{{filesize}}\", Math.round(file.size / 1024 / 10.24) / 100).replace(\"{{maxFilesize}}\", this.options.maxFilesize));\r\n      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\r\n        return done(this.options.dictInvalidFileType);\r\n      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\r\n        done(this.options.dictMaxFilesExceeded.replace(\"{{maxFiles}}\", this.options.maxFiles));\r\n        return this.emit(\"maxfilesexceeded\", file);\r\n      } else {\r\n        return this.options.accept.call(this, file, done);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"addFile\",\r\n    value: function addFile(file) {\r\n      var _this7 = this;\r\n\r\n      file.upload = {\r\n        uuid: Dropzone.uuidv4(),\r\n        progress: 0,\r\n        // Setting the total upload size to file.size for the beginning\r\n        // It's actual different than the size to be transmitted.\r\n        total: file.size,\r\n        bytesSent: 0,\r\n        filename: this._renameFile(file),\r\n        chunked: this.options.chunking && (this.options.forceChunking || file.size > this.options.chunkSize),\r\n        totalChunkCount: Math.ceil(file.size / this.options.chunkSize)\r\n      };\r\n      this.files.push(file);\r\n\r\n      file.status = Dropzone.ADDED;\r\n\r\n      this.emit(\"addedfile\", file);\r\n\r\n      this._enqueueThumbnail(file);\r\n\r\n      return this.accept(file, function (error) {\r\n        if (error) {\r\n          file.accepted = false;\r\n          _this7._errorProcessing([file], error); // Will set the file.status\r\n        } else {\r\n          file.accepted = true;\r\n          if (_this7.options.autoQueue) {\r\n            _this7.enqueueFile(file);\r\n          } // Will set .accepted = true\r\n        }\r\n        return _this7._updateMaxFilesReachedClass();\r\n      });\r\n    }\r\n\r\n    // Wrapper for enqueueFile\r\n\r\n  }, {\r\n    key: \"enqueueFiles\",\r\n    value: function enqueueFiles(files) {\r\n      for (var _iterator17 = files, _isArray17 = true, _i18 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {\r\n        var _ref16;\r\n\r\n        if (_isArray17) {\r\n          if (_i18 >= _iterator17.length) break;\r\n          _ref16 = _iterator17[_i18++];\r\n        } else {\r\n          _i18 = _iterator17.next();\r\n          if (_i18.done) break;\r\n          _ref16 = _i18.value;\r\n        }\r\n\r\n        var file = _ref16;\r\n\r\n        this.enqueueFile(file);\r\n      }\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"enqueueFile\",\r\n    value: function enqueueFile(file) {\r\n      var _this8 = this;\r\n\r\n      if (file.status === Dropzone.ADDED && file.accepted === true) {\r\n        file.status = Dropzone.QUEUED;\r\n        if (this.options.autoProcessQueue) {\r\n          return setTimeout(function () {\r\n            return _this8.processQueue();\r\n          }, 0); // Deferring the call\r\n        }\r\n      } else {\r\n        throw new Error(\"This file can't be queued because it has already been processed or was rejected.\");\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_enqueueThumbnail\",\r\n    value: function _enqueueThumbnail(file) {\r\n      var _this9 = this;\r\n\r\n      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\r\n        this._thumbnailQueue.push(file);\r\n        return setTimeout(function () {\r\n          return _this9._processThumbnailQueue();\r\n        }, 0); // Deferring the call\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_processThumbnailQueue\",\r\n    value: function _processThumbnailQueue() {\r\n      var _this10 = this;\r\n\r\n      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\r\n        return;\r\n      }\r\n\r\n      this._processingThumbnail = true;\r\n      var file = this._thumbnailQueue.shift();\r\n      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {\r\n        _this10.emit(\"thumbnail\", file, dataUrl);\r\n        _this10._processingThumbnail = false;\r\n        return _this10._processThumbnailQueue();\r\n      });\r\n    }\r\n\r\n    // Can be called by the user to remove a file\r\n\r\n  }, {\r\n    key: \"removeFile\",\r\n    value: function removeFile(file) {\r\n      if (file.status === Dropzone.UPLOADING) {\r\n        this.cancelUpload(file);\r\n      }\r\n      this.files = without(this.files, file);\r\n\r\n      this.emit(\"removedfile\", file);\r\n      if (this.files.length === 0) {\r\n        return this.emit(\"reset\");\r\n      }\r\n    }\r\n\r\n    // Removes all files that aren't currently processed from the list\r\n\r\n  }, {\r\n    key: \"removeAllFiles\",\r\n    value: function removeAllFiles(cancelIfNecessary) {\r\n      // Create a copy of files since removeFile() changes the @files array.\r\n      if (cancelIfNecessary == null) {\r\n        cancelIfNecessary = false;\r\n      }\r\n      for (var _iterator18 = this.files.slice(), _isArray18 = true, _i19 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();;) {\r\n        var _ref17;\r\n\r\n        if (_isArray18) {\r\n          if (_i19 >= _iterator18.length) break;\r\n          _ref17 = _iterator18[_i19++];\r\n        } else {\r\n          _i19 = _iterator18.next();\r\n          if (_i19.done) break;\r\n          _ref17 = _i19.value;\r\n        }\r\n\r\n        var file = _ref17;\r\n\r\n        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\r\n          this.removeFile(file);\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // Resizes an image before it gets sent to the server. This function is the default behavior of\r\n    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with\r\n    // the resized blob.\r\n\r\n  }, {\r\n    key: \"resizeImage\",\r\n    value: function resizeImage(file, width, height, resizeMethod, callback) {\r\n      var _this11 = this;\r\n\r\n      return this.createThumbnail(file, width, height, resizeMethod, false, function (dataUrl, canvas) {\r\n        if (canvas == null) {\r\n          // The image has not been resized\r\n          return callback(file);\r\n        } else {\r\n          var resizeMimeType = _this11.options.resizeMimeType;\r\n\r\n          if (resizeMimeType == null) {\r\n            resizeMimeType = file.type;\r\n          }\r\n          var resizedDataURL = canvas.toDataURL(resizeMimeType, _this11.options.resizeQuality);\r\n          if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {\r\n            // Now add the original EXIF information\r\n            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\r\n          }\r\n          return callback(Dropzone.dataURItoBlob(resizedDataURL));\r\n        }\r\n      });\r\n    }\r\n  }, {\r\n    key: \"createThumbnail\",\r\n    value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {\r\n      var _this12 = this;\r\n\r\n      var fileReader = new FileReader();\r\n\r\n      fileReader.onload = function () {\r\n\r\n        file.dataURL = fileReader.result;\r\n\r\n        // Don't bother creating a thumbnail for SVG images since they're vector\r\n        if (file.type === \"image/svg+xml\") {\r\n          if (callback != null) {\r\n            callback(fileReader.result);\r\n          }\r\n          return;\r\n        }\r\n\r\n        return _this12.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);\r\n      };\r\n\r\n      return fileReader.readAsDataURL(file);\r\n    }\r\n  }, {\r\n    key: \"createThumbnailFromUrl\",\r\n    value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {\r\n      var _this13 = this;\r\n\r\n      // Not using `new Image` here because of a bug in latest Chrome versions.\r\n      // See https://github.com/enyo/dropzone/pull/226\r\n      var img = document.createElement(\"img\");\r\n\r\n      if (crossOrigin) {\r\n        img.crossOrigin = crossOrigin;\r\n      }\r\n\r\n      img.onload = function () {\r\n        var loadExif = function loadExif(callback) {\r\n          return callback(1);\r\n        };\r\n        if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {\r\n          loadExif = function loadExif(callback) {\r\n            return EXIF.getData(img, function () {\r\n              return callback(EXIF.getTag(this, 'Orientation'));\r\n            });\r\n          };\r\n        }\r\n\r\n        return loadExif(function (orientation) {\r\n          file.width = img.width;\r\n          file.height = img.height;\r\n\r\n          var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);\r\n\r\n          var canvas = document.createElement(\"canvas\");\r\n          var ctx = canvas.getContext(\"2d\");\r\n\r\n          canvas.width = resizeInfo.trgWidth;\r\n          canvas.height = resizeInfo.trgHeight;\r\n\r\n          if (orientation > 4) {\r\n            canvas.width = resizeInfo.trgHeight;\r\n            canvas.height = resizeInfo.trgWidth;\r\n          }\r\n\r\n          switch (orientation) {\r\n            case 2:\r\n              // horizontal flip\r\n              ctx.translate(canvas.width, 0);\r\n              ctx.scale(-1, 1);\r\n              break;\r\n            case 3:\r\n              // 180Â° rotate left\r\n              ctx.translate(canvas.width, canvas.height);\r\n              ctx.rotate(Math.PI);\r\n              break;\r\n            case 4:\r\n              // vertical flip\r\n              ctx.translate(0, canvas.height);\r\n              ctx.scale(1, -1);\r\n              break;\r\n            case 5:\r\n              // vertical flip + 90 rotate right\r\n              ctx.rotate(0.5 * Math.PI);\r\n              ctx.scale(1, -1);\r\n              break;\r\n            case 6:\r\n              // 90Â° rotate right\r\n              ctx.rotate(0.5 * Math.PI);\r\n              ctx.translate(0, -canvas.height);\r\n              break;\r\n            case 7:\r\n              // horizontal flip + 90 rotate right\r\n              ctx.rotate(0.5 * Math.PI);\r\n              ctx.translate(canvas.width, -canvas.height);\r\n              ctx.scale(-1, 1);\r\n              break;\r\n            case 8:\r\n              // 90Â° rotate left\r\n              ctx.rotate(-0.5 * Math.PI);\r\n              ctx.translate(-canvas.width, 0);\r\n              break;\r\n          }\r\n\r\n          // This is a bugfix for iOS' scaling bug.\r\n          drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\r\n\r\n          var thumbnail = canvas.toDataURL(\"image/png\");\r\n\r\n          if (callback != null) {\r\n            return callback(thumbnail, canvas);\r\n          }\r\n        });\r\n      };\r\n\r\n      if (callback != null) {\r\n        img.onerror = callback;\r\n      }\r\n\r\n      return img.src = file.dataURL;\r\n    }\r\n\r\n    // Goes through the queue and processes files if there aren't too many already.\r\n\r\n  }, {\r\n    key: \"processQueue\",\r\n    value: function processQueue() {\r\n      var parallelUploads = this.options.parallelUploads;\r\n\r\n      var processingLength = this.getUploadingFiles().length;\r\n      var i = processingLength;\r\n\r\n      // There are already at least as many files uploading than should be\r\n      if (processingLength >= parallelUploads) {\r\n        return;\r\n      }\r\n\r\n      var queuedFiles = this.getQueuedFiles();\r\n\r\n      if (!(queuedFiles.length > 0)) {\r\n        return;\r\n      }\r\n\r\n      if (this.options.uploadMultiple) {\r\n        // The files should be uploaded in one request\r\n        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\r\n      } else {\r\n        while (i < parallelUploads) {\r\n          if (!queuedFiles.length) {\r\n            return;\r\n          } // Nothing left to process\r\n          this.processFile(queuedFiles.shift());\r\n          i++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Wrapper for `processFiles`\r\n\r\n  }, {\r\n    key: \"processFile\",\r\n    value: function processFile(file) {\r\n      return this.processFiles([file]);\r\n    }\r\n\r\n    // Loads the file, then calls finishedLoading()\r\n\r\n  }, {\r\n    key: \"processFiles\",\r\n    value: function processFiles(files) {\r\n      for (var _iterator19 = files, _isArray19 = true, _i20 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator]();;) {\r\n        var _ref18;\r\n\r\n        if (_isArray19) {\r\n          if (_i20 >= _iterator19.length) break;\r\n          _ref18 = _iterator19[_i20++];\r\n        } else {\r\n          _i20 = _iterator19.next();\r\n          if (_i20.done) break;\r\n          _ref18 = _i20.value;\r\n        }\r\n\r\n        var file = _ref18;\r\n\r\n        file.processing = true; // Backwards compatibility\r\n        file.status = Dropzone.UPLOADING;\r\n\r\n        this.emit(\"processing\", file);\r\n      }\r\n\r\n      if (this.options.uploadMultiple) {\r\n        this.emit(\"processingmultiple\", files);\r\n      }\r\n\r\n      return this.uploadFiles(files);\r\n    }\r\n  }, {\r\n    key: \"_getFilesWithXhr\",\r\n    value: function _getFilesWithXhr(xhr) {\r\n      var files = void 0;\r\n      return files = this.files.filter(function (file) {\r\n        return file.xhr === xhr;\r\n      }).map(function (file) {\r\n        return file;\r\n      });\r\n    }\r\n\r\n    // Cancels the file upload and sets the status to CANCELED\r\n    // **if** the file is actually being uploaded.\r\n    // If it's still in the queue, the file is being removed from it and the status\r\n    // set to CANCELED.\r\n\r\n  }, {\r\n    key: \"cancelUpload\",\r\n    value: function cancelUpload(file) {\r\n      if (file.status === Dropzone.UPLOADING) {\r\n        var groupedFiles = this._getFilesWithXhr(file.xhr);\r\n        for (var _iterator20 = groupedFiles, _isArray20 = true, _i21 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator]();;) {\r\n          var _ref19;\r\n\r\n          if (_isArray20) {\r\n            if (_i21 >= _iterator20.length) break;\r\n            _ref19 = _iterator20[_i21++];\r\n          } else {\r\n            _i21 = _iterator20.next();\r\n            if (_i21.done) break;\r\n            _ref19 = _i21.value;\r\n          }\r\n\r\n          var groupedFile = _ref19;\r\n\r\n          groupedFile.status = Dropzone.CANCELED;\r\n        }\r\n        if (typeof file.xhr !== 'undefined') {\r\n          file.xhr.abort();\r\n        }\r\n        for (var _iterator21 = groupedFiles, _isArray21 = true, _i22 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator]();;) {\r\n          var _ref20;\r\n\r\n          if (_isArray21) {\r\n            if (_i22 >= _iterator21.length) break;\r\n            _ref20 = _iterator21[_i22++];\r\n          } else {\r\n            _i22 = _iterator21.next();\r\n            if (_i22.done) break;\r\n            _ref20 = _i22.value;\r\n          }\r\n\r\n          var _groupedFile = _ref20;\r\n\r\n          this.emit(\"canceled\", _groupedFile);\r\n        }\r\n        if (this.options.uploadMultiple) {\r\n          this.emit(\"canceledmultiple\", groupedFiles);\r\n        }\r\n      } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {\r\n        file.status = Dropzone.CANCELED;\r\n        this.emit(\"canceled\", file);\r\n        if (this.options.uploadMultiple) {\r\n          this.emit(\"canceledmultiple\", [file]);\r\n        }\r\n      }\r\n\r\n      if (this.options.autoProcessQueue) {\r\n        return this.processQueue();\r\n      }\r\n    }\r\n  }, {\r\n    key: \"resolveOption\",\r\n    value: function resolveOption(option) {\r\n      if (typeof option === 'function') {\r\n        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\r\n          args[_key3 - 1] = arguments[_key3];\r\n        }\r\n\r\n        return option.apply(this, args);\r\n      }\r\n      return option;\r\n    }\r\n  }, {\r\n    key: \"uploadFile\",\r\n    value: function uploadFile(file) {\r\n      return this.uploadFiles([file]);\r\n    }\r\n  }, {\r\n    key: \"uploadFiles\",\r\n    value: function uploadFiles(files) {\r\n      var _this14 = this;\r\n\r\n      this._transformFiles(files, function (transformedFiles) {\r\n        if (files[0].upload.chunked) {\r\n          // This file should be sent in chunks!\r\n\r\n          // If the chunking option is set, we **know** that there can only be **one** file, since\r\n          // uploadMultiple is not allowed with this option.\r\n          var file = files[0];\r\n          var transformedFile = transformedFiles[0];\r\n          var startedChunkCount = 0;\r\n\r\n          file.upload.chunks = [];\r\n\r\n          var handleNextChunk = function handleNextChunk() {\r\n            var chunkIndex = 0;\r\n\r\n            // Find the next item in file.upload.chunks that is not defined yet.\r\n            while (file.upload.chunks[chunkIndex] !== undefined) {\r\n              chunkIndex++;\r\n            }\r\n\r\n            // This means, that all chunks have already been started.\r\n            if (chunkIndex >= file.upload.totalChunkCount) return;\r\n\r\n            startedChunkCount++;\r\n\r\n            var start = chunkIndex * _this14.options.chunkSize;\r\n            var end = Math.min(start + _this14.options.chunkSize, file.size);\r\n\r\n            var dataBlock = {\r\n              name: _this14._getParamName(0),\r\n              data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),\r\n              filename: file.upload.filename,\r\n              chunkIndex: chunkIndex\r\n            };\r\n\r\n            file.upload.chunks[chunkIndex] = {\r\n              file: file,\r\n              index: chunkIndex,\r\n              dataBlock: dataBlock, // In case we want to retry.\r\n              status: Dropzone.UPLOADING,\r\n              progress: 0,\r\n              retries: 0 // The number of times this block has been retried.\r\n            };\r\n\r\n            _this14._uploadData(files, [dataBlock]);\r\n          };\r\n\r\n          file.upload.finishedChunkUpload = function (chunk) {\r\n            var allFinished = true;\r\n            chunk.status = Dropzone.SUCCESS;\r\n\r\n            // Clear the data from the chunk\r\n            chunk.dataBlock = null;\r\n\r\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\r\n              if (file.upload.chunks[i] === undefined) {\r\n                return handleNextChunk();\r\n              }\r\n              if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {\r\n                allFinished = false;\r\n              }\r\n            }\r\n\r\n            if (allFinished) {\r\n              _this14.options.chunksUploaded(file, function () {\r\n                _this14._finished(files, '', null);\r\n              });\r\n            }\r\n          };\r\n\r\n          if (_this14.options.parallelChunkUploads) {\r\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\r\n              handleNextChunk();\r\n            }\r\n          } else {\r\n            handleNextChunk();\r\n          }\r\n        } else {\r\n          var dataBlocks = [];\r\n          for (var _i23 = 0; _i23 < files.length; _i23++) {\r\n            dataBlocks[_i23] = {\r\n              name: _this14._getParamName(_i23),\r\n              data: transformedFiles[_i23],\r\n              filename: files[_i23].upload.filename\r\n            };\r\n          }\r\n          _this14._uploadData(files, dataBlocks);\r\n        }\r\n      });\r\n    }\r\n\r\n    /// Returns the right chunk for given file and xhr\r\n\r\n  }, {\r\n    key: \"_getChunk\",\r\n    value: function _getChunk(file, xhr) {\r\n      for (var i = 0; i < file.upload.totalChunkCount; i++) {\r\n        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {\r\n          return file.upload.chunks[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    // This function actually uploads the file(s) to the server.\r\n    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed\r\n    // files, or individual chunks for chunked upload).\r\n\r\n  }, {\r\n    key: \"_uploadData\",\r\n    value: function _uploadData(files, dataBlocks) {\r\n      var _this15 = this;\r\n\r\n      var xhr = new XMLHttpRequest();\r\n\r\n      // Put the xhr object in the file objects to be able to reference it later.\r\n      for (var _iterator22 = files, _isArray22 = true, _i24 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator]();;) {\r\n        var _ref21;\r\n\r\n        if (_isArray22) {\r\n          if (_i24 >= _iterator22.length) break;\r\n          _ref21 = _iterator22[_i24++];\r\n        } else {\r\n          _i24 = _iterator22.next();\r\n          if (_i24.done) break;\r\n          _ref21 = _i24.value;\r\n        }\r\n\r\n        var file = _ref21;\r\n\r\n        file.xhr = xhr;\r\n      }\r\n      if (files[0].upload.chunked) {\r\n        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk\r\n        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;\r\n      }\r\n\r\n      var method = this.resolveOption(this.options.method, files);\r\n      var url = this.resolveOption(this.options.url, files);\r\n      xhr.open(method, url, true);\r\n\r\n      // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8\r\n      xhr.timeout = this.resolveOption(this.options.timeout, files);\r\n\r\n      // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179\r\n      xhr.withCredentials = !!this.options.withCredentials;\r\n\r\n      xhr.onload = function (e) {\r\n        _this15._finishedUploading(files, xhr, e);\r\n      };\r\n\r\n      xhr.onerror = function () {\r\n        _this15._handleUploadError(files, xhr);\r\n      };\r\n\r\n      // Some browsers do not have the .upload property\r\n      var progressObj = xhr.upload != null ? xhr.upload : xhr;\r\n      progressObj.onprogress = function (e) {\r\n        return _this15._updateFilesUploadProgress(files, xhr, e);\r\n      };\r\n\r\n      var headers = {\r\n        \"Accept\": \"application/json\",\r\n        \"Cache-Control\": \"no-cache\",\r\n        \"X-Requested-With\": \"XMLHttpRequest\"\r\n      };\r\n\r\n      if (this.options.headers) {\r\n        Dropzone.extend(headers, this.options.headers);\r\n      }\r\n\r\n      for (var headerName in headers) {\r\n        var headerValue = headers[headerName];\r\n        if (headerValue) {\r\n          xhr.setRequestHeader(headerName, headerValue);\r\n        }\r\n      }\r\n\r\n      var formData = new FormData();\r\n\r\n      // Adding all @options parameters\r\n      if (this.options.params) {\r\n        var additionalParams = this.options.params;\r\n        if (typeof additionalParams === 'function') {\r\n          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);\r\n        }\r\n\r\n        for (var key in additionalParams) {\r\n          var value = additionalParams[key];\r\n          formData.append(key, value);\r\n        }\r\n      }\r\n\r\n      // Let the user add additional data if necessary\r\n      for (var _iterator23 = files, _isArray23 = true, _i25 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator]();;) {\r\n        var _ref22;\r\n\r\n        if (_isArray23) {\r\n          if (_i25 >= _iterator23.length) break;\r\n          _ref22 = _iterator23[_i25++];\r\n        } else {\r\n          _i25 = _iterator23.next();\r\n          if (_i25.done) break;\r\n          _ref22 = _i25.value;\r\n        }\r\n\r\n        var _file = _ref22;\r\n\r\n        this.emit(\"sending\", _file, xhr, formData);\r\n      }\r\n      if (this.options.uploadMultiple) {\r\n        this.emit(\"sendingmultiple\", files, xhr, formData);\r\n      }\r\n\r\n      this._addFormElementData(formData);\r\n\r\n      // Finally add the files\r\n      // Has to be last because some servers (eg: S3) expect the file to be the last parameter\r\n      for (var i = 0; i < dataBlocks.length; i++) {\r\n        var dataBlock = dataBlocks[i];\r\n        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);\r\n      }\r\n\r\n      this.submitRequest(xhr, formData, files);\r\n    }\r\n\r\n    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.\r\n\r\n  }, {\r\n    key: \"_transformFiles\",\r\n    value: function _transformFiles(files, done) {\r\n      var _this16 = this;\r\n\r\n      var transformedFiles = [];\r\n      // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.\r\n      var doneCounter = 0;\r\n\r\n      var _loop = function _loop(i) {\r\n        _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {\r\n          transformedFiles[i] = transformedFile;\r\n          if (++doneCounter === files.length) {\r\n            done(transformedFiles);\r\n          }\r\n        });\r\n      };\r\n\r\n      for (var i = 0; i < files.length; i++) {\r\n        _loop(i);\r\n      }\r\n    }\r\n\r\n    // Takes care of adding other input elements of the form to the AJAX request\r\n\r\n  }, {\r\n    key: \"_addFormElementData\",\r\n    value: function _addFormElementData(formData) {\r\n      // Take care of other input elements\r\n      if (this.element.tagName === \"FORM\") {\r\n        for (var _iterator24 = this.element.querySelectorAll(\"input, textarea, select, button\"), _isArray24 = true, _i26 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator]();;) {\r\n          var _ref23;\r\n\r\n          if (_isArray24) {\r\n            if (_i26 >= _iterator24.length) break;\r\n            _ref23 = _iterator24[_i26++];\r\n          } else {\r\n            _i26 = _iterator24.next();\r\n            if (_i26.done) break;\r\n            _ref23 = _i26.value;\r\n          }\r\n\r\n          var input = _ref23;\r\n\r\n          var inputName = input.getAttribute(\"name\");\r\n          var inputType = input.getAttribute(\"type\");\r\n          if (inputType) inputType = inputType.toLowerCase();\r\n\r\n          // If the input doesn't have a name, we can't use it.\r\n          if (typeof inputName === 'undefined' || inputName === null) continue;\r\n\r\n          if (input.tagName === \"SELECT\" && input.hasAttribute(\"multiple\")) {\r\n            // Possibly multiple values\r\n            for (var _iterator25 = input.options, _isArray25 = true, _i27 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator]();;) {\r\n              var _ref24;\r\n\r\n              if (_isArray25) {\r\n                if (_i27 >= _iterator25.length) break;\r\n                _ref24 = _iterator25[_i27++];\r\n              } else {\r\n                _i27 = _iterator25.next();\r\n                if (_i27.done) break;\r\n                _ref24 = _i27.value;\r\n              }\r\n\r\n              var option = _ref24;\r\n\r\n              if (option.selected) {\r\n                formData.append(inputName, option.value);\r\n              }\r\n            }\r\n          } else if (!inputType || inputType !== \"checkbox\" && inputType !== \"radio\" || input.checked) {\r\n            formData.append(inputName, input.value);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Invoked when there is new progress information about given files.\r\n    // If e is not provided, it is assumed that the upload is finished.\r\n\r\n  }, {\r\n    key: \"_updateFilesUploadProgress\",\r\n    value: function _updateFilesUploadProgress(files, xhr, e) {\r\n      var progress = void 0;\r\n      if (typeof e !== 'undefined') {\r\n        progress = 100 * e.loaded / e.total;\r\n\r\n        if (files[0].upload.chunked) {\r\n          var file = files[0];\r\n          // Since this is a chunked upload, we need to update the appropriate chunk progress.\r\n          var chunk = this._getChunk(file, xhr);\r\n          chunk.progress = progress;\r\n          chunk.total = e.total;\r\n          chunk.bytesSent = e.loaded;\r\n          var fileProgress = 0,\r\n              fileTotal = void 0,\r\n              fileBytesSent = void 0;\r\n          file.upload.progress = 0;\r\n          file.upload.total = 0;\r\n          file.upload.bytesSent = 0;\r\n          for (var i = 0; i < file.upload.totalChunkCount; i++) {\r\n            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {\r\n              file.upload.progress += file.upload.chunks[i].progress;\r\n              file.upload.total += file.upload.chunks[i].total;\r\n              file.upload.bytesSent += file.upload.chunks[i].bytesSent;\r\n            }\r\n          }\r\n          file.upload.progress = file.upload.progress / file.upload.totalChunkCount;\r\n        } else {\r\n          for (var _iterator26 = files, _isArray26 = true, _i28 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator]();;) {\r\n            var _ref25;\r\n\r\n            if (_isArray26) {\r\n              if (_i28 >= _iterator26.length) break;\r\n              _ref25 = _iterator26[_i28++];\r\n            } else {\r\n              _i28 = _iterator26.next();\r\n              if (_i28.done) break;\r\n              _ref25 = _i28.value;\r\n            }\r\n\r\n            var _file2 = _ref25;\r\n\r\n            _file2.upload.progress = progress;\r\n            _file2.upload.total = e.total;\r\n            _file2.upload.bytesSent = e.loaded;\r\n          }\r\n        }\r\n        for (var _iterator27 = files, _isArray27 = true, _i29 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator]();;) {\r\n          var _ref26;\r\n\r\n          if (_isArray27) {\r\n            if (_i29 >= _iterator27.length) break;\r\n            _ref26 = _iterator27[_i29++];\r\n          } else {\r\n            _i29 = _iterator27.next();\r\n            if (_i29.done) break;\r\n            _ref26 = _i29.value;\r\n          }\r\n\r\n          var _file3 = _ref26;\r\n\r\n          this.emit(\"uploadprogress\", _file3, _file3.upload.progress, _file3.upload.bytesSent);\r\n        }\r\n      } else {\r\n        // Called when the file finished uploading\r\n\r\n        var allFilesFinished = true;\r\n\r\n        progress = 100;\r\n\r\n        for (var _iterator28 = files, _isArray28 = true, _i30 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator]();;) {\r\n          var _ref27;\r\n\r\n          if (_isArray28) {\r\n            if (_i30 >= _iterator28.length) break;\r\n            _ref27 = _iterator28[_i30++];\r\n          } else {\r\n            _i30 = _iterator28.next();\r\n            if (_i30.done) break;\r\n            _ref27 = _i30.value;\r\n          }\r\n\r\n          var _file4 = _ref27;\r\n\r\n          if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {\r\n            allFilesFinished = false;\r\n          }\r\n          _file4.upload.progress = progress;\r\n          _file4.upload.bytesSent = _file4.upload.total;\r\n        }\r\n\r\n        // Nothing to do, all files already at 100%\r\n        if (allFilesFinished) {\r\n          return;\r\n        }\r\n\r\n        for (var _iterator29 = files, _isArray29 = true, _i31 = 0, _iterator29 = _isArray29 ? _iterator29 : _iterator29[Symbol.iterator]();;) {\r\n          var _ref28;\r\n\r\n          if (_isArray29) {\r\n            if (_i31 >= _iterator29.length) break;\r\n            _ref28 = _iterator29[_i31++];\r\n          } else {\r\n            _i31 = _iterator29.next();\r\n            if (_i31.done) break;\r\n            _ref28 = _i31.value;\r\n          }\r\n\r\n          var _file5 = _ref28;\r\n\r\n          this.emit(\"uploadprogress\", _file5, progress, _file5.upload.bytesSent);\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_finishedUploading\",\r\n    value: function _finishedUploading(files, xhr, e) {\r\n      var response = void 0;\r\n\r\n      if (files[0].status === Dropzone.CANCELED) {\r\n        return;\r\n      }\r\n\r\n      if (xhr.readyState !== 4) {\r\n        return;\r\n      }\r\n\r\n      if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {\r\n        response = xhr.responseText;\r\n\r\n        if (xhr.getResponseHeader(\"content-type\") && ~xhr.getResponseHeader(\"content-type\").indexOf(\"application/json\")) {\r\n          try {\r\n            response = JSON.parse(response);\r\n          } catch (error) {\r\n            e = error;\r\n            response = \"Invalid JSON response from server.\";\r\n          }\r\n        }\r\n      }\r\n\r\n      this._updateFilesUploadProgress(files);\r\n\r\n      if (!(200 <= xhr.status && xhr.status < 300)) {\r\n        this._handleUploadError(files, xhr, response);\r\n      } else {\r\n        if (files[0].upload.chunked) {\r\n          files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));\r\n        } else {\r\n          this._finished(files, response, e);\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_handleUploadError\",\r\n    value: function _handleUploadError(files, xhr, response) {\r\n      if (files[0].status === Dropzone.CANCELED) {\r\n        return;\r\n      }\r\n\r\n      if (files[0].upload.chunked && this.options.retryChunks) {\r\n        var chunk = this._getChunk(files[0], xhr);\r\n        if (chunk.retries++ < this.options.retryChunksLimit) {\r\n          this._uploadData(files, [chunk.dataBlock]);\r\n          return;\r\n        } else {\r\n          console.warn('Retried this chunk too often. Giving up.');\r\n        }\r\n      }\r\n\r\n      for (var _iterator30 = files, _isArray30 = true, _i32 = 0, _iterator30 = _isArray30 ? _iterator30 : _iterator30[Symbol.iterator]();;) {\r\n        var _ref29;\r\n\r\n        if (_isArray30) {\r\n          if (_i32 >= _iterator30.length) break;\r\n          _ref29 = _iterator30[_i32++];\r\n        } else {\r\n          _i32 = _iterator30.next();\r\n          if (_i32.done) break;\r\n          _ref29 = _i32.value;\r\n        }\r\n\r\n        var file = _ref29;\r\n\r\n        this._errorProcessing(files, response || this.options.dictResponseError.replace(\"{{statusCode}}\", xhr.status), xhr);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"submitRequest\",\r\n    value: function submitRequest(xhr, formData, files) {\r\n      xhr.send(formData);\r\n    }\r\n\r\n    // Called internally when processing is finished.\r\n    // Individual callbacks have to be called in the appropriate sections.\r\n\r\n  }, {\r\n    key: \"_finished\",\r\n    value: function _finished(files, responseText, e) {\r\n      for (var _iterator31 = files, _isArray31 = true, _i33 = 0, _iterator31 = _isArray31 ? _iterator31 : _iterator31[Symbol.iterator]();;) {\r\n        var _ref30;\r\n\r\n        if (_isArray31) {\r\n          if (_i33 >= _iterator31.length) break;\r\n          _ref30 = _iterator31[_i33++];\r\n        } else {\r\n          _i33 = _iterator31.next();\r\n          if (_i33.done) break;\r\n          _ref30 = _i33.value;\r\n        }\r\n\r\n        var file = _ref30;\r\n\r\n        file.status = Dropzone.SUCCESS;\r\n        this.emit(\"success\", file, responseText, e);\r\n        this.emit(\"complete\", file);\r\n      }\r\n      if (this.options.uploadMultiple) {\r\n        this.emit(\"successmultiple\", files, responseText, e);\r\n        this.emit(\"completemultiple\", files);\r\n      }\r\n\r\n      if (this.options.autoProcessQueue) {\r\n        return this.processQueue();\r\n      }\r\n    }\r\n\r\n    // Called internally when processing is finished.\r\n    // Individual callbacks have to be called in the appropriate sections.\r\n\r\n  }, {\r\n    key: \"_errorProcessing\",\r\n    value: function _errorProcessing(files, message, xhr) {\r\n      for (var _iterator32 = files, _isArray32 = true, _i34 = 0, _iterator32 = _isArray32 ? _iterator32 : _iterator32[Symbol.iterator]();;) {\r\n        var _ref31;\r\n\r\n        if (_isArray32) {\r\n          if (_i34 >= _iterator32.length) break;\r\n          _ref31 = _iterator32[_i34++];\r\n        } else {\r\n          _i34 = _iterator32.next();\r\n          if (_i34.done) break;\r\n          _ref31 = _i34.value;\r\n        }\r\n\r\n        var file = _ref31;\r\n\r\n        file.status = Dropzone.ERROR;\r\n        this.emit(\"error\", file, message, xhr);\r\n        this.emit(\"complete\", file);\r\n      }\r\n      if (this.options.uploadMultiple) {\r\n        this.emit(\"errormultiple\", files, message, xhr);\r\n        this.emit(\"completemultiple\", files);\r\n      }\r\n\r\n      if (this.options.autoProcessQueue) {\r\n        return this.processQueue();\r\n      }\r\n    }\r\n  }], [{\r\n    key: \"uuidv4\",\r\n    value: function uuidv4() {\r\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        var r = Math.random() * 16 | 0,\r\n            v = c === 'x' ? r : r & 0x3 | 0x8;\r\n        return v.toString(16);\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return Dropzone;\r\n}(Emitter);\r\n\r\nDropzone.initClass();\r\n\r\nDropzone.version = \"5.4.0\";\r\n\r\n// This is a map of options for your different dropzones. Add configurations\r\n// to this object for your different dropzone elemens.\r\n//\r\n// Example:\r\n//\r\n//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };\r\n//\r\n// To disable autoDiscover for a specific element, you can set `false` as an option:\r\n//\r\n//     Dropzone.options.myDisabledElementId = false;\r\n//\r\n// And in html:\r\n//\r\n//     <form action=\"/upload\" id=\"my-dropzone-element-id\" class=\"dropzone\"></form>\r\nDropzone.options = {};\r\n\r\n// Returns the options for an element or undefined if none available.\r\nDropzone.optionsForElement = function (element) {\r\n  // Get the `Dropzone.options.elementId` for this element if it exists\r\n  if (element.getAttribute(\"id\")) {\r\n    return Dropzone.options[camelize(element.getAttribute(\"id\"))];\r\n  } else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// Holds a list of all dropzone instances\r\nDropzone.instances = [];\r\n\r\n// Returns the dropzone for given element if any\r\nDropzone.forElement = function (element) {\r\n  if (typeof element === \"string\") {\r\n    element = document.querySelector(element);\r\n  }\r\n  if ((element != null ? element.dropzone : undefined) == null) {\r\n    throw new Error(\"No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.\");\r\n  }\r\n  return element.dropzone;\r\n};\r\n\r\n// Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.\r\nDropzone.autoDiscover = true;\r\n\r\n// Looks for all .dropzone elements and creates a dropzone for them\r\nDropzone.discover = function () {\r\n  var dropzones = void 0;\r\n  if (document.querySelectorAll) {\r\n    dropzones = document.querySelectorAll(\".dropzone\");\r\n  } else {\r\n    dropzones = [];\r\n    // IE :(\r\n    var checkElements = function checkElements(elements) {\r\n      return function () {\r\n        var result = [];\r\n        for (var _iterator33 = elements, _isArray33 = true, _i35 = 0, _iterator33 = _isArray33 ? _iterator33 : _iterator33[Symbol.iterator]();;) {\r\n          var _ref32;\r\n\r\n          if (_isArray33) {\r\n            if (_i35 >= _iterator33.length) break;\r\n            _ref32 = _iterator33[_i35++];\r\n          } else {\r\n            _i35 = _iterator33.next();\r\n            if (_i35.done) break;\r\n            _ref32 = _i35.value;\r\n          }\r\n\r\n          var el = _ref32;\r\n\r\n          if (/(^| )dropzone($| )/.test(el.className)) {\r\n            result.push(dropzones.push(el));\r\n          } else {\r\n            result.push(undefined);\r\n          }\r\n        }\r\n        return result;\r\n      }();\r\n    };\r\n    checkElements(document.getElementsByTagName(\"div\"));\r\n    checkElements(document.getElementsByTagName(\"form\"));\r\n  }\r\n\r\n  return function () {\r\n    var result = [];\r\n    for (var _iterator34 = dropzones, _isArray34 = true, _i36 = 0, _iterator34 = _isArray34 ? _iterator34 : _iterator34[Symbol.iterator]();;) {\r\n      var _ref33;\r\n\r\n      if (_isArray34) {\r\n        if (_i36 >= _iterator34.length) break;\r\n        _ref33 = _iterator34[_i36++];\r\n      } else {\r\n        _i36 = _iterator34.next();\r\n        if (_i36.done) break;\r\n        _ref33 = _i36.value;\r\n      }\r\n\r\n      var dropzone = _ref33;\r\n\r\n      // Create a dropzone unless auto discover has been disabled for specific element\r\n      if (Dropzone.optionsForElement(dropzone) !== false) {\r\n        result.push(new Dropzone(dropzone));\r\n      } else {\r\n        result.push(undefined);\r\n      }\r\n    }\r\n    return result;\r\n  }();\r\n};\r\n\r\n// Since the whole Drag'n'Drop API is pretty new, some browsers implement it,\r\n// but not correctly.\r\n// So I created a blacklist of userAgents. Yes, yes. Browser sniffing, I know.\r\n// But what to do when browsers *theoretically* support an API, but crash\r\n// when using it.\r\n//\r\n// This is a list of regular expressions tested against navigator.userAgent\r\n//\r\n// ** It should only be used on browser that *do* support the API, but\r\n// incorrectly **\r\n//\r\nDropzone.blacklistedBrowsers = [\r\n// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.\r\n/opera.*(Macintosh|Windows Phone).*version\\/12/i];\r\n\r\n// Checks if the browser is supported\r\nDropzone.isBrowserSupported = function () {\r\n  var capableBrowser = true;\r\n\r\n  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\r\n    if (!(\"classList\" in document.createElement(\"a\"))) {\r\n      capableBrowser = false;\r\n    } else {\r\n      // The browser supports the API, but may be blacklisted.\r\n      for (var _iterator35 = Dropzone.blacklistedBrowsers, _isArray35 = true, _i37 = 0, _iterator35 = _isArray35 ? _iterator35 : _iterator35[Symbol.iterator]();;) {\r\n        var _ref34;\r\n\r\n        if (_isArray35) {\r\n          if (_i37 >= _iterator35.length) break;\r\n          _ref34 = _iterator35[_i37++];\r\n        } else {\r\n          _i37 = _iterator35.next();\r\n          if (_i37.done) break;\r\n          _ref34 = _i37.value;\r\n        }\r\n\r\n        var regex = _ref34;\r\n\r\n        if (regex.test(navigator.userAgent)) {\r\n          capableBrowser = false;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    capableBrowser = false;\r\n  }\r\n\r\n  return capableBrowser;\r\n};\r\n\r\nDropzone.dataURItoBlob = function (dataURI) {\r\n  // convert base64 to raw binary data held in a string\r\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\r\n  var byteString = atob(dataURI.split(',')[1]);\r\n\r\n  // separate out the mime component\r\n  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];\r\n\r\n  // write the bytes of the string to an ArrayBuffer\r\n  var ab = new ArrayBuffer(byteString.length);\r\n  var ia = new Uint8Array(ab);\r\n  for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\r\n    ia[i] = byteString.charCodeAt(i);\r\n  }\r\n\r\n  // write the ArrayBuffer to a blob\r\n  return new Blob([ab], { type: mimeString });\r\n};\r\n\r\n// Returns an array without the rejected item\r\nvar without = function without(list, rejectedItem) {\r\n  return list.filter(function (item) {\r\n    return item !== rejectedItem;\r\n  }).map(function (item) {\r\n    return item;\r\n  });\r\n};\r\n\r\n// abc-def_ghi -> abcDefGhi\r\nvar camelize = function camelize(str) {\r\n  return str.replace(/[\\-_](\\w)/g, function (match) {\r\n    return match.charAt(1).toUpperCase();\r\n  });\r\n};\r\n\r\n// Creates an element from string\r\nDropzone.createElement = function (string) {\r\n  var div = document.createElement(\"div\");\r\n  div.innerHTML = string;\r\n  return div.childNodes[0];\r\n};\r\n\r\n// Tests if given element is inside (or simply is) the container\r\nDropzone.elementInside = function (element, container) {\r\n  if (element === container) {\r\n    return true;\r\n  } // Coffeescript doesn't support do/while loops\r\n  while (element = element.parentNode) {\r\n    if (element === container) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nDropzone.getElement = function (el, name) {\r\n  var element = void 0;\r\n  if (typeof el === \"string\") {\r\n    element = document.querySelector(el);\r\n  } else if (el.nodeType != null) {\r\n    element = el;\r\n  }\r\n  if (element == null) {\r\n    throw new Error(\"Invalid `\" + name + \"` option provided. Please provide a CSS selector or a plain HTML element.\");\r\n  }\r\n  return element;\r\n};\r\n\r\nDropzone.getElements = function (els, name) {\r\n  var el = void 0,\r\n      elements = void 0;\r\n  if (els instanceof Array) {\r\n    elements = [];\r\n    try {\r\n      for (var _iterator36 = els, _isArray36 = true, _i38 = 0, _iterator36 = _isArray36 ? _iterator36 : _iterator36[Symbol.iterator]();;) {\r\n        if (_isArray36) {\r\n          if (_i38 >= _iterator36.length) break;\r\n          el = _iterator36[_i38++];\r\n        } else {\r\n          _i38 = _iterator36.next();\r\n          if (_i38.done) break;\r\n          el = _i38.value;\r\n        }\r\n\r\n        elements.push(this.getElement(el, name));\r\n      }\r\n    } catch (e) {\r\n      elements = null;\r\n    }\r\n  } else if (typeof els === \"string\") {\r\n    elements = [];\r\n    for (var _iterator37 = document.querySelectorAll(els), _isArray37 = true, _i39 = 0, _iterator37 = _isArray37 ? _iterator37 : _iterator37[Symbol.iterator]();;) {\r\n      if (_isArray37) {\r\n        if (_i39 >= _iterator37.length) break;\r\n        el = _iterator37[_i39++];\r\n      } else {\r\n        _i39 = _iterator37.next();\r\n        if (_i39.done) break;\r\n        el = _i39.value;\r\n      }\r\n\r\n      elements.push(el);\r\n    }\r\n  } else if (els.nodeType != null) {\r\n    elements = [els];\r\n  }\r\n\r\n  if (elements == null || !elements.length) {\r\n    throw new Error(\"Invalid `\" + name + \"` option provided. Please provide a CSS selector, a plain HTML element or a list of those.\");\r\n  }\r\n\r\n  return elements;\r\n};\r\n\r\n// Asks the user the question and calls accepted or rejected accordingly\r\n//\r\n// The default implementation just uses `window.confirm` and then calls the\r\n// appropriate callback.\r\nDropzone.confirm = function (question, accepted, rejected) {\r\n  if (window.confirm(question)) {\r\n    return accepted();\r\n  } else if (rejected != null) {\r\n    return rejected();\r\n  }\r\n};\r\n\r\n// Validates the mime type like this:\r\n//\r\n// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept\r\nDropzone.isValidFile = function (file, acceptedFiles) {\r\n  if (!acceptedFiles) {\r\n    return true;\r\n  } // If there are no accepted mime types, it's OK\r\n  acceptedFiles = acceptedFiles.split(\",\");\r\n\r\n  var mimeType = file.type;\r\n  var baseMimeType = mimeType.replace(/\\/.*$/, \"\");\r\n\r\n  for (var _iterator38 = acceptedFiles, _isArray38 = true, _i40 = 0, _iterator38 = _isArray38 ? _iterator38 : _iterator38[Symbol.iterator]();;) {\r\n    var _ref35;\r\n\r\n    if (_isArray38) {\r\n      if (_i40 >= _iterator38.length) break;\r\n      _ref35 = _iterator38[_i40++];\r\n    } else {\r\n      _i40 = _iterator38.next();\r\n      if (_i40.done) break;\r\n      _ref35 = _i40.value;\r\n    }\r\n\r\n    var validType = _ref35;\r\n\r\n    validType = validType.trim();\r\n    if (validType.charAt(0) === \".\") {\r\n      if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\r\n        return true;\r\n      }\r\n    } else if (/\\/\\*$/.test(validType)) {\r\n      // This is something like a image/* mime type\r\n      if (baseMimeType === validType.replace(/\\/.*$/, \"\")) {\r\n        return true;\r\n      }\r\n    } else {\r\n      if (mimeType === validType) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// Augment jQuery\r\nif (typeof jQuery !== 'undefined' && jQuery !== null) {\r\n  jQuery.fn.dropzone = function (options) {\r\n    return this.each(function () {\r\n      return new Dropzone(this, options);\r\n    });\r\n  };\r\n}\r\n\r\nif ( true && module !== null) {\r\n  module.exports = Dropzone;\r\n} else {\r\n  window.Dropzone = Dropzone;\r\n}\r\n\r\n// Dropzone file status codes\r\nDropzone.ADDED = \"added\";\r\n\r\nDropzone.QUEUED = \"queued\";\r\n// For backwards compatibility. Now, if a file is accepted, it's either queued\r\n// or uploading.\r\nDropzone.ACCEPTED = Dropzone.QUEUED;\r\n\r\nDropzone.UPLOADING = \"uploading\";\r\nDropzone.PROCESSING = Dropzone.UPLOADING; // alias\r\n\r\nDropzone.CANCELED = \"canceled\";\r\nDropzone.ERROR = \"error\";\r\nDropzone.SUCCESS = \"success\";\r\n\r\n/*\r\n\r\n Bugfix for iOS 6 and 7\r\n Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\r\n based on the work of https://github.com/stomita/ios-imagefile-megapixel\r\n\r\n */\r\n\r\n// Detecting vertical squash in loaded image.\r\n// Fixes a bug which squash image vertically while drawing into canvas for some images.\r\n// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel\r\nvar detectVerticalSquash = function detectVerticalSquash(img) {\r\n  var iw = img.naturalWidth;\r\n  var ih = img.naturalHeight;\r\n  var canvas = document.createElement(\"canvas\");\r\n  canvas.width = 1;\r\n  canvas.height = ih;\r\n  var ctx = canvas.getContext(\"2d\");\r\n  ctx.drawImage(img, 0, 0);\r\n\r\n  var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),\r\n      data = _ctx$getImageData.data;\r\n\r\n  // search image edge pixel position in case it is squashed vertically.\r\n\r\n\r\n  var sy = 0;\r\n  var ey = ih;\r\n  var py = ih;\r\n  while (py > sy) {\r\n    var alpha = data[(py - 1) * 4 + 3];\r\n\r\n    if (alpha === 0) {\r\n      ey = py;\r\n    } else {\r\n      sy = py;\r\n    }\r\n\r\n    py = ey + sy >> 1;\r\n  }\r\n  var ratio = py / ih;\r\n\r\n  if (ratio === 0) {\r\n    return 1;\r\n  } else {\r\n    return ratio;\r\n  }\r\n};\r\n\r\n// A replacement for context.drawImage\r\n// (args are for source and destination).\r\nvar drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n  var vertSquashRatio = detectVerticalSquash(img);\r\n  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\r\n};\r\n\r\n// Based on MinifyJpeg\r\n// Source: http://www.perry.cz/files/ExifRestorer.js\r\n// http://elicon.blog57.fc2.com/blog-entry-206.html\r\n\r\nvar ExifRestore = function () {\r\n  function ExifRestore() {\r\n    _classCallCheck(this, ExifRestore);\r\n  }\r\n\r\n  _createClass(ExifRestore, null, [{\r\n    key: \"initClass\",\r\n    value: function initClass() {\r\n      this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n    }\r\n  }, {\r\n    key: \"encode64\",\r\n    value: function encode64(input) {\r\n      var output = '';\r\n      var chr1 = undefined;\r\n      var chr2 = undefined;\r\n      var chr3 = '';\r\n      var enc1 = undefined;\r\n      var enc2 = undefined;\r\n      var enc3 = undefined;\r\n      var enc4 = '';\r\n      var i = 0;\r\n      while (true) {\r\n        chr1 = input[i++];\r\n        chr2 = input[i++];\r\n        chr3 = input[i++];\r\n        enc1 = chr1 >> 2;\r\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\r\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\r\n        enc4 = chr3 & 63;\r\n        if (isNaN(chr2)) {\r\n          enc3 = enc4 = 64;\r\n        } else if (isNaN(chr3)) {\r\n          enc4 = 64;\r\n        }\r\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\r\n        chr1 = chr2 = chr3 = '';\r\n        enc1 = enc2 = enc3 = enc4 = '';\r\n        if (!(i < input.length)) {\r\n          break;\r\n        }\r\n      }\r\n      return output;\r\n    }\r\n  }, {\r\n    key: \"restore\",\r\n    value: function restore(origFileBase64, resizedFileBase64) {\r\n      if (!origFileBase64.match('data:image/jpeg;base64,')) {\r\n        return resizedFileBase64;\r\n      }\r\n      var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));\r\n      var segments = this.slice2Segments(rawImage);\r\n      var image = this.exifManipulation(resizedFileBase64, segments);\r\n      return \"data:image/jpeg;base64,\" + this.encode64(image);\r\n    }\r\n  }, {\r\n    key: \"exifManipulation\",\r\n    value: function exifManipulation(resizedFileBase64, segments) {\r\n      var exifArray = this.getExifArray(segments);\r\n      var newImageArray = this.insertExif(resizedFileBase64, exifArray);\r\n      var aBuffer = new Uint8Array(newImageArray);\r\n      return aBuffer;\r\n    }\r\n  }, {\r\n    key: \"getExifArray\",\r\n    value: function getExifArray(segments) {\r\n      var seg = undefined;\r\n      var x = 0;\r\n      while (x < segments.length) {\r\n        seg = segments[x];\r\n        if (seg[0] === 255 & seg[1] === 225) {\r\n          return seg;\r\n        }\r\n        x++;\r\n      }\r\n      return [];\r\n    }\r\n  }, {\r\n    key: \"insertExif\",\r\n    value: function insertExif(resizedFileBase64, exifArray) {\r\n      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');\r\n      var buf = this.decode64(imageData);\r\n      var separatePoint = buf.indexOf(255, 3);\r\n      var mae = buf.slice(0, separatePoint);\r\n      var ato = buf.slice(separatePoint);\r\n      var array = mae;\r\n      array = array.concat(exifArray);\r\n      array = array.concat(ato);\r\n      return array;\r\n    }\r\n  }, {\r\n    key: \"slice2Segments\",\r\n    value: function slice2Segments(rawImageArray) {\r\n      var head = 0;\r\n      var segments = [];\r\n      while (true) {\r\n        var length;\r\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\r\n          break;\r\n        }\r\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\r\n          head += 2;\r\n        } else {\r\n          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\r\n          var endPoint = head + length + 2;\r\n          var seg = rawImageArray.slice(head, endPoint);\r\n          segments.push(seg);\r\n          head = endPoint;\r\n        }\r\n        if (head > rawImageArray.length) {\r\n          break;\r\n        }\r\n      }\r\n      return segments;\r\n    }\r\n  }, {\r\n    key: \"decode64\",\r\n    value: function decode64(input) {\r\n      var output = '';\r\n      var chr1 = undefined;\r\n      var chr2 = undefined;\r\n      var chr3 = '';\r\n      var enc1 = undefined;\r\n      var enc2 = undefined;\r\n      var enc3 = undefined;\r\n      var enc4 = '';\r\n      var i = 0;\r\n      var buf = [];\r\n      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\r\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\r\n      if (base64test.exec(input)) {\r\n        console.warn('There were invalid base64 characters in the input text.\\nValid base64 characters are A-Z, a-z, 0-9, \\'+\\', \\'/\\',and \\'=\\'\\nExpect errors in decoding.');\r\n      }\r\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\r\n      while (true) {\r\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\r\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\r\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\r\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\r\n        chr1 = enc1 << 2 | enc2 >> 4;\r\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\r\n        chr3 = (enc3 & 3) << 6 | enc4;\r\n        buf.push(chr1);\r\n        if (enc3 !== 64) {\r\n          buf.push(chr2);\r\n        }\r\n        if (enc4 !== 64) {\r\n          buf.push(chr3);\r\n        }\r\n        chr1 = chr2 = chr3 = '';\r\n        enc1 = enc2 = enc3 = enc4 = '';\r\n        if (!(i < input.length)) {\r\n          break;\r\n        }\r\n      }\r\n      return buf;\r\n    }\r\n  }]);\r\n\r\n  return ExifRestore;\r\n}();\r\n\r\nExifRestore.initClass();\r\n\r\n/*\r\n * contentloaded.js\r\n *\r\n * Author: Diego Perini (diego.perini at gmail.com)\r\n * Summary: cross-browser wrapper for DOMContentLoaded\r\n * Updated: 20101020\r\n * License: MIT\r\n * Version: 1.2\r\n *\r\n * URL:\r\n * http://javascript.nwbox.com/ContentLoaded/\r\n * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\r\n */\r\n\r\n// @win window reference\r\n// @fn function reference\r\nvar contentLoaded = function contentLoaded(win, fn) {\r\n  var done = false;\r\n  var top = true;\r\n  var doc = win.document;\r\n  var root = doc.documentElement;\r\n  var add = doc.addEventListener ? \"addEventListener\" : \"attachEvent\";\r\n  var rem = doc.addEventListener ? \"removeEventListener\" : \"detachEvent\";\r\n  var pre = doc.addEventListener ? \"\" : \"on\";\r\n  var init = function init(e) {\r\n    if (e.type === \"readystatechange\" && doc.readyState !== \"complete\") {\r\n      return;\r\n    }\r\n    (e.type === \"load\" ? win : doc)[rem](pre + e.type, init, false);\r\n    if (!done && (done = true)) {\r\n      return fn.call(win, e.type || e);\r\n    }\r\n  };\r\n\r\n  var poll = function poll() {\r\n    try {\r\n      root.doScroll(\"left\");\r\n    } catch (e) {\r\n      setTimeout(poll, 50);\r\n      return;\r\n    }\r\n    return init(\"poll\");\r\n  };\r\n\r\n  if (doc.readyState !== \"complete\") {\r\n    if (doc.createEventObject && root.doScroll) {\r\n      try {\r\n        top = !win.frameElement;\r\n      } catch (error) {}\r\n      if (top) {\r\n        poll();\r\n      }\r\n    }\r\n    doc[add](pre + \"DOMContentLoaded\", init, false);\r\n    doc[add](pre + \"readystatechange\", init, false);\r\n    return win[add](pre + \"load\", init, false);\r\n  }\r\n};\r\n\r\n// As a single function to be able to write tests.\r\nDropzone._autoDiscoverFunction = function () {\r\n  if (Dropzone.autoDiscover) {\r\n    return Dropzone.discover();\r\n  }\r\n};\r\ncontentLoaded(window, Dropzone._autoDiscoverFunction);\r\n\r\nfunction __guard__(value, transform) {\r\n  return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;\r\n}\r\nfunction __guardMethod__(obj, methodName, transform) {\r\n  if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {\r\n    return transform(obj, methodName);\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL0dhbGxlcmllcy9ub2RlX21vZHVsZXMvZHJvcHpvbmUvZGlzdC9kcm9wem9uZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCO0FBQ2pqQjtBQUNBLGtEQUFrRCxhQUFhLHlGQUF5RjtBQUN4SjtBQUNBLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHO0FBQ3RYO0FBQ0Esa0RBQWtELDBDQUEwQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQSxrSUFBa0k7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxTQUFTLGFBQWE7QUFDOUM7QUFDQSw0Q0FBNEMsVUFBVSxzQkFBc0IsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBZ0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsMExBQTBMO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMExBQTBMO0FBQzFMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0TEFBNEw7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0xBQStMO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTUFBa007QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCxzREFBc0Q7QUFDdEQsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0dBQWdHLGVBQWU7QUFDL0c7QUFDQTtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzRUFBc0U7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0o7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SkFBNEo7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0STtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVSwwREFBMEQsYUFBYTtBQUM1SSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsMERBQTBELFVBQVU7QUFDcEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUpBQW1KO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUpBQW1KO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TUFBdU07QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4SUFBOEk7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixZQUFZO0FBQ3ZHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkJBQTJCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SUFBOEk7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxlZXRjYXJ0Ly4vTW9kdWxlcy9HYWxsZXJpZXMvbm9kZV9tb2R1bGVzL2Ryb3B6b25lL2Rpc3QvZHJvcHpvbmUuanM/YzgxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XHJcblxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cclxuXHJcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbi8qXHJcbiAqXHJcbiAqIE1vcmUgaW5mbyBhdCBbd3d3LmRyb3B6b25lanMuY29tXShodHRwOi8vd3d3LmRyb3B6b25lanMuY29tKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIsIE1hdGlhcyBNZW5vXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICpcclxuICovXHJcblxyXG4vLyBUaGUgRW1pdHRlciBjbGFzcyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byBjYWxsIGAub24oKWAgb24gRHJvcHpvbmUgdG8gbGlzdGVuXHJcbi8vIHRvIGV2ZW50cy5cclxuLy8gSXQgaXMgc3Ryb25nbHkgYmFzZWQgb24gY29tcG9uZW50J3MgZW1pdHRlciBjbGFzcywgYW5kIEkgcmVtb3ZlZCB0aGVcclxuLy8gZnVuY3Rpb25hbGl0eSBiZWNhdXNlIG9mIHRoZSBkZXBlbmRlbmN5IGhlbGwgd2l0aCBkaWZmZXJlbnQgZnJhbWV3b3Jrcy5cclxudmFyIEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gRW1pdHRlcigpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhFbWl0dGVyLCBbe1xyXG4gICAga2V5OiBcIm9uXCIsXHJcblxyXG4gICAgLy8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBnaXZlbiBldmVudFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbikge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgICAgIC8vIENyZWF0ZSBuYW1lc3BhY2UgZm9yIHRoaXMgZXZlbnRcclxuICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3NbZXZlbnRdKSB7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJlbWl0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCkge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xyXG5cclxuICAgICAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjYWxsYmFja3MsIF9pc0FycmF5ID0gdHJ1ZSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWY7XHJcblxyXG4gICAgICAgICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3JlZjtcclxuXHJcbiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBmb3IgZ2l2ZW4gZXZlbnQuIElmIGZuIGlzIG5vdCBwcm92aWRlZCwgYWxsIGV2ZW50XHJcbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoYXQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBJZiBuZWl0aGVyIGlzIHByb3ZpZGVkLCBhbGxcclxuICAgIC8vIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJvZmZcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGZuKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XHJcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSBmbikge1xyXG4gICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gRW1pdHRlcjtcclxufSgpO1xyXG5cclxudmFyIERyb3B6b25lID0gZnVuY3Rpb24gKF9FbWl0dGVyKSB7XHJcbiAgX2luaGVyaXRzKERyb3B6b25lLCBfRW1pdHRlcik7XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhEcm9wem9uZSwgbnVsbCwgW3tcclxuICAgIGtleTogXCJpbml0Q2xhc3NcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q2xhc3MoKSB7XHJcblxyXG4gICAgICAvLyBFeHBvc2luZyB0aGUgZW1pdHRlciBjbGFzcywgbWFpbmx5IGZvciB0ZXN0c1xyXG4gICAgICB0aGlzLnByb3RvdHlwZS5FbWl0dGVyID0gRW1pdHRlcjtcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50cyB5b3UgY2FuIHJlZ2lzdGVyIG9uIGEgZHJvcHpvbmUgb2JqZWN0LlxyXG4gICAgICAgIFlvdSBjYW4gcmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXM6XHJcbiAgICAgICAgZHJvcHpvbmUub24oXCJkcmFnRW50ZXJcIiwgZnVuY3Rpb24oKSB7IH0pO1xyXG4gICAgICAgICovXHJcbiAgICAgIHRoaXMucHJvdG90eXBlLmV2ZW50cyA9IFtcImRyb3BcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcmFnZW5kXCIsIFwiZHJhZ2VudGVyXCIsIFwiZHJhZ292ZXJcIiwgXCJkcmFnbGVhdmVcIiwgXCJhZGRlZGZpbGVcIiwgXCJhZGRlZGZpbGVzXCIsIFwicmVtb3ZlZGZpbGVcIiwgXCJ0aHVtYm5haWxcIiwgXCJlcnJvclwiLCBcImVycm9ybXVsdGlwbGVcIiwgXCJwcm9jZXNzaW5nXCIsIFwicHJvY2Vzc2luZ211bHRpcGxlXCIsIFwidXBsb2FkcHJvZ3Jlc3NcIiwgXCJ0b3RhbHVwbG9hZHByb2dyZXNzXCIsIFwic2VuZGluZ1wiLCBcInNlbmRpbmdtdWx0aXBsZVwiLCBcInN1Y2Nlc3NcIiwgXCJzdWNjZXNzbXVsdGlwbGVcIiwgXCJjYW5jZWxlZFwiLCBcImNhbmNlbGVkbXVsdGlwbGVcIiwgXCJjb21wbGV0ZVwiLCBcImNvbXBsZXRlbXVsdGlwbGVcIiwgXCJyZXNldFwiLCBcIm1heGZpbGVzZXhjZWVkZWRcIiwgXCJtYXhmaWxlc3JlYWNoZWRcIiwgXCJxdWV1ZWNvbXBsZXRlXCJdO1xyXG5cclxuICAgICAgdGhpcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFzIHRvIGJlIHNwZWNpZmllZCBvbiBlbGVtZW50cyBvdGhlciB0aGFuIGZvcm0gKG9yIHdoZW4gdGhlIGZvcm1cclxuICAgICAgICAgKiBkb2Vzbid0IGhhdmUgYW4gYGFjdGlvbmAgYXR0cmlidXRlKS4gWW91IGNhbiBhbHNvXHJcbiAgICAgICAgICogcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgZmlsZXNgIGFuZFxyXG4gICAgICAgICAqIG11c3QgcmV0dXJuIHRoZSB1cmwgKHNpbmNlIGB2My4xMi4wYClcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cmw6IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbiBiZSBjaGFuZ2VkIHRvIGBcInB1dFwiYCBpZiBuZWNlc3NhcnkuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgZnVuY3Rpb25cclxuICAgICAgICAgKiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYGZpbGVzYCBhbmQgbXVzdCByZXR1cm4gdGhlIG1ldGhvZCAoc2luY2UgYHYzLjEyLjBgKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaWxsIGJlIHNldCBvbiB0aGUgWEhSZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0aW1lb3V0IGZvciB0aGUgWEhSIHJlcXVlc3RzIGluIG1pbGxpc2Vjb25kcyAoc2luY2UgYHY0LjQuMGApLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRpbWVvdXQ6IDMwMDAwLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgbWFueSBmaWxlIHVwbG9hZHMgdG8gcHJvY2VzcyBpbiBwYXJhbGxlbCAoU2VlIHRoZVxyXG4gICAgICAgICAqIEVucXVldWluZyBmaWxlIHVwbG9hZHMqIGRvY3VtZW50YXRpb24gc2VjdGlvbiBmb3IgbW9yZSBpbmZvKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkczogMixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBzZW5kIG11bHRpcGxlIGZpbGVzIGluIG9uZSByZXF1ZXN0LiBJZlxyXG4gICAgICAgICAqIHRoaXMgaXQgc2V0IHRvIHRydWUsIHRoZW4gdGhlIGZhbGxiYWNrIGZpbGUgaW5wdXQgZWxlbWVudCB3aWxsXHJcbiAgICAgICAgICogaGF2ZSB0aGUgYG11bHRpcGxlYCBhdHRyaWJ1dGUgYXMgd2VsbC4gVGhpcyBvcHRpb24gd2lsbFxyXG4gICAgICAgICAqIGFsc28gdHJpZ2dlciBhZGRpdGlvbmFsIGV2ZW50cyAobGlrZSBgcHJvY2Vzc2luZ211bHRpcGxlYCkuIFNlZSB0aGUgZXZlbnRzXHJcbiAgICAgICAgICogZG9jdW1lbnRhdGlvbiBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwbG9hZE11bHRpcGxlOiBmYWxzZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB5b3Ugd2FudCBmaWxlcyB0byBiZSB1cGxvYWRlZCBpbiBjaHVua3MgdG8geW91ciBzZXJ2ZXIuIFRoaXMgY2FuJ3QgYmVcclxuICAgICAgICAgKiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYHVwbG9hZE11bHRpcGxlYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFNlZSBbY2h1bmtzVXBsb2FkZWRdKCNjb25maWctY2h1bmtzVXBsb2FkZWQpIGZvciB0aGUgY2FsbGJhY2sgdG8gZmluYWxpc2UgYW4gdXBsb2FkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNodW5raW5nOiBmYWxzZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYGNodW5raW5nYCBpcyBlbmFibGVkLCB0aGlzIGRlZmluZXMgd2hldGhlciAqKmV2ZXJ5KiogZmlsZSBzaG91bGQgYmUgY2h1bmtlZCxcclxuICAgICAgICAgKiBldmVuIGlmIHRoZSBmaWxlIHNpemUgaXMgYmVsb3cgY2h1bmtTaXplLiBUaGlzIG1lYW5zLCB0aGF0IHRoZSBhZGRpdGlvbmFsIGNodW5rXHJcbiAgICAgICAgICogZm9ybSBkYXRhIHdpbGwgYmUgc3VibWl0dGVkIGFuZCB0aGUgYGNodW5rc1VwbG9hZGVkYCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yY2VDaHVua2luZzogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGBjaHVua2luZ2AgaXMgYHRydWVgLCB0aGVuIHRoaXMgZGVmaW5lcyB0aGUgY2h1bmsgc2l6ZSBpbiBieXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjaHVua1NpemU6IDIwMDAwMDAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlIGluZGl2aWR1YWwgY2h1bmtzIG9mIGEgZmlsZSBhcmUgYmVpbmcgdXBsb2FkZWQgc2ltdWx0YW5lb3VzbHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyYWxsZWxDaHVua1VwbG9hZHM6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIGEgY2h1bmsgc2hvdWxkIGJlIHJldHJpZWQgaWYgaXQgZmFpbHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV0cnlDaHVua3M6IGZhbHNlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgcmV0cnlDaHVua3NgIGlzIHRydWUsIGhvdyBtYW55IHRpbWVzIHNob3VsZCBpdCBiZSByZXRyaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHJ5Q2h1bmtzTGltaXQ6IDMsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIG5vdCBgbnVsbGAgZGVmaW5lcyBob3cgbWFueSBmaWxlcyB0aGlzIERyb3B6b25lIGhhbmRsZXMuIElmIGl0IGV4Y2VlZHMsXHJcbiAgICAgICAgICogdGhlIGV2ZW50IGBtYXhmaWxlc2V4Y2VlZGVkYCB3aWxsIGJlIGNhbGxlZC4gVGhlIGRyb3B6b25lIGVsZW1lbnQgZ2V0cyB0aGVcclxuICAgICAgICAgKiBjbGFzcyBgZHotbWF4LWZpbGVzLXJlYWNoZWRgIGFjY29yZGluZ2x5IHNvIHlvdSBjYW4gcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWF4RmlsZXNpemU6IDI1NixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgcGFyYW0gdGhhdCBnZXRzIHRyYW5zZmVycmVkLlxyXG4gICAgICAgICAqICoqTk9URSoqOiBJZiB5b3UgaGF2ZSB0aGUgb3B0aW9uICBgdXBsb2FkTXVsdGlwbGVgIHNldCB0byBgdHJ1ZWAsIHRoZW5cclxuICAgICAgICAgKiBEcm9wem9uZSB3aWxsIGFwcGVuZCBgW11gIHRvIHRoZSBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcmFtTmFtZTogXCJmaWxlXCIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGh1bWJuYWlscyBmb3IgaW1hZ2VzIHNob3VsZCBiZSBnZW5lcmF0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVJbWFnZVRodW1ibmFpbHM6IHRydWUsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluIE1CLiBXaGVuIHRoZSBmaWxlbmFtZSBleGNlZWRzIHRoaXMgbGltaXQsIHRoZSB0aHVtYm5haWwgd2lsbCBub3QgYmUgZ2VuZXJhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1heFRodW1ibmFpbEZpbGVzaXplOiAxMCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYG51bGxgLCB0aGUgcmF0aW8gb2YgdGhlIGltYWdlIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGh1bWJuYWlsV2lkdGg6IDEyMCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNhbWUgYXMgYHRodW1ibmFpbFdpZHRoYC4gSWYgYm90aCBhcmUgbnVsbCwgaW1hZ2VzIHdpbGwgbm90IGJlIHJlc2l6ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGh1bWJuYWlsSGVpZ2h0OiAxMjAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvdyB0aGUgaW1hZ2VzIHNob3VsZCBiZSBzY2FsZWQgZG93biBpbiBjYXNlIGJvdGgsIGB0aHVtYm5haWxXaWR0aGAgYW5kIGB0aHVtYm5haWxIZWlnaHRgIGFyZSBwcm92aWRlZC5cclxuICAgICAgICAgKiBDYW4gYmUgZWl0aGVyIGBjb250YWluYCBvciBgY3JvcGAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGh1bWJuYWlsTWV0aG9kOiAnY3JvcCcsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHNldCwgaW1hZ2VzIHdpbGwgYmUgcmVzaXplZCB0byB0aGVzZSBkaW1lbnNpb25zIGJlZm9yZSBiZWluZyAqKnVwbG9hZGVkKiouXHJcbiAgICAgICAgICogSWYgb25seSBvbmUsIGByZXNpemVXaWR0aGAgKipvcioqIGByZXNpemVIZWlnaHRgIGlzIHByb3ZpZGVkLCB0aGUgb3JpZ2luYWwgYXNwZWN0XHJcbiAgICAgICAgICogcmF0aW8gb2YgdGhlIGZpbGUgd2lsbCBiZSBwcmVzZXJ2ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgYG9wdGlvbnMudHJhbnNmb3JtRmlsZWAgZnVuY3Rpb24gdXNlcyB0aGVzZSBvcHRpb25zLCBzbyBpZiB0aGUgYHRyYW5zZm9ybUZpbGVgIGZ1bmN0aW9uXHJcbiAgICAgICAgICogaXMgb3ZlcnJpZGRlbiwgdGhlc2Ugb3B0aW9ucyBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNpemVXaWR0aDogbnVsbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VlIGByZXNpemVXaWR0aGAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzaXplSGVpZ2h0OiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWltZSB0eXBlIG9mIHRoZSByZXNpemVkIGltYWdlIChiZWZvcmUgaXQgZ2V0cyB1cGxvYWRlZCB0byB0aGUgc2VydmVyKS5cclxuICAgICAgICAgKiBJZiBgbnVsbGAgdGhlIG9yaWdpbmFsIG1pbWUgdHlwZSB3aWxsIGJlIHVzZWQuIFRvIGZvcmNlIGpwZWcsIGZvciBleGFtcGxlLCB1c2UgYGltYWdlL2pwZWdgLlxyXG4gICAgICAgICAqIFNlZSBgcmVzaXplV2lkdGhgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2l6ZU1pbWVUeXBlOiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcXVhbGl0eSBvZiB0aGUgcmVzaXplZCBpbWFnZXMuIFNlZSBgcmVzaXplV2lkdGhgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2l6ZVF1YWxpdHk6IDAuOCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG93IHRoZSBpbWFnZXMgc2hvdWxkIGJlIHNjYWxlZCBkb3duIGluIGNhc2UgYm90aCwgYHJlc2l6ZVdpZHRoYCBhbmQgYHJlc2l6ZUhlaWdodGAgYXJlIHByb3ZpZGVkLlxyXG4gICAgICAgICAqIENhbiBiZSBlaXRoZXIgYGNvbnRhaW5gIG9yIGBjcm9wYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNpemVNZXRob2Q6ICdjb250YWluJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJhc2UgdGhhdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgZmlsZXNpemUuIFlvdSBjYW4gY2hhbmdlIHRoaXMgdG9cclxuICAgICAgICAgKiAxMDI0IGlmIHlvdSB3b3VsZCByYXRoZXIgZGlzcGxheSBraWJpYnl0ZXMsIG1lYmlieXRlcywgZXRjLi4uXHJcbiAgICAgICAgICogMTAyNCBpcyB0ZWNobmljYWxseSBpbmNvcnJlY3QsIGJlY2F1c2UgYDEwMjQgYnl0ZXNgIGFyZSBgMSBraWJpYnl0ZWAgbm90IGAxIGtpbG9ieXRlYC5cclxuICAgICAgICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvIGAxMDI0YCBpZiB5b3UgZG9uJ3QgY2FyZSBhYm91dCB2YWxpZGl0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmaWxlc2l6ZUJhc2U6IDEwMDAsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbiBiZSB1c2VkIHRvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyB0aGF0IHdpbGwgYmUgaGFuZGxlZCBieSB0aGlzIERyb3B6b25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWF4RmlsZXM6IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIG9iamVjdCB0byBzZW5kIGFkZGl0aW9uYWwgaGVhZGVycyB0byB0aGUgc2VydmVyLiBFZzpcclxuICAgICAgICAgKiBgeyBcIk15LUF3ZXNvbWUtSGVhZGVyXCI6IFwiaGVhZGVyIHZhbHVlXCIgfWBcclxuICAgICAgICAgKi9cclxuICAgICAgICBoZWFkZXJzOiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBkcm9wem9uZSBlbGVtZW50IGl0c2VsZiB3aWxsIGJlIGNsaWNrYWJsZSwgaWYgYGZhbHNlYFxyXG4gICAgICAgICAqIG5vdGhpbmcgd2lsbCBiZSBjbGlja2FibGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBIVE1MIGVsZW1lbnQsIGEgQ1NTIHNlbGVjdG9yIChmb3IgbXVsdGlwbGUgZWxlbWVudHMpXHJcbiAgICAgICAgICogb3IgYW4gYXJyYXkgb2YgdGhvc2UuIEluIHRoYXQgY2FzZSwgYWxsIG9mIHRob3NlIGVsZW1lbnRzIHdpbGwgdHJpZ2dlciBhblxyXG4gICAgICAgICAqIHVwbG9hZCB3aGVuIGNsaWNrZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIGhpZGRlbiBmaWxlcyBpbiBkaXJlY3RvcmllcyBzaG91bGQgYmUgaWdub3JlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZ25vcmVIaWRkZW5GaWxlczogdHJ1ZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYGFjY2VwdGAgY2hlY2tzIHRoZSBmaWxlJ3MgbWltZSB0eXBlIG9yXHJcbiAgICAgICAgICogZXh0ZW5zaW9uIGFnYWluc3QgdGhpcyBsaXN0LiBUaGlzIGlzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbWltZVxyXG4gICAgICAgICAqIHR5cGVzIG9yIGZpbGUgZXh0ZW5zaW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEVnLjogYGltYWdlLyosYXBwbGljYXRpb24vcGRmLC5wc2RgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiB0aGUgRHJvcHpvbmUgaXMgYGNsaWNrYWJsZWAgdGhpcyBvcHRpb24gd2lsbCBhbHNvIGJlIHVzZWQgYXNcclxuICAgICAgICAgKiBbYGFjY2VwdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItYWNjZXB0KVxyXG4gICAgICAgICAqIHBhcmFtZXRlciBvbiB0aGUgaGlkZGVuIGZpbGUgaW5wdXQgYXMgd2VsbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhY2NlcHRlZEZpbGVzOiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAqKkRlcHJlY2F0ZWQhKipcclxuICAgICAgICAgKiBVc2UgYWNjZXB0ZWRGaWxlcyBpbnN0ZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFjY2VwdGVkTWltZVR5cGVzOiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBmYWxzZSwgZmlsZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYnV0IHRoZSBxdWV1ZSB3aWxsIG5vdCBiZVxyXG4gICAgICAgICAqIHByb2Nlc3NlZCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgbmVlZCBzb21lIGFkZGl0aW9uYWwgdXNlciBpbnB1dCBiZWZvcmUgc2VuZGluZ1xyXG4gICAgICAgICAqIGZpbGVzIChvciBpZiB5b3Ugd2FudCB3YW50IGFsbCBmaWxlcyBzZW50IGF0IG9uY2UpLlxyXG4gICAgICAgICAqIElmIHlvdSdyZSByZWFkeSB0byBzZW5kIHRoZSBmaWxlIHNpbXBseSBjYWxsIGBteURyb3B6b25lLnByb2Nlc3NRdWV1ZSgpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFNlZSB0aGUgW2VucXVldWluZyBmaWxlIHVwbG9hZHNdKCNlbnF1ZXVpbmctZmlsZS11cGxvYWRzKSBkb2N1bWVudGF0aW9uXHJcbiAgICAgICAgICogc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhdXRvUHJvY2Vzc1F1ZXVlOiB0cnVlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBmYWxzZSwgZmlsZXMgYWRkZWQgdG8gdGhlIGRyb3B6b25lIHdpbGwgbm90IGJlIHF1ZXVlZCBieSBkZWZhdWx0LlxyXG4gICAgICAgICAqIFlvdSdsbCBoYXZlIHRvIGNhbGwgYGVucXVldWVGaWxlKGZpbGUpYCBtYW51YWxseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhdXRvUXVldWU6IHRydWUsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhpcyB3aWxsIGFkZCBhIGxpbmsgdG8gZXZlcnkgZmlsZSBwcmV2aWV3IHRvIHJlbW92ZSBvciBjYW5jZWwgKGlmXHJcbiAgICAgICAgICogYWxyZWFkeSB1cGxvYWRpbmcpIHRoZSBmaWxlLiBUaGUgYGRpY3RDYW5jZWxVcGxvYWRgLCBgZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbmBcclxuICAgICAgICAgKiBhbmQgYGRpY3RSZW1vdmVGaWxlYCBvcHRpb25zIGFyZSB1c2VkIGZvciB0aGUgd29yZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRSZW1vdmVMaW5rczogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZXMgd2hlcmUgdG8gZGlzcGxheSB0aGUgZmlsZSBwcmV2aWV3cyDigJMgaWYgYG51bGxgIHRoZVxyXG4gICAgICAgICAqIERyb3B6b25lIGVsZW1lbnQgaXRzZWxmIGlzIHVzZWQuIENhbiBiZSBhIHBsYWluIGBIVE1MRWxlbWVudGAgb3IgYSBDU1NcclxuICAgICAgICAgKiBzZWxlY3Rvci4gVGhlIGVsZW1lbnQgc2hvdWxkIGhhdmUgdGhlIGBkcm9wem9uZS1wcmV2aWV3c2AgY2xhc3Mgc29cclxuICAgICAgICAgKiB0aGUgcHJldmlld3MgYXJlIGRpc3BsYXllZCBwcm9wZXJseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcmV2aWV3c0NvbnRhaW5lcjogbnVsbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGUgaGlkZGVuIGlucHV0IGZpZWxkICh3aGljaCBpcyB1c2VkIHdoZW4gY2xpY2tpbmcgb24gdGhlXHJcbiAgICAgICAgICogZHJvcHpvbmUgdG8gdHJpZ2dlciBmaWxlIHNlbGVjdGlvbikgd2lsbCBiZSBhcHBlbmRlZCB0by4gVGhpcyBtaWdodFxyXG4gICAgICAgICAqIGJlIGltcG9ydGFudCBpbiBjYXNlIHlvdSB1c2UgZnJhbWV3b3JrcyB0byBzd2l0Y2ggdGhlIGNvbnRlbnQgb2YgeW91ciBwYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGhpZGRlbklucHV0Q29udGFpbmVyOiBcImJvZHlcIixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgbnVsbCwgbm8gY2FwdHVyZSB0eXBlIHdpbGwgYmUgc3BlY2lmaWVkXHJcbiAgICAgICAgICogSWYgY2FtZXJhLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgY2FtZXJhXHJcbiAgICAgICAgICogSWYgbWljcm9waG9uZSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIHRoZSBtaWNyb3Bob25lXHJcbiAgICAgICAgICogSWYgY2FtY29yZGVyLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgdGhlIGNhbWVyYSBpbiB2aWRlbyBtb2RlXHJcbiAgICAgICAgICogT24gYXBwbGUgZGV2aWNlcyBtdWx0aXBsZSBtdXN0IGJlIHNldCB0byBmYWxzZS4gIEFjY2VwdGVkRmlsZXMgbWF5IG5lZWQgdG9cclxuICAgICAgICAgKiBiZSBzZXQgdG8gYW4gYXBwcm9wcmlhdGUgbWltZSB0eXBlIChlLmcuIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiwgb3IgXCJ2aWRlby8qXCIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhcHR1cmU6IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICoqRGVwcmVjYXRlZCoqLiBVc2UgYHJlbmFtZUZpbGVgIGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVuYW1lRmlsZW5hbWU6IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGJlZm9yZSB0aGUgZmlsZSBpcyB1cGxvYWRlZCB0byB0aGUgc2VydmVyIGFuZCByZW5hbWVzIHRoZSBmaWxlLlxyXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgYEZpbGVgIGFzIGFyZ3VtZW50IGFuZCBjYW4gdXNlIHRoZSBgZmlsZS5uYW1lYC4gVGhlIGFjdHVhbCBuYW1lIG9mIHRoZVxyXG4gICAgICAgICAqIGZpbGUgdGhhdCBnZXRzIHVzZWQgZHVyaW5nIHRoZSB1cGxvYWQgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggYGZpbGUudXBsb2FkLmZpbGVuYW1lYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZW5hbWVGaWxlOiBudWxsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgdHJ1ZWAgdGhlIGZhbGxiYWNrIHdpbGwgYmUgZm9yY2VkLiBUaGlzIGlzIHZlcnkgdXNlZnVsIHRvIHRlc3QgeW91ciBzZXJ2ZXJcclxuICAgICAgICAgKiBpbXBsZW1lbnRhdGlvbnMgZmlyc3QgYW5kIG1ha2Ugc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgd29ya3MgYXNcclxuICAgICAgICAgKiBleHBlY3RlZCB3aXRob3V0IGRyb3B6b25lIGlmIHlvdSBleHBlcmllbmNlIHByb2JsZW1zLCBhbmQgdG8gdGVzdFxyXG4gICAgICAgICAqIGhvdyB5b3VyIGZhbGxiYWNrcyB3aWxsIGxvb2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IHVzZWQgYmVmb3JlIGFueSBmaWxlcyBhcmUgZHJvcHBlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaWN0RGVmYXVsdE1lc3NhZ2U6IFwiRHJvcCBmaWxlcyBoZXJlIHRvIHVwbG9hZFwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCB0aGF0IHJlcGxhY2VzIHRoZSBkZWZhdWx0IG1lc3NhZ2UgdGV4dCBpdCB0aGUgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpY3RGYWxsYmFja01lc3NhZ2U6IFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZHJhZyduJ2Ryb3AgZmlsZSB1cGxvYWRzLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCB0aGF0IHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoZSBmYWxsYmFjayBmb3JtLlxyXG4gICAgICAgICAqIElmIHlvdSBwcm92aWRlIGEgIGZhbGxiYWNrIGVsZW1lbnQgeW91cnNlbGYsIG9yIGlmIHRoaXMgb3B0aW9uIGlzIGBudWxsYCB0aGlzIHdpbGxcclxuICAgICAgICAgKiBiZSBpZ25vcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpY3RGYWxsYmFja1RleHQ6IFwiUGxlYXNlIHVzZSB0aGUgZmFsbGJhY2sgZm9ybSBiZWxvdyB0byB1cGxvYWQgeW91ciBmaWxlcyBsaWtlIGluIHRoZSBvbGRlbiBkYXlzLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgZmlsZXNpemUgaXMgdG9vIGJpZy5cclxuICAgICAgICAgKiBge3tmaWxlc2l6ZX19YCBhbmQgYHt7bWF4RmlsZXNpemV9fWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSByZXNwZWN0aXZlIGNvbmZpZ3VyYXRpb24gdmFsdWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpY3RGaWxlVG9vQmlnOiBcIkZpbGUgaXMgdG9vIGJpZyAoe3tmaWxlc2l6ZX19TWlCKS4gTWF4IGZpbGVzaXplOiB7e21heEZpbGVzaXplfX1NaUIuXCIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBmaWxlIGRvZXNuJ3QgbWF0Y2ggdGhlIGZpbGUgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaWN0SW52YWxpZEZpbGVUeXBlOiBcIllvdSBjYW4ndCB1cGxvYWQgZmlsZXMgb2YgdGhpcyB0eXBlLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgc2VydmVyIHJlc3BvbnNlIHdhcyBpbnZhbGlkLlxyXG4gICAgICAgICAqIGB7e3N0YXR1c0NvZGV9fWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzZXJ2ZXJzIHN0YXR1cyBjb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpY3RSZXNwb25zZUVycm9yOiBcIlNlcnZlciByZXNwb25kZWQgd2l0aCB7e3N0YXR1c0NvZGV9fSBjb2RlLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgYWRkUmVtb3ZlTGlua3NgIGlzIHRydWUsIHRoZSB0ZXh0IHRvIGJlIHVzZWQgZm9yIHRoZSBjYW5jZWwgdXBsb2FkIGxpbmsuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGljdENhbmNlbFVwbG9hZDogXCJDYW5jZWwgdXBsb2FkXCIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGlmIGFuIHVwbG9hZCB3YXMgbWFudWFsbHkgY2FuY2VsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBkaWN0VXBsb2FkQ2FuY2VsZWQ6IFwiVXBsb2FkIGNhbmNlbGVkLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBgYWRkUmVtb3ZlTGlua3NgIGlzIHRydWUsIHRoZSB0ZXh0IHRvIGJlIHVzZWQgZm9yIGNvbmZpcm1hdGlvbiB3aGVuIGNhbmNlbGxpbmcgdXBsb2FkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb246IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNhbmNlbCB0aGlzIHVwbG9hZD9cIixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYGFkZFJlbW92ZUxpbmtzYCBpcyB0cnVlLCB0aGUgdGV4dCB0byBiZSB1c2VkIHRvIHJlbW92ZSBhIGZpbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGljdFJlbW92ZUZpbGU6IFwiUmVtb3ZlIGZpbGVcIixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhpcyBpcyBub3QgbnVsbCwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIGJlZm9yZSByZW1vdmluZyBhIGZpbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGljdFJlbW92ZUZpbGVDb25maXJtYXRpb246IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3BsYXllZCBpZiBgbWF4RmlsZXNgIGlzIHN0IGFuZCBleGNlZWRlZC5cclxuICAgICAgICAgKiBUaGUgc3RyaW5nIGB7e21heEZpbGVzfX1gIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGljdE1heEZpbGVzRXhjZWVkZWQ6IFwiWW91IGNhbiBub3QgdXBsb2FkIGFueSBtb3JlIGZpbGVzLlwiLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIHRyYW5zbGF0ZSB0aGUgZGlmZmVyZW50IHVuaXRzLiBTdGFydGluZyB3aXRoIGB0YmAgZm9yIHRlcmFieXRlcyBhbmQgZ29pbmcgZG93biB0b1xyXG4gICAgICAgICAqIGBiYCBmb3IgYnl0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGljdEZpbGVTaXplVW5pdHM6IHsgdGI6IFwiVEJcIiwgZ2I6IFwiR0JcIiwgbWI6IFwiTUJcIiwga2I6IFwiS0JcIiwgYjogXCJiXCIgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBkcm9wem9uZSBpbml0aWFsaXplZFxyXG4gICAgICAgICAqIFlvdSBjYW4gYWRkIGV2ZW50IGxpc3RlbmVycyBoZXJlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHt9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuIGJlIGFuICoqb2JqZWN0Kiogb2YgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRyYW5zZmVyIHRvIHRoZSBzZXJ2ZXIsICoqb3IqKiBhIGBGdW5jdGlvbmBcclxuICAgICAgICAgKiB0aGF0IGdldHMgaW52b2tlZCB3aXRoIHRoZSBgZmlsZXNgLCBgeGhyYCBhbmQsIGlmIGl0J3MgYSBjaHVua2VkIHVwbG9hZCwgYGNodW5rYCBhcmd1bWVudHMuIEluIGNhc2VcclxuICAgICAgICAgKiBvZiBhIGZ1bmN0aW9uLCB0aGlzIG5lZWRzIHRvIHJldHVybiBhIG1hcC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90aGluZyBmb3Igbm9ybWFsIHVwbG9hZHMsIGJ1dCBhZGRzIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvclxyXG4gICAgICAgICAqIGNodW5rZWQgdXBsb2Fkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYWRkaW5nIGhpZGRlbiBpbnB1dCBmaWVsZHMgaW4gdGhlIGZvcm0gZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJhbXM6IGZ1bmN0aW9uIHBhcmFtcyhmaWxlcywgeGhyLCBjaHVuaykge1xyXG4gICAgICAgICAgaWYgKGNodW5rKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgZHp1dWlkOiBjaHVuay5maWxlLnVwbG9hZC51dWlkLFxyXG4gICAgICAgICAgICAgIGR6Y2h1bmtpbmRleDogY2h1bmsuaW5kZXgsXHJcbiAgICAgICAgICAgICAgZHp0b3RhbGZpbGVzaXplOiBjaHVuay5maWxlLnNpemUsXHJcbiAgICAgICAgICAgICAgZHpjaHVua3NpemU6IHRoaXMub3B0aW9ucy5jaHVua1NpemUsXHJcbiAgICAgICAgICAgICAgZHp0b3RhbGNodW5rY291bnQ6IGNodW5rLmZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCxcclxuICAgICAgICAgICAgICBkemNodW5rYnl0ZW9mZnNldDogY2h1bmsuaW5kZXggKiB0aGlzLm9wdGlvbnMuY2h1bmtTaXplXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGEgW2ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0ZpbGUpXHJcbiAgICAgICAgICogYW5kIGEgYGRvbmVgIGZ1bmN0aW9uIGFzIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiB0aGUgZG9uZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCB0aGUgZmlsZSBpcyBcImFjY2VwdGVkXCIgYW5kIHdpbGxcclxuICAgICAgICAgKiBiZSBwcm9jZXNzZWQuIElmIHlvdSBwYXNzIGFuIGVycm9yIG1lc3NhZ2UsIHRoZSBmaWxlIGlzIHJlamVjdGVkLCBhbmQgdGhlIGVycm9yXHJcbiAgICAgICAgICogbWVzc2FnZSB3aWxsIGJlIGRpc3BsYXllZC5cclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZmlsZSBpcyB0b28gYmlnIG9yIGRvZXNuJ3QgbWF0Y2ggdGhlIG1pbWUgdHlwZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiBhY2NlcHQoZmlsZSwgZG9uZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYWxsIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgZm9yIGEgZmlsZS5cclxuICAgICAgICAgKiBJdCBnZXRzIHRoZSBmaWxlIGZvciB3aGljaCB0aGUgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLFxyXG4gICAgICAgICAqIGFuZCB0aGUgYGRvbmVgIGZ1bmN0aW9uIGFzIHNlY29uZC4gYGRvbmUoKWAgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIGV2ZXJ5dGhpbmdcclxuICAgICAgICAgKiBuZWVkZWQgdG8gZmluaXNoIHRoZSB1cGxvYWQgcHJvY2VzcyBpcyBkb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNodW5rc1VwbG9hZGVkOiBmdW5jdGlvbiBjaHVua3NVcGxvYWRlZChmaWxlLCBkb25lKSB7XHJcbiAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNob3dzIHRoZSBmYWxsYmFjayBpbnB1dCBmaWVsZCBhbmQgYWRkc1xyXG4gICAgICAgICAqIGEgdGV4dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGNvZGUgc2hvdWxkIHBhc3MgaW4gSUU3Li4uIDooXHJcbiAgICAgICAgICB2YXIgbWVzc2FnZUVsZW1lbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZSArIFwiIGR6LWJyb3dzZXItbm90LXN1cHBvcnRlZFwiO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIiksIF9pc0FycmF5MiA9IHRydWUsIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgICB2YXIgX3JlZjI7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XHJcbiAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcclxuICAgICAgICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfcmVmMjtcclxuXHJcbiAgICAgICAgICAgIGlmICgvKF58IClkei1tZXNzYWdlKCR8ICkvLnRlc3QoY2hpbGQuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgY2hpbGQuY2xhc3NOYW1lID0gXCJkei1tZXNzYWdlXCI7IC8vIFJlbW92ZXMgdGhlICdkei1kZWZhdWx0JyBjbGFzc1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIW1lc3NhZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50ID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxkaXYgY2xhc3M9XFxcImR6LW1lc3NhZ2VcXFwiPjxzcGFuPjwvc3Bhbj48L2Rpdj5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIHNwYW4gPSBtZXNzYWdlRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIilbMF07XHJcbiAgICAgICAgICBpZiAoc3Bhbikge1xyXG4gICAgICAgICAgICBpZiAoc3Bhbi50ZXh0Q29udGVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwYW4uaW5uZXJUZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICBzcGFuLmlubmVyVGV4dCA9IHRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmdldEZhbGxiYWNrRm9ybSgpKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjYWxsZWQgdG8gY2FsY3VsYXRlIHRoZSB0aHVtYm5haWwgZGltZW5zaW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IGdldHMgYGZpbGVgLCBgd2lkdGhgIGFuZCBgaGVpZ2h0YCAoYm90aCBtYXkgYmUgYG51bGxgKSBhcyBwYXJhbWV0ZXJzIGFuZCBtdXN0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZzpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAtIGBzcmNXaWR0aGAgJiBgc3JjSGVpZ2h0YCAocmVxdWlyZWQpXHJcbiAgICAgICAgICogIC0gYHRyZ1dpZHRoYCAmIGB0cmdIZWlnaHRgIChyZXF1aXJlZClcclxuICAgICAgICAgKiAgLSBgc3JjWGAgJiBgc3JjWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcclxuICAgICAgICAgKiAgLSBgdHJnWGAgJiBgdHJnWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRob3NlIHZhbHVlcyBhcmUgZ29pbmcgdG8gYmUgdXNlZCBieSBgY3R4LmRyYXdJbWFnZSgpYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZShmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QpIHtcclxuICAgICAgICAgIHZhciBpbmZvID0ge1xyXG4gICAgICAgICAgICBzcmNYOiAwLFxyXG4gICAgICAgICAgICBzcmNZOiAwLFxyXG4gICAgICAgICAgICBzcmNXaWR0aDogZmlsZS53aWR0aCxcclxuICAgICAgICAgICAgc3JjSGVpZ2h0OiBmaWxlLmhlaWdodFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgc3JjUmF0aW8gPSBmaWxlLndpZHRoIC8gZmlsZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSBjYWxjdWxhdGUgZGltZW5zaW9ucyBpZiBub3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGluZm8uc3JjV2lkdGg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGluZm8uc3JjSGVpZ2h0O1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogc3JjUmF0aW87XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGltYWdlcyBhcmVuJ3QgdXBzY2FsZWRcclxuICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIGluZm8uc3JjV2lkdGgpO1xyXG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBpbmZvLnNyY0hlaWdodCk7XHJcblxyXG4gICAgICAgICAgdmFyIHRyZ1JhdGlvID0gd2lkdGggLyBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKGluZm8uc3JjV2lkdGggPiB3aWR0aCB8fCBpbmZvLnNyY0hlaWdodCA+IGhlaWdodCkge1xyXG4gICAgICAgICAgICAvLyBJbWFnZSBpcyBiaWdnZXIgYW5kIG5lZWRzIHJlc2NhbGluZ1xyXG4gICAgICAgICAgICBpZiAocmVzaXplTWV0aG9kID09PSAnY3JvcCcpIHtcclxuICAgICAgICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgaW5mby5zcmNIZWlnaHQgPSBmaWxlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGluZm8uc3JjV2lkdGggPSBpbmZvLnNyY0hlaWdodCAqIHRyZ1JhdGlvO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLnNyY1dpZHRoID0gZmlsZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGluZm8uc3JjSGVpZ2h0ID0gaW5mby5zcmNXaWR0aCAvIHRyZ1JhdGlvO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNpemVNZXRob2QgPT09ICdjb250YWluJykge1xyXG4gICAgICAgICAgICAgIC8vIE1ldGhvZCAnY29udGFpbidcclxuICAgICAgICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBzcmNSYXRpbztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByZXNpemVNZXRob2QgJ1wiICsgcmVzaXplTWV0aG9kICsgXCInXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaW5mby5zcmNYID0gKGZpbGUud2lkdGggLSBpbmZvLnNyY1dpZHRoKSAvIDI7XHJcbiAgICAgICAgICBpbmZvLnNyY1kgPSAoZmlsZS5oZWlnaHQgLSBpbmZvLnNyY0hlaWdodCkgLyAyO1xyXG5cclxuICAgICAgICAgIGluZm8udHJnV2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgIGluZm8udHJnSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGZpbGUgKGZvciBleGFtcGxlLCByZXNpemUgYW4gaW1hZ2UgaWYgbmVjZXNzYXJ5KS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZXMgYHJlc2l6ZVdpZHRoYCBhbmQgYHJlc2l6ZUhlaWdodGAgKGlmIHByb3ZpZGVkKSBhbmQgcmVzaXplc1xyXG4gICAgICAgICAqIGltYWdlcyBhY2NvcmRpbmcgdG8gdGhvc2UgZGltZW5zaW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGBmaWxlYCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCBhbmQgYSBgZG9uZSgpYCBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kLCB0aGF0IG5lZWRzXHJcbiAgICAgICAgICogdG8gYmUgaW52b2tlZCB3aXRoIHRoZSBmaWxlIHdoZW4gdGhlIHRyYW5zZm9ybWF0aW9uIGlzIGRvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJhbnNmb3JtRmlsZTogZnVuY3Rpb24gdHJhbnNmb3JtRmlsZShmaWxlLCBkb25lKSB7XHJcbiAgICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5yZXNpemVXaWR0aCB8fCB0aGlzLm9wdGlvbnMucmVzaXplSGVpZ2h0KSAmJiBmaWxlLnR5cGUubWF0Y2goL2ltYWdlLiovKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemVJbWFnZShmaWxlLCB0aGlzLm9wdGlvbnMucmVzaXplV2lkdGgsIHRoaXMub3B0aW9ucy5yZXNpemVIZWlnaHQsIHRoaXMub3B0aW9ucy5yZXNpemVNZXRob2QsIGRvbmUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvbmUoZmlsZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHRlbXBsYXRlIHVzZWQgZm9yIGVhY2ggZHJvcHBlZFxyXG4gICAgICAgICAqIGZpbGUuIENoYW5nZSBpdCB0byBmdWxmaWxsIHlvdXIgbmVlZHMgYnV0IG1ha2Ugc3VyZSB0byBwcm9wZXJseVxyXG4gICAgICAgICAqIHByb3ZpZGUgYWxsIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFuIGFjdHVhbCBIVE1MIGVsZW1lbnQgaW5zdGVhZCBvZiBwcm92aWRpbmcgYSBTdHJpbmdcclxuICAgICAgICAgKiBhcyBhIGNvbmZpZyBvcHRpb24sIHlvdSBjb3VsZCBjcmVhdGUgYSBkaXYgd2l0aCB0aGUgaWQgYHRwbGAsXHJcbiAgICAgICAgICogcHV0IHRoZSB0ZW1wbGF0ZSBpbnNpZGUgaXQgYW5kIHByb3ZpZGUgdGhlIGVsZW1lbnQgbGlrZSB0aGlzOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGRvY3VtZW50XHJcbiAgICAgICAgICogICAgICAgLnF1ZXJ5U2VsZWN0b3IoJyN0cGwnKVxyXG4gICAgICAgICAqICAgICAgIC5pbm5lckhUTUxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByZXZpZXdUZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJkei1wcmV2aWV3IGR6LWZpbGUtcHJldmlld1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1pbWFnZVxcXCI+PGltZyBkYXRhLWR6LXRodW1ibmFpbCAvPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotZGV0YWlsc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImR6LXNpemVcXFwiPjxzcGFuIGRhdGEtZHotc2l6ZT48L3NwYW4+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImR6LWZpbGVuYW1lXFxcIj48c3BhbiBkYXRhLWR6LW5hbWU+PC9zcGFuPjwvZGl2PlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1wcm9ncmVzc1xcXCI+PHNwYW4gY2xhc3M9XFxcImR6LXVwbG9hZFxcXCIgZGF0YS1kei11cGxvYWRwcm9ncmVzcz48L3NwYW4+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1lcnJvci1tZXNzYWdlXFxcIj48c3BhbiBkYXRhLWR6LWVycm9ybWVzc2FnZT48L3NwYW4+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1zdWNjZXNzLW1hcmtcXFwiPlxcbiAgICA8c3ZnIHdpZHRoPVxcXCI1NHB4XFxcIiBoZWlnaHQ9XFxcIjU0cHhcXFwiIHZpZXdCb3g9XFxcIjAgMCA1NCA1NFxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4bWxuczpza2V0Y2g9XFxcImh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9uc1xcXCI+XFxuICAgICAgPHRpdGxlPkNoZWNrPC90aXRsZT5cXG4gICAgICA8ZGVmcz48L2RlZnM+XFxuICAgICAgPGcgaWQ9XFxcIlBhZ2UtMVxcXCIgc3Ryb2tlPVxcXCJub25lXFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIGZpbGwtcnVsZT1cXFwiZXZlbm9kZFxcXCIgc2tldGNoOnR5cGU9XFxcIk1TUGFnZVxcXCI+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMjMuNSwzMS44NDMxNDU4IEwxNy41ODUyNDE5LDI1LjkyODM4NzcgQzE2LjAyNDgyNTMsMjQuMzY3OTcxMSAxMy40OTEwMjk0LDI0LjM2NjgzNSAxMS45Mjg5MzIyLDI1LjkyODkzMjIgQzEwLjM3MDAxMzYsMjcuNDg3ODUwOCAxMC4zNjY1OTEyLDMwLjAyMzQ0NTUgMTEuOTI4Mzg3NywzMS41ODUyNDE5IEwyMC40MTQ3NTgxLDQwLjA3MTYxMjMgQzIwLjUxMzM5OTksNDAuMTcwMjU0MSAyMC42MTU5MzE1LDQwLjI2MjY2NDkgMjAuNzIxODYxNSw0MC4zNDg4NDM1IEMyMi4yODM1NjY5LDQxLjg3MjU2NTEgMjQuNzk0MjM0LDQxLjg2MjYyMDIgMjYuMzQ2MTU2NCw0MC4zMTA2OTc4IEw0My4zMTA2OTc4LDIzLjM0NjE1NjQgQzQ0Ljg3NzEwMjEsMjEuNzc5NzUyMSA0NC44NzU4MDU3LDE5LjI0ODM4ODcgNDMuMzEzNzA4NSwxNy42ODYyOTE1IEM0MS43NTQ3ODk5LDE2LjEyNzM3MjkgMzkuMjE3NjAzNSwxNi4xMjU1NDIyIDM3LjY1Mzg0MzYsMTcuNjg5MzAyMiBMMjMuNSwzMS44NDMxNDU4IFogTTI3LDUzIEM0MS4zNTk0MDM1LDUzIDUzLDQxLjM1OTQwMzUgNTMsMjcgQzUzLDEyLjY0MDU5NjUgNDEuMzU5NDAzNSwxIDI3LDEgQzEyLjY0MDU5NjUsMSAxLDEyLjY0MDU5NjUgMSwyNyBDMSw0MS4zNTk0MDM1IDEyLjY0MDU5NjUsNTMgMjcsNTMgWlxcXCIgaWQ9XFxcIk92YWwtMlxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjAuMTk4Nzk0MTU4XFxcIiBzdHJva2U9XFxcIiM3NDc0NzRcXFwiIGZpbGwtb3BhY2l0eT1cXFwiMC44MTY1MTk0NzVcXFwiIGZpbGw9XFxcIiNGRkZGRkZcXFwiIHNrZXRjaDp0eXBlPVxcXCJNU1NoYXBlR3JvdXBcXFwiPjwvcGF0aD5cXG4gICAgICA8L2c+XFxuICAgIDwvc3ZnPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1lcnJvci1tYXJrXFxcIj5cXG4gICAgPHN2ZyB3aWR0aD1cXFwiNTRweFxcXCIgaGVpZ2h0PVxcXCI1NHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgNTQgNTRcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeG1sbnM6c2tldGNoPVxcXCJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnNcXFwiPlxcbiAgICAgIDx0aXRsZT5FcnJvcjwvdGl0bGU+XFxuICAgICAgPGRlZnM+PC9kZWZzPlxcbiAgICAgIDxnIGlkPVxcXCJQYWdlLTFcXFwiIHN0cm9rZT1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxXFxcIiBmaWxsPVxcXCJub25lXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiIHNrZXRjaDp0eXBlPVxcXCJNU1BhZ2VcXFwiPlxcbiAgICAgICAgPGcgaWQ9XFxcIkNoZWNrLSstT3ZhbC0yXFxcIiBza2V0Y2g6dHlwZT1cXFwiTVNMYXllckdyb3VwXFxcIiBzdHJva2U9XFxcIiM3NDc0NzRcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXCIwLjE5ODc5NDE1OFxcXCIgZmlsbD1cXFwiI0ZGRkZGRlxcXCIgZmlsbC1vcGFjaXR5PVxcXCIwLjgxNjUxOTQ3NVxcXCI+XFxuICAgICAgICAgIDxwYXRoIGQ9XFxcIk0zMi42NTY4NTQyLDI5IEwzOC4zMTA2OTc4LDIzLjM0NjE1NjQgQzM5Ljg3NzEwMjEsMjEuNzc5NzUyMSAzOS44NzU4MDU3LDE5LjI0ODM4ODcgMzguMzEzNzA4NSwxNy42ODYyOTE1IEMzNi43NTQ3ODk5LDE2LjEyNzM3MjkgMzQuMjE3NjAzNSwxNi4xMjU1NDIyIDMyLjY1Mzg0MzYsMTcuNjg5MzAyMiBMMjcsMjMuMzQzMTQ1OCBMMjEuMzQ2MTU2NCwxNy42ODkzMDIyIEMxOS43ODIzOTY1LDE2LjEyNTU0MjIgMTcuMjQ1MjEwMSwxNi4xMjczNzI5IDE1LjY4NjI5MTUsMTcuNjg2MjkxNSBDMTQuMTI0MTk0MywxOS4yNDgzODg3IDE0LjEyMjg5NzksMjEuNzc5NzUyMSAxNS42ODkzMDIyLDIzLjM0NjE1NjQgTDIxLjM0MzE0NTgsMjkgTDE1LjY4OTMwMjIsMzQuNjUzODQzNiBDMTQuMTIyODk3OSwzNi4yMjAyNDc5IDE0LjEyNDE5NDMsMzguNzUxNjExMyAxNS42ODYyOTE1LDQwLjMxMzcwODUgQzE3LjI0NTIxMDEsNDEuODcyNjI3MSAxOS43ODIzOTY1LDQxLjg3NDQ1NzggMjEuMzQ2MTU2NCw0MC4zMTA2OTc4IEwyNywzNC42NTY4NTQyIEwzMi42NTM4NDM2LDQwLjMxMDY5NzggQzM0LjIxNzYwMzUsNDEuODc0NDU3OCAzNi43NTQ3ODk5LDQxLjg3MjYyNzEgMzguMzEzNzA4NSw0MC4zMTM3MDg1IEMzOS44NzU4MDU3LDM4Ljc1MTYxMTMgMzkuODc3MTAyMSwzNi4yMjAyNDc5IDM4LjMxMDY5NzgsMzQuNjUzODQzNiBMMzIuNjU2ODU0MiwyOSBaIE0yNyw1MyBDNDEuMzU5NDAzNSw1MyA1Myw0MS4zNTk0MDM1IDUzLDI3IEM1MywxMi42NDA1OTY1IDQxLjM1OTQwMzUsMSAyNywxIEMxMi42NDA1OTY1LDEgMSwxMi42NDA1OTY1IDEsMjcgQzEsNDEuMzU5NDAzNSAxMi42NDA1OTY1LDUzIDI3LDUzIFpcXFwiIGlkPVxcXCJPdmFsLTJcXFwiIHNrZXRjaDp0eXBlPVxcXCJNU1NoYXBlR3JvdXBcXFwiPjwvcGF0aD5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L2c+XFxuICAgIDwvc3ZnPlxcbiAgPC9kaXY+XFxuPC9kaXY+XCIsXHJcblxyXG4gICAgICAgIC8vIEVORCBPUFRJT05TXHJcbiAgICAgICAgLy8gKFJlcXVpcmVkIGJ5IHRoZSBkcm9wem9uZSBkb2N1bWVudGF0aW9uIHBhcnNlcilcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIFRob3NlIGZ1bmN0aW9ucyByZWdpc3RlciB0aGVtc2VsdmVzIHRvIHRoZSBldmVudHMgb24gaW5pdCBhbmQgaGFuZGxlIGFsbFxyXG4gICAgICAgICB0aGUgdXNlciBpbnRlcmZhY2Ugc3BlY2lmaWMgc3R1ZmYuIE92ZXJ3cml0aW5nIHRoZW0gd29uJ3QgYnJlYWsgdGhlIHVwbG9hZFxyXG4gICAgICAgICBidXQgY2FuIGJyZWFrIHRoZSB3YXkgaXQncyBkaXNwbGF5ZWQuXHJcbiAgICAgICAgIFlvdSBjYW4gb3ZlcndyaXRlIHRoZW0gaWYgeW91IGRvbid0IGxpa2UgdGhlIGRlZmF1bHQgYmVoYXZpb3IuIElmIHlvdSBqdXN0XHJcbiAgICAgICAgIHdhbnQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgZXZlbnQgaGFuZGxlciwgcmVnaXN0ZXIgaXQgb24gdGhlIGRyb3B6b25lIG9iamVjdFxyXG4gICAgICAgICBhbmQgZG9uJ3Qgb3ZlcndyaXRlIHRob3NlIG9wdGlvbnMuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIFRob3NlIGFyZSBzZWxmIGV4cGxhbmF0b3J5IGFuZCBzaW1wbHkgY29uY2VybiB0aGUgRHJhZ25Ecm9wLlxyXG4gICAgICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdzdGFydDogZnVuY3Rpb24gZHJhZ3N0YXJ0KGUpIHt9LFxyXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIGRyYWdlbmQoZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdlbnRlcjogZnVuY3Rpb24gZHJhZ2VudGVyKGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWRyYWctaG92ZXJcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmFnb3ZlcjogZnVuY3Rpb24gZHJhZ292ZXIoZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotZHJhZy1ob3ZlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdsZWF2ZTogZnVuY3Rpb24gZHJhZ2xlYXZlKGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWRyYWctaG92ZXJcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXN0ZTogZnVuY3Rpb24gcGFzdGUoZSkge30sXHJcblxyXG5cclxuICAgICAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIGZpbGVzIGxlZnQgaW4gdGhlIGRyb3B6b25lIGFueW1vcmUsIGFuZCB0aGVcclxuICAgICAgICAvLyBkcm9wem9uZSBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGlmIGluIHRoZSBpbml0aWFsIHN0YXRlLlxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LXN0YXJ0ZWRcIik7XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIGEgZmlsZSBpcyBhZGRlZCB0byB0aGUgcXVldWVcclxuICAgICAgICAvLyBSZWNlaXZlcyBgZmlsZWBcclxuICAgICAgICBhZGRlZGZpbGU6IGZ1bmN0aW9uIGFkZGVkZmlsZShmaWxlKSB7XHJcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSB0aGlzLnByZXZpZXdzQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotc3RhcnRlZFwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5wcmV2aWV3c0NvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50ID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMucHJldmlld1RlbXBsYXRlLnRyaW0oKSk7XHJcbiAgICAgICAgICAgIGZpbGUucHJldmlld1RlbXBsYXRlID0gZmlsZS5wcmV2aWV3RWxlbWVudDsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJldmlld3NDb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZS5wcmV2aWV3RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1uYW1lXVwiKSwgX2lzQXJyYXkzID0gdHJ1ZSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9yZWYzO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTMrK107XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcclxuICAgICAgICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfcmVmMztcclxuXHJcbiAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGZpbGUubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotc2l6ZV1cIiksIF9pc0FycmF5NCA9IHRydWUsIF9pNCA9IDAsIF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgPyBfaXRlcmF0b3I0IDogX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IF9pdGVyYXRvcjRbX2k0KytdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfaTQuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gX2k0LnZhbHVlO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB0aGlzLmZpbGVzaXplKGZpbGUuc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkUmVtb3ZlTGlua3MpIHtcclxuICAgICAgICAgICAgICBmaWxlLl9yZW1vdmVMaW5rID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxhIGNsYXNzPVxcXCJkei1yZW1vdmVcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dW5kZWZpbmVkO1xcXCIgZGF0YS1kei1yZW1vdmU+XCIgKyB0aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGUgKyBcIjwvYT5cIik7XHJcbiAgICAgICAgICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudC5hcHBlbmRDaGlsZChmaWxlLl9yZW1vdmVMaW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUZpbGVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUZpbGVFdmVudChlKSB7XHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5VUExPQURJTkcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEcm9wem9uZS5jb25maXJtKF90aGlzMi5vcHRpb25zLmRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW1vdmVGaWxlKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gRHJvcHpvbmUuY29uZmlybShfdGhpczIub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVtb3ZlRmlsZShmaWxlKTtcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbW92ZUZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXJlbW92ZV1cIiksIF9pc0FycmF5NSA9IHRydWUsIF9pNSA9IDAsIF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgPyBfaXRlcmF0b3I1IDogX2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgICAgIHZhciBfcmVmNDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9pNSA+PSBfaXRlcmF0b3I1Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjVbX2k1KytdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfaTUgPSBfaXRlcmF0b3I1Lm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBfcmVmNCA9IF9pNS52YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciByZW1vdmVMaW5rID0gX3JlZjQ7XHJcblxyXG4gICAgICAgICAgICAgIHJlbW92ZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHJlbW92ZUZpbGVFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIGEgZmlsZSBpcyByZW1vdmVkLlxyXG4gICAgICAgIHJlbW92ZWRmaWxlOiBmdW5jdGlvbiByZW1vdmVkZmlsZShmaWxlKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCAhPSBudWxsICYmIGZpbGUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmaWxlLnByZXZpZXdFbGVtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNYXhGaWxlc1JlYWNoZWRDbGFzcygpO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIHRodW1ibmFpbCBoYXMgYmVlbiBnZW5lcmF0ZWRcclxuICAgICAgICAvLyBSZWNlaXZlcyBgZmlsZWAgYW5kIGBkYXRhVXJsYFxyXG4gICAgICAgIHRodW1ibmFpbDogZnVuY3Rpb24gdGh1bWJuYWlsKGZpbGUsIGRhdGFVcmwpIHtcclxuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWZpbGUtcHJldmlld1wiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXRodW1ibmFpbF1cIiksIF9pc0FycmF5NiA9IHRydWUsIF9pNiA9IDAsIF9pdGVyYXRvcjYgPSBfaXNBcnJheTYgPyBfaXRlcmF0b3I2IDogX2l0ZXJhdG9yNltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgICAgIHZhciBfcmVmNTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Nikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9pNiA+PSBfaXRlcmF0b3I2Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjZbX2k2KytdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfaTYgPSBfaXRlcmF0b3I2Lm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfaTYuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBfcmVmNSA9IF9pNi52YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciB0aHVtYm5haWxFbGVtZW50ID0gX3JlZjU7XHJcblxyXG4gICAgICAgICAgICAgIHRodW1ibmFpbEVsZW1lbnQuYWx0ID0gZmlsZS5uYW1lO1xyXG4gICAgICAgICAgICAgIHRodW1ibmFpbEVsZW1lbnQuc3JjID0gZGF0YVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1pbWFnZS1wcmV2aWV3XCIpO1xyXG4gICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIGFuIGVycm9yIG9jY3Vyc1xyXG4gICAgICAgIC8vIFJlY2VpdmVzIGBmaWxlYCBhbmQgYG1lc3NhZ2VgXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGZpbGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWVycm9yXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwiU3RyaW5nXCIgJiYgbWVzc2FnZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1lcnJvcm1lc3NhZ2VdXCIpLCBfaXNBcnJheTcgPSB0cnVlLCBfaTcgPSAwLCBfaXRlcmF0b3I3ID0gX2lzQXJyYXk3ID8gX2l0ZXJhdG9yNyA6IF9pdGVyYXRvcjdbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgICAgICB2YXIgX3JlZjY7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfaTcgPj0gX2l0ZXJhdG9yNy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjYgPSBfaXRlcmF0b3I3W19pNysrXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2k3ID0gX2l0ZXJhdG9yNy5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2k3LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjYgPSBfaTcudmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9yZWY2O1xyXG5cclxuICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3JtdWx0aXBsZTogZnVuY3Rpb24gZXJyb3JtdWx0aXBsZSgpIHt9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gYSBmaWxlIGdldHMgcHJvY2Vzc2VkLiBTaW5jZSB0aGVyZSBpcyBhIGN1ZSwgbm90IGFsbCBhZGRlZFxyXG4gICAgICAgIC8vIGZpbGVzIGFyZSBwcm9jZXNzZWQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLy8gUmVjZWl2ZXMgYGZpbGVgXHJcbiAgICAgICAgcHJvY2Vzc2luZzogZnVuY3Rpb24gcHJvY2Vzc2luZyhmaWxlKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xyXG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1wcm9jZXNzaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAoZmlsZS5fcmVtb3ZlTGluaykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmaWxlLl9yZW1vdmVMaW5rLnRleHRDb250ZW50ID0gdGhpcy5vcHRpb25zLmRpY3RDYW5jZWxVcGxvYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb2Nlc3NpbmdtdWx0aXBsZTogZnVuY3Rpb24gcHJvY2Vzc2luZ211bHRpcGxlKCkge30sXHJcblxyXG5cclxuICAgICAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHVwbG9hZCBwcm9ncmVzcyBnZXRzIHVwZGF0ZWQuXHJcbiAgICAgICAgLy8gUmVjZWl2ZXMgYGZpbGVgLCBgcHJvZ3Jlc3NgIChwZXJjZW50YWdlIDAtMTAwKSBhbmQgYGJ5dGVzU2VudGAuXHJcbiAgICAgICAgLy8gVG8gZ2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGZpbGUsIHVzZSBgZmlsZS5zaXplYFxyXG4gICAgICAgIHVwbG9hZHByb2dyZXNzOiBmdW5jdGlvbiB1cGxvYWRwcm9ncmVzcyhmaWxlLCBwcm9ncmVzcywgYnl0ZXNTZW50KSB7XHJcbiAgICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotdXBsb2FkcHJvZ3Jlc3NdXCIpLCBfaXNBcnJheTggPSB0cnVlLCBfaTggPSAwLCBfaXRlcmF0b3I4ID0gX2lzQXJyYXk4ID8gX2l0ZXJhdG9yOCA6IF9pdGVyYXRvcjhbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgICAgICB2YXIgX3JlZjc7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfaTggPj0gX2l0ZXJhdG9yOC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3I4W19pOCsrXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2k4ID0gX2l0ZXJhdG9yOC5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2k4LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjcgPSBfaTgudmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9yZWY3O1xyXG5cclxuICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lID09PSAnUFJPR1JFU1MnID8gbm9kZS52YWx1ZSA9IHByb2dyZXNzIDogbm9kZS5zdHlsZS53aWR0aCA9IHByb2dyZXNzICsgXCIlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSB0b3RhbCB1cGxvYWQgcHJvZ3Jlc3MgZ2V0cyB1cGRhdGVkLlxyXG4gICAgICAgIC8vIENhbGxlZCB3aXRoIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgKDAtMTAwKSwgdG90YWxCeXRlcyBhbmQgdG90YWxCeXRlc1NlbnRcclxuICAgICAgICB0b3RhbHVwbG9hZHByb2dyZXNzOiBmdW5jdGlvbiB0b3RhbHVwbG9hZHByb2dyZXNzKCkge30sXHJcblxyXG5cclxuICAgICAgICAvLyBDYWxsZWQganVzdCBiZWZvcmUgdGhlIGZpbGUgaXMgc2VudC4gR2V0cyB0aGUgYHhocmAgb2JqZWN0IGFzIHNlY29uZFxyXG4gICAgICAgIC8vIHBhcmFtZXRlciwgc28geW91IGNhbiBtb2RpZnkgaXQgKGZvciBleGFtcGxlIHRvIGFkZCBhIENTUkYgdG9rZW4pIGFuZCBhXHJcbiAgICAgICAgLy8gYGZvcm1EYXRhYCBvYmplY3QgdG8gYWRkIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgc2VuZGluZzogZnVuY3Rpb24gc2VuZGluZygpIHt9LFxyXG4gICAgICAgIHNlbmRpbmdtdWx0aXBsZTogZnVuY3Rpb24gc2VuZGluZ211bHRpcGxlKCkge30sXHJcblxyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBjb21wbGV0ZSB1cGxvYWQgaXMgZmluaXNoZWQgYW5kIHN1Y2Nlc3NmdWxcclxuICAgICAgICAvLyBSZWNlaXZlcyBgZmlsZWBcclxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcclxuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1zdWNjZXNzXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3VjY2Vzc211bHRpcGxlOiBmdW5jdGlvbiBzdWNjZXNzbXVsdGlwbGUoKSB7fSxcclxuXHJcblxyXG4gICAgICAgIC8vIFdoZW4gdGhlIHVwbG9hZCBpcyBjYW5jZWxlZC5cclxuICAgICAgICBjYW5jZWxlZDogZnVuY3Rpb24gY2FuY2VsZWQoZmlsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsIGZpbGUsIHRoaXMub3B0aW9ucy5kaWN0VXBsb2FkQ2FuY2VsZWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FuY2VsZWRtdWx0aXBsZTogZnVuY3Rpb24gY2FuY2VsZWRtdWx0aXBsZSgpIHt9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgdXBsb2FkIGlzIGZpbmlzaGVkLCBlaXRoZXIgd2l0aCBzdWNjZXNzIG9yIGFuIGVycm9yLlxyXG4gICAgICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxyXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShmaWxlKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZS5fcmVtb3ZlTGluaykge1xyXG4gICAgICAgICAgICBmaWxlLl9yZW1vdmVMaW5rLnRleHRDb250ZW50ID0gdGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWNvbXBsZXRlXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGxldGVtdWx0aXBsZTogZnVuY3Rpb24gY29tcGxldGVtdWx0aXBsZSgpIHt9LFxyXG4gICAgICAgIG1heGZpbGVzZXhjZWVkZWQ6IGZ1bmN0aW9uIG1heGZpbGVzZXhjZWVkZWQoKSB7fSxcclxuICAgICAgICBtYXhmaWxlc3JlYWNoZWQ6IGZ1bmN0aW9uIG1heGZpbGVzcmVhY2hlZCgpIHt9LFxyXG4gICAgICAgIHF1ZXVlY29tcGxldGU6IGZ1bmN0aW9uIHF1ZXVlY29tcGxldGUoKSB7fSxcclxuICAgICAgICBhZGRlZGZpbGVzOiBmdW5jdGlvbiBhZGRlZGZpbGVzKCkge31cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMucHJvdG90eXBlLl90aHVtYm5haWxRdWV1ZSA9IFtdO1xyXG4gICAgICB0aGlzLnByb3RvdHlwZS5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdsb2JhbCB1dGlsaXR5XHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJleHRlbmRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgb2JqZWN0cyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgICBvYmplY3RzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gb2JqZWN0cywgX2lzQXJyYXk5ID0gdHJ1ZSwgX2k5ID0gMCwgX2l0ZXJhdG9yOSA9IF9pc0FycmF5OSA/IF9pdGVyYXRvcjkgOiBfaXRlcmF0b3I5W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgdmFyIF9yZWY4O1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXk5KSB7XHJcbiAgICAgICAgICBpZiAoX2k5ID49IF9pdGVyYXRvcjkubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yOVtfaTkrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pOSA9IF9pdGVyYXRvcjkubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pOS5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWY4ID0gX2k5LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IF9yZWY4O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIGZ1bmN0aW9uIERyb3B6b25lKGVsLCBvcHRpb25zKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcHpvbmUpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcm9wem9uZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3B6b25lKSkuY2FsbCh0aGlzKSk7XHJcblxyXG4gICAgdmFyIGZhbGxiYWNrID0gdm9pZCAwLFxyXG4gICAgICAgIGxlZnQgPSB2b2lkIDA7XHJcbiAgICBfdGhpcy5lbGVtZW50ID0gZWw7XHJcbiAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgc2luY2UgdGhlIHZlcnNpb24gd2FzIGluIHRoZSBwcm90b3R5cGUgcHJldmlvdXNseVxyXG4gICAgX3RoaXMudmVyc2lvbiA9IERyb3B6b25lLnZlcnNpb247XHJcblxyXG4gICAgX3RoaXMuZGVmYXVsdE9wdGlvbnMucHJldmlld1RlbXBsYXRlID0gX3RoaXMuZGVmYXVsdE9wdGlvbnMucHJldmlld1RlbXBsYXRlLnJlcGxhY2UoL1xcbiovZywgXCJcIik7XHJcblxyXG4gICAgX3RoaXMuY2xpY2thYmxlRWxlbWVudHMgPSBbXTtcclxuICAgIF90aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgX3RoaXMuZmlsZXMgPSBbXTsgLy8gQWxsIGZpbGVzXHJcblxyXG4gICAgaWYgKHR5cGVvZiBfdGhpcy5lbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIF90aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLmVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdCBjaGVja2luZyBpZiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudCBvciBFbGVtZW50IHNpbmNlIElFOSBpcyBleHRyZW1lbHkgd2VpcmQuXHJcbiAgICBpZiAoIV90aGlzLmVsZW1lbnQgfHwgX3RoaXMuZWxlbWVudC5ub2RlVHlwZSA9PSBudWxsKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZHJvcHpvbmUgZWxlbWVudC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF90aGlzLmVsZW1lbnQuZHJvcHpvbmUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHJvcHpvbmUgYWxyZWFkeSBhdHRhY2hlZC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm93IGFkZCB0aGlzIGRyb3B6b25lIHRvIHRoZSBpbnN0YW5jZXMuXHJcbiAgICBEcm9wem9uZS5pbnN0YW5jZXMucHVzaChfdGhpcyk7XHJcblxyXG4gICAgLy8gUHV0IHRoZSBkcm9wem9uZSBpbnNpZGUgdGhlIGVsZW1lbnQgaXRzZWxmLlxyXG4gICAgX3RoaXMuZWxlbWVudC5kcm9wem9uZSA9IF90aGlzO1xyXG5cclxuICAgIHZhciBlbGVtZW50T3B0aW9ucyA9IChsZWZ0ID0gRHJvcHpvbmUub3B0aW9uc0ZvckVsZW1lbnQoX3RoaXMuZWxlbWVudCkpICE9IG51bGwgPyBsZWZ0IDoge307XHJcblxyXG4gICAgX3RoaXMub3B0aW9ucyA9IERyb3B6b25lLmV4dGVuZCh7fSwgX3RoaXMuZGVmYXVsdE9wdGlvbnMsIGVsZW1lbnRPcHRpb25zLCBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge30pO1xyXG5cclxuICAgIC8vIElmIHRoZSBicm93c2VyIGZhaWxlZCwganVzdCBjYWxsIHRoZSBmYWxsYmFjayBhbmQgbGVhdmVcclxuICAgIGlmIChfdGhpcy5vcHRpb25zLmZvcmNlRmFsbGJhY2sgfHwgIURyb3B6b25lLmlzQnJvd3NlclN1cHBvcnRlZCgpKSB7XHJcbiAgICAgIHZhciBfcmV0O1xyXG5cclxuICAgICAgcmV0dXJuIF9yZXQgPSBfdGhpcy5vcHRpb25zLmZhbGxiYWNrLmNhbGwoX3RoaXMpLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG9wdGlvbnMudXJsID0gQGVsZW1lbnQuZ2V0QXR0cmlidXRlIFwiYWN0aW9uXCIgdW5sZXNzIEBvcHRpb25zLnVybD9cclxuICAgIGlmIChfdGhpcy5vcHRpb25zLnVybCA9PSBudWxsKSB7XHJcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gX3RoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFfdGhpcy5vcHRpb25zLnVybCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBVUkwgcHJvdmlkZWQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMgJiYgX3RoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgcHJvdmlkZSBib3RoICdhY2NlcHRlZEZpbGVzJyBhbmQgJ2FjY2VwdGVkTWltZVR5cGVzJy4gJ2FjY2VwdGVkTWltZVR5cGVzJyBpcyBkZXByZWNhdGVkLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX3RoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSAmJiBfdGhpcy5vcHRpb25zLmNodW5raW5nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBzZXQgYm90aDogdXBsb2FkTXVsdGlwbGUgYW5kIGNodW5raW5nLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICBpZiAoX3RoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcykge1xyXG4gICAgICBfdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMgPSBfdGhpcy5vcHRpb25zLmFjY2VwdGVkTWltZVR5cGVzO1xyXG4gICAgICBkZWxldGUgX3RoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgaWYgKF90aGlzLm9wdGlvbnMucmVuYW1lRmlsZW5hbWUgIT0gbnVsbCkge1xyXG4gICAgICBfdGhpcy5vcHRpb25zLnJlbmFtZUZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lLmNhbGwoX3RoaXMsIGZpbGUubmFtZSwgZmlsZSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXMub3B0aW9ucy5tZXRob2QgPSBfdGhpcy5vcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIGlmICgoZmFsbGJhY2sgPSBfdGhpcy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpICYmIGZhbGxiYWNrLnBhcmVudE5vZGUpIHtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSBmYWxsYmFja1xyXG4gICAgICBmYWxsYmFjay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwbGF5IHByZXZpZXdzIGluIHRoZSBwcmV2aWV3c0NvbnRhaW5lciBlbGVtZW50IG9yIHRoZSBEcm9wem9uZSBlbGVtZW50IHVubGVzcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZVxyXG4gICAgaWYgKF90aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIgIT09IGZhbHNlKSB7XHJcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLnByZXZpZXdzQ29udGFpbmVyKSB7XHJcbiAgICAgICAgX3RoaXMucHJldmlld3NDb250YWluZXIgPSBEcm9wem9uZS5nZXRFbGVtZW50KF90aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIsIFwicHJldmlld3NDb250YWluZXJcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3RoaXMucHJldmlld3NDb250YWluZXIgPSBfdGhpcy5lbGVtZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF90aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsaWNrYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIF90aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gW190aGlzLmVsZW1lbnRdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF90aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gRHJvcHpvbmUuZ2V0RWxlbWVudHMoX3RoaXMub3B0aW9ucy5jbGlja2FibGUsIFwiY2xpY2thYmxlXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXMuaW5pdCgpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyBhbGwgZmlsZXMgdGhhdCBoYXZlIGJlZW4gYWNjZXB0ZWRcclxuXHJcblxyXG4gIF9jcmVhdGVDbGFzcyhEcm9wem9uZSwgW3tcclxuICAgIGtleTogXCJnZXRBY2NlcHRlZEZpbGVzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWNjZXB0ZWRGaWxlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGUuYWNjZXB0ZWQ7XHJcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmaWxlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGhhdmUgYmVlbiByZWplY3RlZFxyXG4gICAgLy8gTm90IHN1cmUgd2hlbiB0aGF0J3MgZ29pbmcgdG8gYmUgdXNlZnVsLCBidXQgYWRkZWQgZm9yIGNvbXBsZXRlbmVzcy5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldFJlamVjdGVkRmlsZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWplY3RlZEZpbGVzKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICByZXR1cm4gIWZpbGUuYWNjZXB0ZWQ7XHJcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBmaWxlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0RmlsZXNXaXRoU3RhdHVzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZXNXaXRoU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICByZXR1cm4gZmlsZS5zdGF0dXMgPT09IHN0YXR1cztcclxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgYWxsIGZpbGVzIHRoYXQgYXJlIGluIHRoZSBxdWV1ZVxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0UXVldWVkRmlsZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRRdWV1ZWRGaWxlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLlFVRVVFRCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldFVwbG9hZGluZ0ZpbGVzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXBsb2FkaW5nRmlsZXMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzV2l0aFN0YXR1cyhEcm9wem9uZS5VUExPQURJTkcpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRBZGRlZEZpbGVzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWRkZWRGaWxlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLkFEREVEKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWxlcyB0aGF0IGFyZSBlaXRoZXIgcXVldWVkIG9yIHVwbG9hZGluZ1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0QWN0aXZlRmlsZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmVGaWxlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5VUExPQURJTkcgfHwgZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLlFVRVVFRDtcclxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gRHJvcHpvbmUgaXMgaW5pdGlhbGl6ZWQuIFlvdVxyXG4gICAgLy8gY2FuIChhbmQgc2hvdWxkKSBzZXR1cCBldmVudCBsaXN0ZW5lcnMgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJpbml0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBJbiBjYXNlIGl0IGlzbid0IHNldCBhbHJlYWR5XHJcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQudGFnTmFtZSA9PT0gXCJmb3JtXCIpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZHJvcHpvbmVcIikgJiYgIXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmR6LW1lc3NhZ2VcIikpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxkaXYgY2xhc3M9XFxcImR6LWRlZmF1bHQgZHotbWVzc2FnZVxcXCI+PHNwYW4+XCIgKyB0aGlzLm9wdGlvbnMuZGljdERlZmF1bHRNZXNzYWdlICsgXCI8L3NwYW4+PC9kaXY+XCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuY2xpY2thYmxlRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHNldHVwSGlkZGVuRmlsZUlucHV0ID0gZnVuY3Rpb24gc2V0dXBIaWRkZW5GaWxlSW5wdXQoKSB7XHJcbiAgICAgICAgICBpZiAoX3RoaXMzLmhpZGRlbkZpbGVJbnB1dCkge1xyXG4gICAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXMzLmhpZGRlbkZpbGVJbnB1dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZmlsZVwiKTtcclxuICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5tYXhGaWxlcyA9PT0gbnVsbCB8fCBfdGhpczMub3B0aW9ucy5tYXhGaWxlcyA+IDEpIHtcclxuICAgICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5jbGFzc05hbWUgPSBcImR6LWhpZGRlbi1pbnB1dFwiO1xyXG5cclxuICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5hY2NlcHRlZEZpbGVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwiYWNjZXB0XCIsIF90aGlzMy5vcHRpb25zLmFjY2VwdGVkRmlsZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLmNhcHR1cmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJjYXB0dXJlXCIsIF90aGlzMy5vcHRpb25zLmNhcHR1cmUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5vdCBzZXR0aW5nIGBkaXNwbGF5PVwibm9uZVwiYCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjZXB0IGNsaWNrc1xyXG4gICAgICAgICAgLy8gb24gZWxlbWVudHMgdGhhdCBhcmVuJ3QgZGlzcGxheWVkLlxyXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5sZWZ0ID0gXCIwXCI7XHJcbiAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLmhlaWdodCA9IFwiMFwiO1xyXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS53aWR0aCA9IFwiMFwiO1xyXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpczMub3B0aW9ucy5oaWRkZW5JbnB1dENvbnRhaW5lcikuYXBwZW5kQ2hpbGQoX3RoaXMzLmhpZGRlbkZpbGVJbnB1dCk7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGZpbGVzID0gX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5maWxlcztcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IGZpbGVzLCBfaXNBcnJheTEwID0gdHJ1ZSwgX2kxMCA9IDAsIF9pdGVyYXRvcjEwID0gX2lzQXJyYXkxMCA/IF9pdGVyYXRvcjEwIDogX2l0ZXJhdG9yMTBbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkxMCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoX2kxMCA+PSBfaXRlcmF0b3IxMC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjEwW19pMTArK107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBfaTEwID0gX2l0ZXJhdG9yMTAubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoX2kxMC5kb25lKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgX3JlZjkgPSBfaTEwLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gX3JlZjk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMzLmFkZEZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzMy5lbWl0KFwiYWRkZWRmaWxlc1wiLCBmaWxlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXR1cEhpZGRlbkZpbGVJbnB1dCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZXR1cEhpZGRlbkZpbGVJbnB1dCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLlVSTCA9IHdpbmRvdy5VUkwgIT09IG51bGwgPyB3aW5kb3cuVVJMIDogd2luZG93LndlYmtpdFVSTDtcclxuXHJcbiAgICAgIC8vIFNldHVwIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIERyb3B6b25lIG9iamVjdCBpdHNlbGYuXHJcbiAgICAgIC8vIFRoZXkncmUgbm90IGluIEBzZXR1cEV2ZW50TGlzdGVuZXJzKCkgYmVjYXVzZSB0aGV5IHNob3VsZG4ndCBiZSByZW1vdmVkXHJcbiAgICAgIC8vIGFnYWluIHdoZW4gdGhlIGRyb3B6b25lIGdldHMgZGlzYWJsZWQuXHJcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjExID0gdGhpcy5ldmVudHMsIF9pc0FycmF5MTEgPSB0cnVlLCBfaTExID0gMCwgX2l0ZXJhdG9yMTEgPSBfaXNBcnJheTExID8gX2l0ZXJhdG9yMTEgOiBfaXRlcmF0b3IxMVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgIHZhciBfcmVmMTA7XHJcblxyXG4gICAgICAgIGlmIChfaXNBcnJheTExKSB7XHJcbiAgICAgICAgICBpZiAoX2kxMSA+PSBfaXRlcmF0b3IxMS5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgX3JlZjEwID0gX2l0ZXJhdG9yMTFbX2kxMSsrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX2kxMSA9IF9pdGVyYXRvcjExLm5leHQoKTtcclxuICAgICAgICAgIGlmIChfaTExLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgX3JlZjEwID0gX2kxMS52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBldmVudE5hbWUgPSBfcmVmMTA7XHJcblxyXG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub24oXCJ1cGxvYWRwcm9ncmVzc1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMy51cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5vbihcInJlbW92ZWRmaWxlXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMzLnVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLm9uKFwiY2FuY2VsZWRcIiwgZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBFbWl0IGEgYHF1ZXVlY29tcGxldGVgIGV2ZW50IGlmIGFsbCBmaWxlcyBmaW5pc2hlZCB1cGxvYWRpbmcuXHJcbiAgICAgIHRoaXMub24oXCJjb21wbGV0ZVwiLCBmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgIGlmIChfdGhpczMuZ2V0QWRkZWRGaWxlcygpLmxlbmd0aCA9PT0gMCAmJiBfdGhpczMuZ2V0VXBsb2FkaW5nRmlsZXMoKS5sZW5ndGggPT09IDAgJiYgX3RoaXMzLmdldFF1ZXVlZEZpbGVzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlZmVycmVkIHNvIHRoYXQgYHF1ZXVlY29tcGxldGVgIHJlYWxseSB0cmlnZ2VycyBhZnRlciBgY29tcGxldGVgXHJcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcInF1ZXVlY29tcGxldGVcIik7XHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIG5vUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBub1Byb3BhZ2F0aW9uKGUpIHtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgbGlzdGVuZXJzXHJcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gW3tcclxuICAgICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXHJcbiAgICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgICBcImRyYWdzdGFydFwiOiBmdW5jdGlvbiBkcmFnc3RhcnQoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnc3RhcnRcIiwgZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJkcmFnZW50ZXJcIjogZnVuY3Rpb24gZHJhZ2VudGVyKGUpIHtcclxuICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5lbWl0KFwiZHJhZ2VudGVyXCIsIGUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwiZHJhZ292ZXJcIjogZnVuY3Rpb24gZHJhZ292ZXIoZSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlcyBpdCBwb3NzaWJsZSB0byBkcmFnIGZpbGVzIGZyb20gY2hyb21lJ3MgZG93bmxvYWQgYmFyXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk1MjY0MzAvZHJhZy1hbmQtZHJvcC1maWxlLXVwbG9hZHMtZnJvbS1jaHJvbWUtZG93bmxvYWRzLWJhclxyXG4gICAgICAgICAgICAvLyBUcnkgaXMgcmVxdWlyZWQgdG8gcHJldmVudCBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgKFNDUklQVDY1NTM1IGV4Y2VwdGlvbilcclxuICAgICAgICAgICAgdmFyIGVmY3QgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgZWZjdCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxyXG4gICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnID09PSBlZmN0IHx8ICdsaW5rTW92ZScgPT09IGVmY3QgPyAnbW92ZScgOiAnY29weSc7XHJcblxyXG4gICAgICAgICAgICBub1Byb3BhZ2F0aW9uKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnb3ZlclwiLCBlKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBcImRyYWdsZWF2ZVwiOiBmdW5jdGlvbiBkcmFnbGVhdmUoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnbGVhdmVcIiwgZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJkcm9wXCI6IGZ1bmN0aW9uIGRyb3AoZSkge1xyXG4gICAgICAgICAgICBub1Byb3BhZ2F0aW9uKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmRyb3AoZSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJkcmFnZW5kXCI6IGZ1bmN0aW9uIGRyYWdlbmQoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnZW5kXCIsIGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFRoaXMgaXMgZGlzYWJsZWQgcmlnaHQgbm93LCBiZWNhdXNlIHRoZSBicm93c2VycyBkb24ndCBpbXBsZW1lbnQgaXQgcHJvcGVybHkuXHJcbiAgICAgICAgICAvLyBcInBhc3RlXCI6IChlKSA9PlxyXG4gICAgICAgICAgLy8gICBub1Byb3BhZ2F0aW9uIGVcclxuICAgICAgICAgIC8vICAgQHBhc3RlIGVcclxuICAgICAgICB9IH1dO1xyXG5cclxuICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbGlja2FibGVFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMy5saXN0ZW5lcnMucHVzaCh7XHJcbiAgICAgICAgICBlbGVtZW50OiBjbGlja2FibGVFbGVtZW50LFxyXG4gICAgICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24gY2xpY2soZXZ0KSB7XHJcbiAgICAgICAgICAgICAgLy8gT25seSB0aGUgYWN0dWFsIGRyb3B6b25lIG9yIHRoZSBtZXNzYWdlIGVsZW1lbnQgc2hvdWxkIHRyaWdnZXIgZmlsZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICBpZiAoY2xpY2thYmxlRWxlbWVudCAhPT0gX3RoaXMzLmVsZW1lbnQgfHwgZXZ0LnRhcmdldCA9PT0gX3RoaXMzLmVsZW1lbnQgfHwgRHJvcHpvbmUuZWxlbWVudEluc2lkZShldnQudGFyZ2V0LCBfdGhpczMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmR6LW1lc3NhZ2VcIikpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LmNsaWNrKCk7IC8vIEZvcndhcmQgdGhlIGNsaWNrXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5lbmFibGUoKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdCBmdWxseSB0ZXN0ZWQgeWV0XHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJkZXN0cm95XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgdGhpcy5kaXNhYmxlKCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlQWxsRmlsZXModHJ1ZSk7XHJcbiAgICAgIGlmICh0aGlzLmhpZGRlbkZpbGVJbnB1dCAhPSBudWxsID8gdGhpcy5oaWRkZW5GaWxlSW5wdXQucGFyZW50Tm9kZSA6IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgdGhpcy5lbGVtZW50LmRyb3B6b25lO1xyXG4gICAgICByZXR1cm4gRHJvcHpvbmUuaW5zdGFuY2VzLnNwbGljZShEcm9wem9uZS5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3NcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzKCkge1xyXG4gICAgICB2YXIgdG90YWxVcGxvYWRQcm9ncmVzcyA9IHZvaWQgMDtcclxuICAgICAgdmFyIHRvdGFsQnl0ZXNTZW50ID0gMDtcclxuICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xyXG5cclxuICAgICAgdmFyIGFjdGl2ZUZpbGVzID0gdGhpcy5nZXRBY3RpdmVGaWxlcygpO1xyXG5cclxuICAgICAgaWYgKGFjdGl2ZUZpbGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEyID0gdGhpcy5nZXRBY3RpdmVGaWxlcygpLCBfaXNBcnJheTEyID0gdHJ1ZSwgX2kxMiA9IDAsIF9pdGVyYXRvcjEyID0gX2lzQXJyYXkxMiA/IF9pdGVyYXRvcjEyIDogX2l0ZXJhdG9yMTJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgIHZhciBfcmVmMTE7XHJcblxyXG4gICAgICAgICAgaWYgKF9pc0FycmF5MTIpIHtcclxuICAgICAgICAgICAgaWYgKF9pMTIgPj0gX2l0ZXJhdG9yMTIubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZjExID0gX2l0ZXJhdG9yMTJbX2kxMisrXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9pMTIgPSBfaXRlcmF0b3IxMi5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChfaTEyLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMTEgPSBfaTEyLnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBmaWxlID0gX3JlZjExO1xyXG5cclxuICAgICAgICAgIHRvdGFsQnl0ZXNTZW50ICs9IGZpbGUudXBsb2FkLmJ5dGVzU2VudDtcclxuICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZmlsZS51cGxvYWQudG90YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgPSAxMDAgKiB0b3RhbEJ5dGVzU2VudCAvIHRvdGFsQnl0ZXM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG90YWxVcGxvYWRQcm9ncmVzcyA9IDEwMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChcInRvdGFsdXBsb2FkcHJvZ3Jlc3NcIiwgdG90YWxVcGxvYWRQcm9ncmVzcywgdG90YWxCeXRlcywgdG90YWxCeXRlc1NlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvcHRpb25zLnBhcmFtTmFtZSBjYW4gYmUgYSBmdW5jdGlvbiB0YWtpbmcgb25lIHBhcmFtZXRlciByYXRoZXIgdGhhbiBhIHN0cmluZy5cclxuICAgIC8vIEEgcGFyYW1ldGVyIG5hbWUgZm9yIGEgZmlsZSBpcyBvYnRhaW5lZCBzaW1wbHkgYnkgY2FsbGluZyB0aGlzIHdpdGggYW4gaW5kZXggbnVtYmVyLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2dldFBhcmFtTmFtZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQYXJhbU5hbWUobikge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbU5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGFyYW1OYW1lKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5vcHRpb25zLnBhcmFtTmFtZSArICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgPyBcIltcIiArIG4gKyBcIl1cIiA6IFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgQG9wdGlvbnMucmVuYW1lRmlsZSBpcyBhIGZ1bmN0aW9uLFxyXG4gICAgLy8gdGhlIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byByZW5hbWUgdGhlIGZpbGUubmFtZSBiZWZvcmUgYXBwZW5kaW5nIGl0IHRvIHRoZSBmb3JtRGF0YVxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX3JlbmFtZUZpbGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuYW1lRmlsZShmaWxlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlbmFtZUZpbGUgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmaWxlLm5hbWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlKGZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgYSBmb3JtIHRoYXQgY2FuIGJlIHVzZWQgYXMgZmFsbGJhY2sgaWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBEcmFnbkRyb3BcclxuICAgIC8vXHJcbiAgICAvLyBJZiB0aGUgZHJvcHpvbmUgaXMgYWxyZWFkeSBhIGZvcm0sIG9ubHkgdGhlIGlucHV0IGZpZWxkIGFuZCBidXR0b24gYXJlIHJldHVybmVkLiBPdGhlcndpc2UgYSBjb21wbGV0ZSBmb3JtIGVsZW1lbnQgaXMgcHJvdmlkZWQuXHJcbiAgICAvLyBUaGlzIGNvZGUgaGFzIHRvIHBhc3MgaW4gSUU3IDooXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJnZXRGYWxsYmFja0Zvcm1cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGYWxsYmFja0Zvcm0oKSB7XHJcbiAgICAgIHZhciBleGlzdGluZ0ZhbGxiYWNrID0gdm9pZCAwLFxyXG4gICAgICAgICAgZm9ybSA9IHZvaWQgMDtcclxuICAgICAgaWYgKGV4aXN0aW5nRmFsbGJhY2sgPSB0aGlzLmdldEV4aXN0aW5nRmFsbGJhY2soKSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0ZhbGxiYWNrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmllbGRzU3RyaW5nID0gXCI8ZGl2IGNsYXNzPVxcXCJkei1mYWxsYmFja1xcXCI+XCI7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrVGV4dCkge1xyXG4gICAgICAgIGZpZWxkc1N0cmluZyArPSBcIjxwPlwiICsgdGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQgKyBcIjwvcD5cIjtcclxuICAgICAgfVxyXG4gICAgICBmaWVsZHNTdHJpbmcgKz0gXCI8aW5wdXQgdHlwZT1cXFwiZmlsZVxcXCIgbmFtZT1cXFwiXCIgKyB0aGlzLl9nZXRQYXJhbU5hbWUoMCkgKyBcIlxcXCIgXCIgKyAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlID8gJ211bHRpcGxlPVwibXVsdGlwbGVcIicgOiB1bmRlZmluZWQpICsgXCIgLz48aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiVXBsb2FkIVxcXCI+PC9kaXY+XCI7XHJcblxyXG4gICAgICB2YXIgZmllbGRzID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChmaWVsZHNTdHJpbmcpO1xyXG4gICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgIT09IFwiRk9STVwiKSB7XHJcbiAgICAgICAgZm9ybSA9IERyb3B6b25lLmNyZWF0ZUVsZW1lbnQoXCI8Zm9ybSBhY3Rpb249XFxcIlwiICsgdGhpcy5vcHRpb25zLnVybCArIFwiXFxcIiBlbmN0eXBlPVxcXCJtdWx0aXBhcnQvZm9ybS1kYXRhXFxcIiBtZXRob2Q9XFxcIlwiICsgdGhpcy5vcHRpb25zLm1ldGhvZCArIFwiXFxcIj48L2Zvcm0+XCIpO1xyXG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoZmllbGRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZW5jdHlwZSBhbmQgbWV0aG9kIGF0dHJpYnV0ZXMgYXJlIHNldCBwcm9wZXJseVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIHRoaXMub3B0aW9ucy5tZXRob2QpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtICE9IG51bGwgPyBmb3JtIDogZmllbGRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgdGhlIGZhbGxiYWNrIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QgYWxyZWFkeVxyXG4gICAgLy9cclxuICAgIC8vIFRoaXMgY29kZSBoYXMgdG8gcGFzcyBpbiBJRTcgOihcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldEV4aXN0aW5nRmFsbGJhY2tcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFeGlzdGluZ0ZhbGxiYWNrKCkge1xyXG4gICAgICB2YXIgZ2V0RmFsbGJhY2sgPSBmdW5jdGlvbiBnZXRGYWxsYmFjayhlbGVtZW50cykge1xyXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEzID0gZWxlbWVudHMsIF9pc0FycmF5MTMgPSB0cnVlLCBfaTEzID0gMCwgX2l0ZXJhdG9yMTMgPSBfaXNBcnJheTEzID8gX2l0ZXJhdG9yMTMgOiBfaXRlcmF0b3IxM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWYxMjtcclxuXHJcbiAgICAgICAgICBpZiAoX2lzQXJyYXkxMykge1xyXG4gICAgICAgICAgICBpZiAoX2kxMyA+PSBfaXRlcmF0b3IxMy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMTIgPSBfaXRlcmF0b3IxM1tfaTEzKytdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2kxMyA9IF9pdGVyYXRvcjEzLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pMTMuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYxMiA9IF9pMTMudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGVsID0gX3JlZjEyO1xyXG5cclxuICAgICAgICAgIGlmICgvKF58IClmYWxsYmFjaygkfCApLy50ZXN0KGVsLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBfYXJyID0gW1wiZGl2XCIsIFwiZm9ybVwiXTtcclxuICAgICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBfYXJyLmxlbmd0aDsgX2kxNCsrKSB7XHJcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBfYXJyW19pMTRdO1xyXG4gICAgICAgIHZhciBmYWxsYmFjaztcclxuICAgICAgICBpZiAoZmFsbGJhY2sgPSBnZXRGYWxsYmFjayh0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0aXZhdGVzIGFsbCBsaXN0ZW5lcnMgc3RvcmVkIGluIEBsaXN0ZW5lcnNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcInNldHVwRXZlbnRMaXN0ZW5lcnNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMubWFwKGZ1bmN0aW9uIChlbGVtZW50TGlzdGVuZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudExpc3RlbmVycy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlYWN0aXZhdGVzIGFsbCBsaXN0ZW5lcnMgc3RvcmVkIGluIEBsaXN0ZW5lcnNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoZnVuY3Rpb24gKGVsZW1lbnRMaXN0ZW5lcnMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gZWxlbWVudExpc3RlbmVycy5ldmVudHMpIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZWxlbWVudExpc3RlbmVycy5ldmVudHNbZXZlbnRdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50TGlzdGVuZXJzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjYW5jZWxzIGFsbCBmaWxlcyBpbiB0aGUgcXVldWUgb3IgYmVpbmcgcHJvY2Vzc2VkLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWNsaWNrYWJsZVwiKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXM0LmNhbmNlbFVwbG9hZChmaWxlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImVuYWJsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgICAgZGVsZXRlIHRoaXMuZGlzYWJsZWQ7XHJcbiAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1jbGlja2FibGVcIik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJucyBhIG5pY2VseSBmb3JtYXR0ZWQgZmlsZXNpemVcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImZpbGVzaXplXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsZXNpemUoc2l6ZSkge1xyXG4gICAgICB2YXIgc2VsZWN0ZWRTaXplID0gMDtcclxuICAgICAgdmFyIHNlbGVjdGVkVW5pdCA9IFwiYlwiO1xyXG5cclxuICAgICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgdmFyIHVuaXRzID0gWyd0YicsICdnYicsICdtYicsICdrYicsICdiJ107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciB1bml0ID0gdW5pdHNbaV07XHJcbiAgICAgICAgICB2YXIgY3V0b2ZmID0gTWF0aC5wb3codGhpcy5vcHRpb25zLmZpbGVzaXplQmFzZSwgNCAtIGkpIC8gMTA7XHJcblxyXG4gICAgICAgICAgaWYgKHNpemUgPj0gY3V0b2ZmKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkU2l6ZSA9IHNpemUgLyBNYXRoLnBvdyh0aGlzLm9wdGlvbnMuZmlsZXNpemVCYXNlLCA0IC0gaSk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZWN0ZWRTaXplID0gTWF0aC5yb3VuZCgxMCAqIHNlbGVjdGVkU2l6ZSkgLyAxMDsgLy8gQ3V0dGluZyBvZiBkaWdpdHNcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFwiPHN0cm9uZz5cIiArIHNlbGVjdGVkU2l6ZSArIFwiPC9zdHJvbmc+IFwiICsgdGhpcy5vcHRpb25zLmRpY3RGaWxlU2l6ZVVuaXRzW3NlbGVjdGVkVW5pdF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkcyBvciByZW1vdmVzIHRoZSBgZHotbWF4LWZpbGVzLXJlYWNoZWRgIGNsYXNzIGZyb20gdGhlIGZvcm0uXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3NcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKSB7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgIT0gbnVsbCAmJiB0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aCA9PT0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoJ21heGZpbGVzcmVhY2hlZCcsIHRoaXMuZmlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1tYXgtZmlsZXMtcmVhY2hlZFwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1tYXgtZmlsZXMtcmVhY2hlZFwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJkcm9wXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJvcChlKSB7XHJcbiAgICAgIGlmICghZS5kYXRhVHJhbnNmZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbWl0KFwiZHJvcFwiLCBlKTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdGhlIEZpbGVMaXN0IHRvIGFuIEFycmF5XHJcbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBJRTExXHJcbiAgICAgIHZhciBmaWxlcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZmlsZXNbaV0gPSBlLmRhdGFUcmFuc2Zlci5maWxlc1tpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5lbWl0KFwiYWRkZWRmaWxlc1wiLCBmaWxlcyk7XHJcblxyXG4gICAgICAvLyBFdmVuIGlmIGl0J3MgYSBmb2xkZXIsIGZpbGVzLmxlbmd0aCB3aWxsIGNvbnRhaW4gdGhlIGZvbGRlcnMuXHJcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBlLmRhdGFUcmFuc2Zlci5pdGVtcztcclxuXHJcbiAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS53ZWJraXRHZXRBc0VudHJ5ICE9IG51bGwpIHtcclxuICAgICAgICAgIC8vIFRoZSBicm93c2VyIHN1cHBvcnRzIGRyb3BwaW5nIG9mIGZvbGRlcnMsIHNvIGhhbmRsZSBpdGVtcyBpbnN0ZWFkIG9mIGZpbGVzXHJcbiAgICAgICAgICB0aGlzLl9hZGRGaWxlc0Zyb21JdGVtcyhpdGVtcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuaGFuZGxlRmlsZXMoZmlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJwYXN0ZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhc3RlKGUpIHtcclxuICAgICAgaWYgKF9fZ3VhcmRfXyhlICE9IG51bGwgPyBlLmNsaXBib2FyZERhdGEgOiB1bmRlZmluZWQsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHguaXRlbXM7XHJcbiAgICAgIH0pID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZW1pdChcInBhc3RlXCIsIGUpO1xyXG4gICAgICB2YXIgaXRlbXMgPSBlLmNsaXBib2FyZERhdGEuaXRlbXM7XHJcblxyXG5cclxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRGaWxlc0Zyb21JdGVtcyhpdGVtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiaGFuZGxlRmlsZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGaWxlcyhmaWxlcykge1xyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNCA9IGZpbGVzLCBfaXNBcnJheTE0ID0gdHJ1ZSwgX2kxNSA9IDAsIF9pdGVyYXRvcjE0ID0gX2lzQXJyYXkxNCA/IF9pdGVyYXRvcjE0IDogX2l0ZXJhdG9yMTRbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjEzO1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkxNCkge1xyXG4gICAgICAgICAgaWYgKF9pMTUgPj0gX2l0ZXJhdG9yMTQubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxMyA9IF9pdGVyYXRvcjE0W19pMTUrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMTUgPSBfaXRlcmF0b3IxNC5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kxNS5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxMyA9IF9pMTUudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYxMztcclxuXHJcbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbiBhIGZvbGRlciBpcyBkcm9wcGVkIChvciBmaWxlcyBhcmUgcGFzdGVkKSwgaXRlbXMgbXVzdCBiZSBoYW5kbGVkXHJcbiAgICAvLyBpbnN0ZWFkIG9mIGZpbGVzLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2FkZEZpbGVzRnJvbUl0ZW1zXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKSB7XHJcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTUgPSBpdGVtcywgX2lzQXJyYXkxNSA9IHRydWUsIF9pMTYgPSAwLCBfaXRlcmF0b3IxNSA9IF9pc0FycmF5MTUgPyBfaXRlcmF0b3IxNSA6IF9pdGVyYXRvcjE1W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgICB2YXIgX3JlZjE0O1xyXG5cclxuICAgICAgICAgIGlmIChfaXNBcnJheTE1KSB7XHJcbiAgICAgICAgICAgIGlmIChfaTE2ID49IF9pdGVyYXRvcjE1Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYxNCA9IF9pdGVyYXRvcjE1W19pMTYrK107XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfaTE2ID0gX2l0ZXJhdG9yMTUubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoX2kxNi5kb25lKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZjE0ID0gX2kxNi52YWx1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgaXRlbSA9IF9yZWYxNDtcclxuXHJcbiAgICAgICAgICB2YXIgZW50cnk7XHJcbiAgICAgICAgICBpZiAoaXRlbS53ZWJraXRHZXRBc0VudHJ5ICE9IG51bGwgJiYgKGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCkpKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcclxuICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczUuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcclxuICAgICAgICAgICAgICAvLyBBcHBlbmQgYWxsIGZpbGVzIGZyb20gdGhhdCBkaXJlY3RvcnkgdG8gZmlsZXNcclxuICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczUuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgZW50cnkubmFtZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5nZXRBc0ZpbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5raW5kID09IG51bGwgfHwgaXRlbS5raW5kID09PSBcImZpbGVcIikge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF90aGlzNS5hZGRGaWxlKGl0ZW0uZ2V0QXNGaWxlKCkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR29lcyB0aHJvdWdoIHRoZSBkaXJlY3RvcnksIGFuZCBhZGRzIGVhY2ggZmlsZSBpdCBmaW5kcyByZWN1cnNpdmVseVxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2FkZEZpbGVzRnJvbURpcmVjdG9yeVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRGaWxlc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5LCBwYXRoKSB7XHJcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xyXG5cclxuICAgICAgdmFyIGRpclJlYWRlciA9IGRpcmVjdG9yeS5jcmVhdGVSZWFkZXIoKTtcclxuXHJcbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gX19ndWFyZE1ldGhvZF9fKGNvbnNvbGUsICdsb2cnLCBmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgcmV0dXJuIG8ubG9nKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uIHJlYWRFbnRyaWVzKCkge1xyXG4gICAgICAgIHJldHVybiBkaXJSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24gKGVudHJpZXMpIHtcclxuICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTYgPSBlbnRyaWVzLCBfaXNBcnJheTE2ID0gdHJ1ZSwgX2kxNyA9IDAsIF9pdGVyYXRvcjE2ID0gX2lzQXJyYXkxNiA/IF9pdGVyYXRvcjE2IDogX2l0ZXJhdG9yMTZbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgICAgICB2YXIgX3JlZjE1O1xyXG5cclxuICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkxNikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9pMTcgPj0gX2l0ZXJhdG9yMTYubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICAgIF9yZWYxNSA9IF9pdGVyYXRvcjE2W19pMTcrK107XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9pMTcgPSBfaXRlcmF0b3IxNi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2kxNy5kb25lKSBicmVhaztcclxuICAgICAgICAgICAgICAgIF9yZWYxNSA9IF9pMTcudmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfcmVmMTU7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLmlnbm9yZUhpZGRlbkZpbGVzICYmIGZpbGUubmFtZS5zdWJzdHJpbmcoMCwgMSkgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBmaWxlLmZ1bGxQYXRoID0gcGF0aCArIFwiL1wiICsgZmlsZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2LmFkZEZpbGUoZmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpczYuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgcGF0aCArIFwiL1wiICsgZW50cnkubmFtZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjYWxsIHJlYWRFbnRyaWVzKCkgYWdhaW4sIHNpbmNlIGJyb3dzZXIgb25seSBoYW5kbGVcclxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IDEwMCBlbnRyaWVzLlxyXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EaXJlY3RvcnlSZWFkZXIjcmVhZEVudHJpZXNcclxuICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gcmVhZEVudHJpZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBgZG9uZSgpYCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudCB0aGUgZmlsZSBpcyBhY2NlcHRlZFxyXG4gICAgLy8gSWYgeW91IGNhbGwgaXQgd2l0aCBhbiBlcnJvciBtZXNzYWdlLCB0aGUgZmlsZSBpcyByZWplY3RlZFxyXG4gICAgLy8gKFRoaXMgYWxsb3dzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdGlvbilcclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgZmlsZXNpemUsIGFuZCBpZiB0aGUgZmlsZS50eXBlIHBhc3NlcyB0aGVcclxuICAgIC8vIGBhY2NlcHRlZEZpbGVzYCBjaGVjay5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImFjY2VwdFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjY2VwdChmaWxlLCBkb25lKSB7XHJcbiAgICAgIGlmIChmaWxlLnNpemUgPiB0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUgKiAxMDI0ICogMTAyNCkge1xyXG4gICAgICAgIHJldHVybiBkb25lKHRoaXMub3B0aW9ucy5kaWN0RmlsZVRvb0JpZy5yZXBsYWNlKFwie3tmaWxlc2l6ZX19XCIsIE1hdGgucm91bmQoZmlsZS5zaXplIC8gMTAyNCAvIDEwLjI0KSAvIDEwMCkucmVwbGFjZShcInt7bWF4RmlsZXNpemV9fVwiLCB0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUpKTtcclxuICAgICAgfSBlbHNlIGlmICghRHJvcHpvbmUuaXNWYWxpZEZpbGUoZmlsZSwgdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUodGhpcy5vcHRpb25zLmRpY3RJbnZhbGlkRmlsZVR5cGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlcyAhPSBudWxsICYmIHRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4RmlsZXMpIHtcclxuICAgICAgICBkb25lKHRoaXMub3B0aW9ucy5kaWN0TWF4RmlsZXNFeGNlZWRlZC5yZXBsYWNlKFwie3ttYXhGaWxlc319XCIsIHRoaXMub3B0aW9ucy5tYXhGaWxlcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJtYXhmaWxlc2V4Y2VlZGVkXCIsIGZpbGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYWNjZXB0LmNhbGwodGhpcywgZmlsZSwgZG9uZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiYWRkRmlsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZpbGUoZmlsZSkge1xyXG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcclxuXHJcbiAgICAgIGZpbGUudXBsb2FkID0ge1xyXG4gICAgICAgIHV1aWQ6IERyb3B6b25lLnV1aWR2NCgpLFxyXG4gICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIHRvdGFsIHVwbG9hZCBzaXplIHRvIGZpbGUuc2l6ZSBmb3IgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgIC8vIEl0J3MgYWN0dWFsIGRpZmZlcmVudCB0aGFuIHRoZSBzaXplIHRvIGJlIHRyYW5zbWl0dGVkLlxyXG4gICAgICAgIHRvdGFsOiBmaWxlLnNpemUsXHJcbiAgICAgICAgYnl0ZXNTZW50OiAwLFxyXG4gICAgICAgIGZpbGVuYW1lOiB0aGlzLl9yZW5hbWVGaWxlKGZpbGUpLFxyXG4gICAgICAgIGNodW5rZWQ6IHRoaXMub3B0aW9ucy5jaHVua2luZyAmJiAodGhpcy5vcHRpb25zLmZvcmNlQ2h1bmtpbmcgfHwgZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSksXHJcbiAgICAgICAgdG90YWxDaHVua0NvdW50OiBNYXRoLmNlaWwoZmlsZS5zaXplIC8gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSlcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xyXG5cclxuICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5BRERFRDtcclxuXHJcbiAgICAgIHRoaXMuZW1pdChcImFkZGVkZmlsZVwiLCBmaWxlKTtcclxuXHJcbiAgICAgIHRoaXMuX2VucXVldWVUaHVtYm5haWwoZmlsZSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5hY2NlcHQoZmlsZSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBmaWxlLmFjY2VwdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICBfdGhpczcuX2Vycm9yUHJvY2Vzc2luZyhbZmlsZV0sIGVycm9yKTsgLy8gV2lsbCBzZXQgdGhlIGZpbGUuc3RhdHVzXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZpbGUuYWNjZXB0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKF90aGlzNy5vcHRpb25zLmF1dG9RdWV1ZSkge1xyXG4gICAgICAgICAgICBfdGhpczcuZW5xdWV1ZUZpbGUoZmlsZSk7XHJcbiAgICAgICAgICB9IC8vIFdpbGwgc2V0IC5hY2NlcHRlZCA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzNy5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JhcHBlciBmb3IgZW5xdWV1ZUZpbGVcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImVucXVldWVGaWxlc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWVGaWxlcyhmaWxlcykge1xyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNyA9IGZpbGVzLCBfaXNBcnJheTE3ID0gdHJ1ZSwgX2kxOCA9IDAsIF9pdGVyYXRvcjE3ID0gX2lzQXJyYXkxNyA/IF9pdGVyYXRvcjE3IDogX2l0ZXJhdG9yMTdbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjE2O1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkxNykge1xyXG4gICAgICAgICAgaWYgKF9pMTggPj0gX2l0ZXJhdG9yMTcubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxNiA9IF9pdGVyYXRvcjE3W19pMTgrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMTggPSBfaXRlcmF0b3IxNy5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kxOC5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxNiA9IF9pMTgudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYxNjtcclxuXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlRmlsZShmaWxlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZW5xdWV1ZUZpbGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnF1ZXVlRmlsZShmaWxlKSB7XHJcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5BRERFRCAmJiBmaWxlLmFjY2VwdGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5RVUVVRUQ7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpczgucHJvY2Vzc1F1ZXVlKCk7XHJcbiAgICAgICAgICB9LCAwKTsgLy8gRGVmZXJyaW5nIHRoZSBjYWxsXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBjYW4ndCBiZSBxdWV1ZWQgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBvciB3YXMgcmVqZWN0ZWQuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9lbnF1ZXVlVGh1bWJuYWlsXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VucXVldWVUaHVtYm5haWwoZmlsZSkge1xyXG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlSW1hZ2VUaHVtYm5haWxzICYmIGZpbGUudHlwZS5tYXRjaCgvaW1hZ2UuKi8pICYmIGZpbGUuc2l6ZSA8PSB0aGlzLm9wdGlvbnMubWF4VGh1bWJuYWlsRmlsZXNpemUgKiAxMDI0ICogMTAyNCkge1xyXG4gICAgICAgIHRoaXMuX3RodW1ibmFpbFF1ZXVlLnB1c2goZmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XHJcbiAgICAgICAgfSwgMCk7IC8vIERlZmVycmluZyB0aGUgY2FsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9wcm9jZXNzVGh1bWJuYWlsUXVldWVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCkge1xyXG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCB8fCB0aGlzLl90aHVtYm5haWxRdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3Byb2Nlc3NpbmdUaHVtYm5haWwgPSB0cnVlO1xyXG4gICAgICB2YXIgZmlsZSA9IHRoaXMuX3RodW1ibmFpbFF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChmaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy50aHVtYm5haWxNZXRob2QsIHRydWUsIGZ1bmN0aW9uIChkYXRhVXJsKSB7XHJcbiAgICAgICAgX3RoaXMxMC5lbWl0KFwidGh1bWJuYWlsXCIsIGZpbGUsIGRhdGFVcmwpO1xyXG4gICAgICAgIF90aGlzMTAuX3Byb2Nlc3NpbmdUaHVtYm5haWwgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXMxMC5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbiBiZSBjYWxsZWQgYnkgdGhlIHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVtb3ZlRmlsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZpbGUoZmlsZSkge1xyXG4gICAgICBpZiAoZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLlVQTE9BRElORykge1xyXG4gICAgICAgIHRoaXMuY2FuY2VsVXBsb2FkKGZpbGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZmlsZXMgPSB3aXRob3V0KHRoaXMuZmlsZXMsIGZpbGUpO1xyXG5cclxuICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlZGZpbGVcIiwgZmlsZSk7XHJcbiAgICAgIGlmICh0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJyZXNldFwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZXMgYWxsIGZpbGVzIHRoYXQgYXJlbid0IGN1cnJlbnRseSBwcm9jZXNzZWQgZnJvbSB0aGUgbGlzdFxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVtb3ZlQWxsRmlsZXNcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxGaWxlcyhjYW5jZWxJZk5lY2Vzc2FyeSkge1xyXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIGZpbGVzIHNpbmNlIHJlbW92ZUZpbGUoKSBjaGFuZ2VzIHRoZSBAZmlsZXMgYXJyYXkuXHJcbiAgICAgIGlmIChjYW5jZWxJZk5lY2Vzc2FyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgY2FuY2VsSWZOZWNlc3NhcnkgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxOCA9IHRoaXMuZmlsZXMuc2xpY2UoKSwgX2lzQXJyYXkxOCA9IHRydWUsIF9pMTkgPSAwLCBfaXRlcmF0b3IxOCA9IF9pc0FycmF5MTggPyBfaXRlcmF0b3IxOCA6IF9pdGVyYXRvcjE4W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgdmFyIF9yZWYxNztcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5MTgpIHtcclxuICAgICAgICAgIGlmIChfaTE5ID49IF9pdGVyYXRvcjE4Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMTcgPSBfaXRlcmF0b3IxOFtfaTE5KytdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfaTE5ID0gX2l0ZXJhdG9yMTgubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pMTkuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMTcgPSBfaTE5LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMTc7XHJcblxyXG4gICAgICAgIGlmIChmaWxlLnN0YXR1cyAhPT0gRHJvcHpvbmUuVVBMT0FESU5HIHx8IGNhbmNlbElmTmVjZXNzYXJ5KSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUZpbGUoZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2l6ZXMgYW4gaW1hZ2UgYmVmb3JlIGl0IGdldHMgc2VudCB0byB0aGUgc2VydmVyLiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcbiAgICAvLyBgb3B0aW9ucy50cmFuc2Zvcm1GaWxlYCBpZiBgcmVzaXplV2lkdGhgIG9yIGByZXNpemVIZWlnaHRgIGFyZSBzZXQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGhcclxuICAgIC8vIHRoZSByZXNpemVkIGJsb2IuXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZXNpemVJbWFnZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUltYWdlKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgY2FsbGJhY2spIHtcclxuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZmFsc2UsIGZ1bmN0aW9uIChkYXRhVXJsLCBjYW52YXMpIHtcclxuICAgICAgICBpZiAoY2FudmFzID09IG51bGwpIHtcclxuICAgICAgICAgIC8vIFRoZSBpbWFnZSBoYXMgbm90IGJlZW4gcmVzaXplZFxyXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgcmVzaXplTWltZVR5cGUgPSBfdGhpczExLm9wdGlvbnMucmVzaXplTWltZVR5cGU7XHJcblxyXG4gICAgICAgICAgaWYgKHJlc2l6ZU1pbWVUeXBlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzaXplTWltZVR5cGUgPSBmaWxlLnR5cGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgcmVzaXplZERhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHJlc2l6ZU1pbWVUeXBlLCBfdGhpczExLm9wdGlvbnMucmVzaXplUXVhbGl0eSk7XHJcbiAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT09ICdpbWFnZS9qcGVnJyB8fCByZXNpemVNaW1lVHlwZSA9PT0gJ2ltYWdlL2pwZycpIHtcclxuICAgICAgICAgICAgLy8gTm93IGFkZCB0aGUgb3JpZ2luYWwgRVhJRiBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICByZXNpemVkRGF0YVVSTCA9IEV4aWZSZXN0b3JlLnJlc3RvcmUoZmlsZS5kYXRhVVJMLCByZXNpemVkRGF0YVVSTCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRHJvcHpvbmUuZGF0YVVSSXRvQmxvYihyZXNpemVkRGF0YVVSTCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNyZWF0ZVRodW1ibmFpbFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRodW1ibmFpbChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZmlsZS5kYXRhVVJMID0gZmlsZVJlYWRlci5yZXN1bHQ7XHJcblxyXG4gICAgICAgIC8vIERvbid0IGJvdGhlciBjcmVhdGluZyBhIHRodW1ibmFpbCBmb3IgU1ZHIGltYWdlcyBzaW5jZSB0aGV5J3JlIHZlY3RvclxyXG4gICAgICAgIGlmIChmaWxlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmaWxlUmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX3RoaXMxMi5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZml4T3JpZW50YXRpb24sIGNhbGxiYWNrKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNyZWF0ZVRodW1ibmFpbEZyb21VcmxcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUaHVtYm5haWxGcm9tVXJsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZml4T3JpZW50YXRpb24sIGNhbGxiYWNrLCBjcm9zc09yaWdpbikge1xyXG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBOb3QgdXNpbmcgYG5ldyBJbWFnZWAgaGVyZSBiZWNhdXNlIG9mIGEgYnVnIGluIGxhdGVzdCBDaHJvbWUgdmVyc2lvbnMuXHJcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZW55by9kcm9wem9uZS9wdWxsLzIyNlxyXG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHJcbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xyXG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2FkRXhpZiA9IGZ1bmN0aW9uIGxvYWRFeGlmKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIEVYSUYgIT09ICd1bmRlZmluZWQnICYmIEVYSUYgIT09IG51bGwgJiYgZml4T3JpZW50YXRpb24pIHtcclxuICAgICAgICAgIGxvYWRFeGlmID0gZnVuY3Rpb24gbG9hZEV4aWYoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVYSUYuZ2V0RGF0YShpbWcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRVhJRi5nZXRUYWcodGhpcywgJ09yaWVudGF0aW9uJykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbG9hZEV4aWYoZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICBmaWxlLndpZHRoID0gaW1nLndpZHRoO1xyXG4gICAgICAgICAgZmlsZS5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIHZhciByZXNpemVJbmZvID0gX3RoaXMxMy5vcHRpb25zLnJlc2l6ZS5jYWxsKF90aGlzMTMsIGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCk7XHJcblxyXG4gICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ1dpZHRoO1xyXG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlc2l6ZUluZm8udHJnSGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA+IDQpIHtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmVzaXplSW5mby50cmdIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZXNpemVJbmZvLnRyZ1dpZHRoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgIC8vIGhvcml6b250YWwgZmxpcFxyXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgLy8gMTgwwrAgcm90YXRlIGxlZnRcclxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGZsaXBcclxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgLy8gOTDCsCByb3RhdGUgcmlnaHRcclxuICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLWNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgLWNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAvLyA5MMKwIHJvdGF0ZSBsZWZ0XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtMC41ICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgYnVnZml4IGZvciBpT1MnIHNjYWxpbmcgYnVnLlxyXG4gICAgICAgICAgZHJhd0ltYWdlSU9TRml4KGN0eCwgaW1nLCByZXNpemVJbmZvLnNyY1ggIT0gbnVsbCA/IHJlc2l6ZUluZm8uc3JjWCA6IDAsIHJlc2l6ZUluZm8uc3JjWSAhPSBudWxsID8gcmVzaXplSW5mby5zcmNZIDogMCwgcmVzaXplSW5mby5zcmNXaWR0aCwgcmVzaXplSW5mby5zcmNIZWlnaHQsIHJlc2l6ZUluZm8udHJnWCAhPSBudWxsID8gcmVzaXplSW5mby50cmdYIDogMCwgcmVzaXplSW5mby50cmdZICE9IG51bGwgPyByZXNpemVJbmZvLnRyZ1kgOiAwLCByZXNpemVJbmZvLnRyZ1dpZHRoLCByZXNpemVJbmZvLnRyZ0hlaWdodCk7XHJcblxyXG4gICAgICAgICAgdmFyIHRodW1ibmFpbCA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcblxyXG4gICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRodW1ibmFpbCwgY2FudmFzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XHJcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBjYWxsYmFjaztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGltZy5zcmMgPSBmaWxlLmRhdGFVUkw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR29lcyB0aHJvdWdoIHRoZSBxdWV1ZSBhbmQgcHJvY2Vzc2VzIGZpbGVzIGlmIHRoZXJlIGFyZW4ndCB0b28gbWFueSBhbHJlYWR5LlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicHJvY2Vzc1F1ZXVlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xyXG4gICAgICB2YXIgcGFyYWxsZWxVcGxvYWRzID0gdGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcztcclxuXHJcbiAgICAgIHZhciBwcm9jZXNzaW5nTGVuZ3RoID0gdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aDtcclxuICAgICAgdmFyIGkgPSBwcm9jZXNzaW5nTGVuZ3RoO1xyXG5cclxuICAgICAgLy8gVGhlcmUgYXJlIGFscmVhZHkgYXQgbGVhc3QgYXMgbWFueSBmaWxlcyB1cGxvYWRpbmcgdGhhbiBzaG91bGQgYmVcclxuICAgICAgaWYgKHByb2Nlc3NpbmdMZW5ndGggPj0gcGFyYWxsZWxVcGxvYWRzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcXVldWVkRmlsZXMgPSB0aGlzLmdldFF1ZXVlZEZpbGVzKCk7XHJcblxyXG4gICAgICBpZiAoIShxdWV1ZWRGaWxlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xyXG4gICAgICAgIC8vIFRoZSBmaWxlcyBzaG91bGQgYmUgdXBsb2FkZWQgaW4gb25lIHJlcXVlc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRmlsZXMocXVldWVkRmlsZXMuc2xpY2UoMCwgcGFyYWxsZWxVcGxvYWRzIC0gcHJvY2Vzc2luZ0xlbmd0aCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlIChpIDwgcGFyYWxsZWxVcGxvYWRzKSB7XHJcbiAgICAgICAgICBpZiAoIXF1ZXVlZEZpbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIE5vdGhpbmcgbGVmdCB0byBwcm9jZXNzXHJcbiAgICAgICAgICB0aGlzLnByb2Nlc3NGaWxlKHF1ZXVlZEZpbGVzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdyYXBwZXIgZm9yIGBwcm9jZXNzRmlsZXNgXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJwcm9jZXNzRmlsZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGaWxlKGZpbGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbGVzKFtmaWxlXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZHMgdGhlIGZpbGUsIHRoZW4gY2FsbHMgZmluaXNoZWRMb2FkaW5nKClcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcInByb2Nlc3NGaWxlc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhmaWxlcykge1xyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxOSA9IGZpbGVzLCBfaXNBcnJheTE5ID0gdHJ1ZSwgX2kyMCA9IDAsIF9pdGVyYXRvcjE5ID0gX2lzQXJyYXkxOSA/IF9pdGVyYXRvcjE5IDogX2l0ZXJhdG9yMTlbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjE4O1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkxOSkge1xyXG4gICAgICAgICAgaWYgKF9pMjAgPj0gX2l0ZXJhdG9yMTkubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxOCA9IF9pdGVyYXRvcjE5W19pMjArK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMjAgPSBfaXRlcmF0b3IxOS5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kyMC5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYxOCA9IF9pMjAudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYxODtcclxuXHJcbiAgICAgICAgZmlsZS5wcm9jZXNzaW5nID0gdHJ1ZTsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgICAgICBmaWxlLnN0YXR1cyA9IERyb3B6b25lLlVQTE9BRElORztcclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KFwicHJvY2Vzc2luZ1wiLCBmaWxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xyXG4gICAgICAgIHRoaXMuZW1pdChcInByb2Nlc3NpbmdtdWx0aXBsZVwiLCBmaWxlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2dldEZpbGVzV2l0aFhoclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGaWxlc1dpdGhYaHIoeGhyKSB7XHJcbiAgICAgIHZhciBmaWxlcyA9IHZvaWQgMDtcclxuICAgICAgcmV0dXJuIGZpbGVzID0gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICByZXR1cm4gZmlsZS54aHIgPT09IHhocjtcclxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbmNlbHMgdGhlIGZpbGUgdXBsb2FkIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG8gQ0FOQ0VMRURcclxuICAgIC8vICoqaWYqKiB0aGUgZmlsZSBpcyBhY3R1YWxseSBiZWluZyB1cGxvYWRlZC5cclxuICAgIC8vIElmIGl0J3Mgc3RpbGwgaW4gdGhlIHF1ZXVlLCB0aGUgZmlsZSBpcyBiZWluZyByZW1vdmVkIGZyb20gaXQgYW5kIHRoZSBzdGF0dXNcclxuICAgIC8vIHNldCB0byBDQU5DRUxFRC5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNhbmNlbFVwbG9hZFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbFVwbG9hZChmaWxlKSB7XHJcbiAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuVVBMT0FESU5HKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwZWRGaWxlcyA9IHRoaXMuX2dldEZpbGVzV2l0aFhocihmaWxlLnhocik7XHJcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjAgPSBncm91cGVkRmlsZXMsIF9pc0FycmF5MjAgPSB0cnVlLCBfaTIxID0gMCwgX2l0ZXJhdG9yMjAgPSBfaXNBcnJheTIwID8gX2l0ZXJhdG9yMjAgOiBfaXRlcmF0b3IyMFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWYxOTtcclxuXHJcbiAgICAgICAgICBpZiAoX2lzQXJyYXkyMCkge1xyXG4gICAgICAgICAgICBpZiAoX2kyMSA+PSBfaXRlcmF0b3IyMC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMTkgPSBfaXRlcmF0b3IyMFtfaTIxKytdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2kyMSA9IF9pdGVyYXRvcjIwLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pMjEuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYxOSA9IF9pMjEudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGdyb3VwZWRGaWxlID0gX3JlZjE5O1xyXG5cclxuICAgICAgICAgIGdyb3VwZWRGaWxlLnN0YXR1cyA9IERyb3B6b25lLkNBTkNFTEVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZpbGUueGhyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgZmlsZS54aHIuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjEgPSBncm91cGVkRmlsZXMsIF9pc0FycmF5MjEgPSB0cnVlLCBfaTIyID0gMCwgX2l0ZXJhdG9yMjEgPSBfaXNBcnJheTIxID8gX2l0ZXJhdG9yMjEgOiBfaXRlcmF0b3IyMVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWYyMDtcclxuXHJcbiAgICAgICAgICBpZiAoX2lzQXJyYXkyMSkge1xyXG4gICAgICAgICAgICBpZiAoX2kyMiA+PSBfaXRlcmF0b3IyMS5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMjAgPSBfaXRlcmF0b3IyMVtfaTIyKytdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2kyMiA9IF9pdGVyYXRvcjIxLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pMjIuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYyMCA9IF9pMjIudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIF9ncm91cGVkRmlsZSA9IF9yZWYyMDtcclxuXHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxlZFwiLCBfZ3JvdXBlZEZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxlZG11bHRpcGxlXCIsIGdyb3VwZWRGaWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5BRERFRCB8fCBmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuUVVFVUVEKSB7XHJcbiAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5DQU5DRUxFRDtcclxuICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxlZFwiLCBmaWxlKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjYW5jZWxlZG11bHRpcGxlXCIsIFtmaWxlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZXNvbHZlT3B0aW9uXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbihvcHRpb24pIHtcclxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XHJcbiAgICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJ1cGxvYWRGaWxlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkRmlsZShmaWxlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKFtmaWxlXSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInVwbG9hZEZpbGVzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkRmlsZXMoZmlsZXMpIHtcclxuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5fdHJhbnNmb3JtRmlsZXMoZmlsZXMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1lZEZpbGVzKSB7XHJcbiAgICAgICAgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGZpbGUgc2hvdWxkIGJlIHNlbnQgaW4gY2h1bmtzIVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBjaHVua2luZyBvcHRpb24gaXMgc2V0LCB3ZSAqKmtub3cqKiB0aGF0IHRoZXJlIGNhbiBvbmx5IGJlICoqb25lKiogZmlsZSwgc2luY2VcclxuICAgICAgICAgIC8vIHVwbG9hZE11bHRpcGxlIGlzIG5vdCBhbGxvd2VkIHdpdGggdGhpcyBvcHRpb24uXHJcbiAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzWzBdO1xyXG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRmlsZSA9IHRyYW5zZm9ybWVkRmlsZXNbMF07XHJcbiAgICAgICAgICB2YXIgc3RhcnRlZENodW5rQ291bnQgPSAwO1xyXG5cclxuICAgICAgICAgIGZpbGUudXBsb2FkLmNodW5rcyA9IFtdO1xyXG5cclxuICAgICAgICAgIHZhciBoYW5kbGVOZXh0Q2h1bmsgPSBmdW5jdGlvbiBoYW5kbGVOZXh0Q2h1bmsoKSB7XHJcbiAgICAgICAgICAgIHZhciBjaHVua0luZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgaXRlbSBpbiBmaWxlLnVwbG9hZC5jaHVua3MgdGhhdCBpcyBub3QgZGVmaW5lZCB5ZXQuXHJcbiAgICAgICAgICAgIHdoaWxlIChmaWxlLnVwbG9hZC5jaHVua3NbY2h1bmtJbmRleF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIGNodW5rSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucywgdGhhdCBhbGwgY2h1bmtzIGhhdmUgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuXHJcbiAgICAgICAgICAgIGlmIChjaHVua0luZGV4ID49IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgc3RhcnRlZENodW5rQ291bnQrKztcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNodW5rSW5kZXggKiBfdGhpczE0Lm9wdGlvbnMuY2h1bmtTaXplO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBfdGhpczE0Lm9wdGlvbnMuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGFCbG9jayA9IHtcclxuICAgICAgICAgICAgICBuYW1lOiBfdGhpczE0Ll9nZXRQYXJhbU5hbWUoMCksXHJcbiAgICAgICAgICAgICAgZGF0YTogdHJhbnNmb3JtZWRGaWxlLndlYmtpdFNsaWNlID8gdHJhbnNmb3JtZWRGaWxlLndlYmtpdFNsaWNlKHN0YXJ0LCBlbmQpIDogdHJhbnNmb3JtZWRGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLFxyXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLnVwbG9hZC5maWxlbmFtZSxcclxuICAgICAgICAgICAgICBjaHVua0luZGV4OiBjaHVua0luZGV4XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmaWxlLnVwbG9hZC5jaHVua3NbY2h1bmtJbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgZmlsZTogZmlsZSxcclxuICAgICAgICAgICAgICBpbmRleDogY2h1bmtJbmRleCxcclxuICAgICAgICAgICAgICBkYXRhQmxvY2s6IGRhdGFCbG9jaywgLy8gSW4gY2FzZSB3ZSB3YW50IHRvIHJldHJ5LlxyXG4gICAgICAgICAgICAgIHN0YXR1czogRHJvcHpvbmUuVVBMT0FESU5HLFxyXG4gICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgIHJldHJpZXM6IDAgLy8gVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGJsb2NrIGhhcyBiZWVuIHJldHJpZWQuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBfdGhpczE0Ll91cGxvYWREYXRhKGZpbGVzLCBbZGF0YUJsb2NrXSk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGZpbGUudXBsb2FkLmZpbmlzaGVkQ2h1bmtVcGxvYWQgPSBmdW5jdGlvbiAoY2h1bmspIHtcclxuICAgICAgICAgICAgdmFyIGFsbEZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gRHJvcHpvbmUuU1VDQ0VTUztcclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBkYXRhIGZyb20gdGhlIGNodW5rXHJcbiAgICAgICAgICAgIGNodW5rLmRhdGFCbG9jayA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTmV4dENodW5rKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0uc3RhdHVzICE9PSBEcm9wem9uZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxGaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFsbEZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMxNC5vcHRpb25zLmNodW5rc1VwbG9hZGVkKGZpbGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzMTQuX2ZpbmlzaGVkKGZpbGVzLCAnJywgbnVsbCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKF90aGlzMTQub3B0aW9ucy5wYXJhbGxlbENodW5rVXBsb2Fkcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlTmV4dENodW5rKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZU5leHRDaHVuaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgZGF0YUJsb2NrcyA9IFtdO1xyXG4gICAgICAgICAgZm9yICh2YXIgX2kyMyA9IDA7IF9pMjMgPCBmaWxlcy5sZW5ndGg7IF9pMjMrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tzW19pMjNdID0ge1xyXG4gICAgICAgICAgICAgIG5hbWU6IF90aGlzMTQuX2dldFBhcmFtTmFtZShfaTIzKSxcclxuICAgICAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1lZEZpbGVzW19pMjNdLFxyXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlc1tfaTIzXS51cGxvYWQuZmlsZW5hbWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF90aGlzMTQuX3VwbG9hZERhdGEoZmlsZXMsIGRhdGFCbG9ja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIFJldHVybnMgdGhlIHJpZ2h0IGNodW5rIGZvciBnaXZlbiBmaWxlIGFuZCB4aHJcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9nZXRDaHVua1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaHVuayhmaWxlLCB4aHIpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKykge1xyXG4gICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0gIT09IHVuZGVmaW5lZCAmJiBmaWxlLnVwbG9hZC5jaHVua3NbaV0ueGhyID09PSB4aHIpIHtcclxuICAgICAgICAgIHJldHVybiBmaWxlLnVwbG9hZC5jaHVua3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY3R1YWxseSB1cGxvYWRzIHRoZSBmaWxlKHMpIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAvLyBJZiBkYXRhQmxvY2tzIGNvbnRhaW5zIHRoZSBhY3R1YWwgZGF0YSB0byB1cGxvYWQgKG1lYW5pbmcsIHRoYXQgdGhpcyBjb3VsZCBlaXRoZXIgYmUgdHJhbnNmb3JtZWRcclxuICAgIC8vIGZpbGVzLCBvciBpbmRpdmlkdWFsIGNodW5rcyBmb3IgY2h1bmtlZCB1cGxvYWQpLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX3VwbG9hZERhdGFcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBsb2FkRGF0YShmaWxlcywgZGF0YUJsb2Nrcykge1xyXG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgICAvLyBQdXQgdGhlIHhociBvYmplY3QgaW4gdGhlIGZpbGUgb2JqZWN0cyB0byBiZSBhYmxlIHRvIHJlZmVyZW5jZSBpdCBsYXRlci5cclxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjIgPSBmaWxlcywgX2lzQXJyYXkyMiA9IHRydWUsIF9pMjQgPSAwLCBfaXRlcmF0b3IyMiA9IF9pc0FycmF5MjIgPyBfaXRlcmF0b3IyMiA6IF9pdGVyYXRvcjIyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgdmFyIF9yZWYyMTtcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5MjIpIHtcclxuICAgICAgICAgIGlmIChfaTI0ID49IF9pdGVyYXRvcjIyLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMjEgPSBfaXRlcmF0b3IyMltfaTI0KytdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfaTI0ID0gX2l0ZXJhdG9yMjIubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pMjQuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMjEgPSBfaTI0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMjE7XHJcblxyXG4gICAgICAgIGZpbGUueGhyID0geGhyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkge1xyXG4gICAgICAgIC8vIFB1dCB0aGUgeGhyIG9iamVjdCBpbiB0aGUgcmlnaHQgY2h1bmsgb2JqZWN0LCBzbyBpdCBjYW4gYmUgYXNzb2NpYXRlZCBsYXRlciwgYW5kIGZvdW5kIHdpdGggX2dldENodW5rXHJcbiAgICAgICAgZmlsZXNbMF0udXBsb2FkLmNodW5rc1tkYXRhQmxvY2tzWzBdLmNodW5rSW5kZXhdLnhociA9IHhocjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMubWV0aG9kLCBmaWxlcyk7XHJcbiAgICAgIHZhciB1cmwgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnVybCwgZmlsZXMpO1xyXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XHJcblxyXG4gICAgICAvLyBTZXR0aW5nIHRoZSB0aW1lb3V0IGFmdGVyIG9wZW4gYmVjYXVzZSBvZiBJRTExIGlzc3VlOiBodHRwczovL2dpdGxhYi5jb20vbWVuby9kcm9wem9uZS9pc3N1ZXMvOFxyXG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMudGltZW91dCwgZmlsZXMpO1xyXG5cclxuICAgICAgLy8gSGFzIHRvIGJlIGFmdGVyIGAub3BlbigpYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbnlvL2Ryb3B6b25lL2lzc3Vlcy8xNzlcclxuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhdGhpcy5vcHRpb25zLndpdGhDcmVkZW50aWFscztcclxuXHJcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIF90aGlzMTUuX2ZpbmlzaGVkVXBsb2FkaW5nKGZpbGVzLCB4aHIsIGUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3RoaXMxNS5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhocik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBoYXZlIHRoZSAudXBsb2FkIHByb3BlcnR5XHJcbiAgICAgIHZhciBwcm9ncmVzc09iaiA9IHhoci51cGxvYWQgIT0gbnVsbCA/IHhoci51cGxvYWQgOiB4aHI7XHJcbiAgICAgIHByb2dyZXNzT2JqLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiBfdGhpczE1Ll91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzKGZpbGVzLCB4aHIsIGUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGhlYWRlcnMgPSB7XHJcbiAgICAgICAgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGVcIixcclxuICAgICAgICBcIlgtUmVxdWVzdGVkLVdpdGhcIjogXCJYTUxIdHRwUmVxdWVzdFwiXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcclxuICAgICAgICBEcm9wem9uZS5leHRlbmQoaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcclxuICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xyXG4gICAgICAgIGlmIChoZWFkZXJWYWx1ZSkge1xyXG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcblxyXG4gICAgICAvLyBBZGRpbmcgYWxsIEBvcHRpb25zIHBhcmFtZXRlcnNcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbXMpIHtcclxuICAgICAgICB2YXIgYWRkaXRpb25hbFBhcmFtcyA9IHRoaXMub3B0aW9ucy5wYXJhbXM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRpdGlvbmFsUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBhZGRpdGlvbmFsUGFyYW1zID0gYWRkaXRpb25hbFBhcmFtcy5jYWxsKHRoaXMsIGZpbGVzLCB4aHIsIGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkID8gdGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhocikgOiBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhZGRpdGlvbmFsUGFyYW1zKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhZGRpdGlvbmFsUGFyYW1zW2tleV07XHJcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMZXQgdGhlIHVzZXIgYWRkIGFkZGl0aW9uYWwgZGF0YSBpZiBuZWNlc3NhcnlcclxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjMgPSBmaWxlcywgX2lzQXJyYXkyMyA9IHRydWUsIF9pMjUgPSAwLCBfaXRlcmF0b3IyMyA9IF9pc0FycmF5MjMgPyBfaXRlcmF0b3IyMyA6IF9pdGVyYXRvcjIzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgdmFyIF9yZWYyMjtcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5MjMpIHtcclxuICAgICAgICAgIGlmIChfaTI1ID49IF9pdGVyYXRvcjIzLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMjIgPSBfaXRlcmF0b3IyM1tfaTI1KytdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfaTI1ID0gX2l0ZXJhdG9yMjMubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pMjUuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMjIgPSBfaTI1LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIF9maWxlID0gX3JlZjIyO1xyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJzZW5kaW5nXCIsIF9maWxlLCB4aHIsIGZvcm1EYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwic2VuZGluZ211bHRpcGxlXCIsIGZpbGVzLCB4aHIsIGZvcm1EYXRhKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fYWRkRm9ybUVsZW1lbnREYXRhKGZvcm1EYXRhKTtcclxuXHJcbiAgICAgIC8vIEZpbmFsbHkgYWRkIHRoZSBmaWxlc1xyXG4gICAgICAvLyBIYXMgdG8gYmUgbGFzdCBiZWNhdXNlIHNvbWUgc2VydmVycyAoZWc6IFMzKSBleHBlY3QgdGhlIGZpbGUgdG8gYmUgdGhlIGxhc3QgcGFyYW1ldGVyXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUJsb2Nrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzW2ldO1xyXG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChkYXRhQmxvY2submFtZSwgZGF0YUJsb2NrLmRhdGEsIGRhdGFCbG9jay5maWxlbmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc3VibWl0UmVxdWVzdCh4aHIsIGZvcm1EYXRhLCBmaWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJhbnNmb3JtcyBhbGwgZmlsZXMgd2l0aCB0aGlzLm9wdGlvbnMudHJhbnNmb3JtRmlsZSBhbmQgaW52b2tlcyBkb25lIHdpdGggdGhlIHRyYW5zZm9ybWVkIGZpbGVzIHdoZW4gZG9uZS5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl90cmFuc2Zvcm1GaWxlc1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1GaWxlcyhmaWxlcywgZG9uZSkge1xyXG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgdHJhbnNmb3JtZWRGaWxlcyA9IFtdO1xyXG4gICAgICAvLyBDbHVtc3kgd2F5IG9mIGhhbmRsaW5nIGFzeW5jaHJvbm91cyBjYWxscywgdW50aWwgSSBnZXQgdG8gYWRkIGEgcHJvcGVyIEZ1dHVyZSBsaWJyYXJ5LlxyXG4gICAgICB2YXIgZG9uZUNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xyXG4gICAgICAgIF90aGlzMTYub3B0aW9ucy50cmFuc2Zvcm1GaWxlLmNhbGwoX3RoaXMxNiwgZmlsZXNbaV0sIGZ1bmN0aW9uICh0cmFuc2Zvcm1lZEZpbGUpIHtcclxuICAgICAgICAgIHRyYW5zZm9ybWVkRmlsZXNbaV0gPSB0cmFuc2Zvcm1lZEZpbGU7XHJcbiAgICAgICAgICBpZiAoKytkb25lQ291bnRlciA9PT0gZmlsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRvbmUodHJhbnNmb3JtZWRGaWxlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgX2xvb3AoaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUYWtlcyBjYXJlIG9mIGFkZGluZyBvdGhlciBpbnB1dCBlbGVtZW50cyBvZiB0aGUgZm9ybSB0byB0aGUgQUpBWCByZXF1ZXN0XHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfYWRkRm9ybUVsZW1lbnREYXRhXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZvcm1FbGVtZW50RGF0YShmb3JtRGF0YSkge1xyXG4gICAgICAvLyBUYWtlIGNhcmUgb2Ygb3RoZXIgaW5wdXQgZWxlbWVudHNcclxuICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lID09PSBcIkZPUk1cIikge1xyXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjI0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCwgYnV0dG9uXCIpLCBfaXNBcnJheTI0ID0gdHJ1ZSwgX2kyNiA9IDAsIF9pdGVyYXRvcjI0ID0gX2lzQXJyYXkyNCA/IF9pdGVyYXRvcjI0IDogX2l0ZXJhdG9yMjRbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgIHZhciBfcmVmMjM7XHJcblxyXG4gICAgICAgICAgaWYgKF9pc0FycmF5MjQpIHtcclxuICAgICAgICAgICAgaWYgKF9pMjYgPj0gX2l0ZXJhdG9yMjQubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZjIzID0gX2l0ZXJhdG9yMjRbX2kyNisrXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9pMjYgPSBfaXRlcmF0b3IyNC5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChfaTI2LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMjMgPSBfaTI2LnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBpbnB1dCA9IF9yZWYyMztcclxuXHJcbiAgICAgICAgICB2YXIgaW5wdXROYW1lID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcclxuICAgICAgICAgIHZhciBpbnB1dFR5cGUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xyXG4gICAgICAgICAgaWYgKGlucHV0VHlwZSkgaW5wdXRUeXBlID0gaW5wdXRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIG5hbWUsIHdlIGNhbid0IHVzZSBpdC5cclxuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXROYW1lID09PSAndW5kZWZpbmVkJyB8fCBpbnB1dE5hbWUgPT09IG51bGwpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSBcIlNFTEVDVFwiICYmIGlucHV0Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmx5IG11bHRpcGxlIHZhbHVlc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNSA9IGlucHV0Lm9wdGlvbnMsIF9pc0FycmF5MjUgPSB0cnVlLCBfaTI3ID0gMCwgX2l0ZXJhdG9yMjUgPSBfaXNBcnJheTI1ID8gX2l0ZXJhdG9yMjUgOiBfaXRlcmF0b3IyNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgICAgIHZhciBfcmVmMjQ7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTI1KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2kyNyA+PSBfaXRlcmF0b3IyNS5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjI0ID0gX2l0ZXJhdG9yMjVbX2kyNysrXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2kyNyA9IF9pdGVyYXRvcjI1Lm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfaTI3LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgX3JlZjI0ID0gX2kyNy52YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfcmVmMjQ7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChpbnB1dE5hbWUsIG9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUgfHwgaW5wdXRUeXBlICE9PSBcImNoZWNrYm94XCIgJiYgaW5wdXRUeXBlICE9PSBcInJhZGlvXCIgfHwgaW5wdXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoaW5wdXROYW1lLCBpbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW52b2tlZCB3aGVuIHRoZXJlIGlzIG5ldyBwcm9ncmVzcyBpbmZvcm1hdGlvbiBhYm91dCBnaXZlbiBmaWxlcy5cclxuICAgIC8vIElmIGUgaXMgbm90IHByb3ZpZGVkLCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHVwbG9hZCBpcyBmaW5pc2hlZC5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZmlsZXMsIHhociwgZSkge1xyXG4gICAgICB2YXIgcHJvZ3Jlc3MgPSB2b2lkIDA7XHJcbiAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBwcm9ncmVzcyA9IDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbDtcclxuXHJcbiAgICAgICAgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkKSB7XHJcbiAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzWzBdO1xyXG4gICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGNodW5rZWQgdXBsb2FkLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgYXBwcm9wcmlhdGUgY2h1bmsgcHJvZ3Jlc3MuXHJcbiAgICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLl9nZXRDaHVuayhmaWxlLCB4aHIpO1xyXG4gICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICAgIGNodW5rLnRvdGFsID0gZS50b3RhbDtcclxuICAgICAgICAgIGNodW5rLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xyXG4gICAgICAgICAgdmFyIGZpbGVQcm9ncmVzcyA9IDAsXHJcbiAgICAgICAgICAgICAgZmlsZVRvdGFsID0gdm9pZCAwLFxyXG4gICAgICAgICAgICAgIGZpbGVCeXRlc1NlbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICBmaWxlLnVwbG9hZC50b3RhbCA9IDA7XHJcbiAgICAgICAgICBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgPSAwO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZmlsZS51cGxvYWQuY2h1bmtzW2ldICE9PSB1bmRlZmluZWQgJiYgZmlsZS51cGxvYWQuY2h1bmtzW2ldLnByb2dyZXNzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyArPSBmaWxlLnVwbG9hZC5jaHVua3NbaV0ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgZmlsZS51cGxvYWQudG90YWwgKz0gZmlsZS51cGxvYWQuY2h1bmtzW2ldLnRvdGFsO1xyXG4gICAgICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCArPSBmaWxlLnVwbG9hZC5jaHVua3NbaV0uYnl0ZXNTZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IGZpbGUudXBsb2FkLnByb2dyZXNzIC8gZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNiA9IGZpbGVzLCBfaXNBcnJheTI2ID0gdHJ1ZSwgX2kyOCA9IDAsIF9pdGVyYXRvcjI2ID0gX2lzQXJyYXkyNiA/IF9pdGVyYXRvcjI2IDogX2l0ZXJhdG9yMjZbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgICAgdmFyIF9yZWYyNTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfaXNBcnJheTI2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKF9pMjggPj0gX2l0ZXJhdG9yMjYubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgICBfcmVmMjUgPSBfaXRlcmF0b3IyNltfaTI4KytdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIF9pMjggPSBfaXRlcmF0b3IyNi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgaWYgKF9pMjguZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgX3JlZjI1ID0gX2kyOC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIF9maWxlMiA9IF9yZWYyNTtcclxuXHJcbiAgICAgICAgICAgIF9maWxlMi51cGxvYWQucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICAgICAgX2ZpbGUyLnVwbG9hZC50b3RhbCA9IGUudG90YWw7XHJcbiAgICAgICAgICAgIF9maWxlMi51cGxvYWQuYnl0ZXNTZW50ID0gZS5sb2FkZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjI3ID0gZmlsZXMsIF9pc0FycmF5MjcgPSB0cnVlLCBfaTI5ID0gMCwgX2l0ZXJhdG9yMjcgPSBfaXNBcnJheTI3ID8gX2l0ZXJhdG9yMjcgOiBfaXRlcmF0b3IyN1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWYyNjtcclxuXHJcbiAgICAgICAgICBpZiAoX2lzQXJyYXkyNykge1xyXG4gICAgICAgICAgICBpZiAoX2kyOSA+PSBfaXRlcmF0b3IyNy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMjYgPSBfaXRlcmF0b3IyN1tfaTI5KytdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2kyOSA9IF9pdGVyYXRvcjI3Lm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pMjkuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYyNiA9IF9pMjkudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIF9maWxlMyA9IF9yZWYyNjtcclxuXHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGxvYWRwcm9ncmVzc1wiLCBfZmlsZTMsIF9maWxlMy51cGxvYWQucHJvZ3Jlc3MsIF9maWxlMy51cGxvYWQuYnl0ZXNTZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGZpbGUgZmluaXNoZWQgdXBsb2FkaW5nXHJcblxyXG4gICAgICAgIHZhciBhbGxGaWxlc0ZpbmlzaGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcHJvZ3Jlc3MgPSAxMDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjI4ID0gZmlsZXMsIF9pc0FycmF5MjggPSB0cnVlLCBfaTMwID0gMCwgX2l0ZXJhdG9yMjggPSBfaXNBcnJheTI4ID8gX2l0ZXJhdG9yMjggOiBfaXRlcmF0b3IyOFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgICAgdmFyIF9yZWYyNztcclxuXHJcbiAgICAgICAgICBpZiAoX2lzQXJyYXkyOCkge1xyXG4gICAgICAgICAgICBpZiAoX2kzMCA+PSBfaXRlcmF0b3IyOC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMjcgPSBfaXRlcmF0b3IyOFtfaTMwKytdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2kzMCA9IF9pdGVyYXRvcjI4Lm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKF9pMzAuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYyNyA9IF9pMzAudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIF9maWxlNCA9IF9yZWYyNztcclxuXHJcbiAgICAgICAgICBpZiAoX2ZpbGU0LnVwbG9hZC5wcm9ncmVzcyAhPT0gMTAwIHx8IF9maWxlNC51cGxvYWQuYnl0ZXNTZW50ICE9PSBfZmlsZTQudXBsb2FkLnRvdGFsKSB7XHJcbiAgICAgICAgICAgIGFsbEZpbGVzRmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF9maWxlNC51cGxvYWQucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICAgIF9maWxlNC51cGxvYWQuYnl0ZXNTZW50ID0gX2ZpbGU0LnVwbG9hZC50b3RhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIGFsbCBmaWxlcyBhbHJlYWR5IGF0IDEwMCVcclxuICAgICAgICBpZiAoYWxsRmlsZXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjkgPSBmaWxlcywgX2lzQXJyYXkyOSA9IHRydWUsIF9pMzEgPSAwLCBfaXRlcmF0b3IyOSA9IF9pc0FycmF5MjkgPyBfaXRlcmF0b3IyOSA6IF9pdGVyYXRvcjI5W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgICB2YXIgX3JlZjI4O1xyXG5cclxuICAgICAgICAgIGlmIChfaXNBcnJheTI5KSB7XHJcbiAgICAgICAgICAgIGlmIChfaTMxID49IF9pdGVyYXRvcjI5Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgIF9yZWYyOCA9IF9pdGVyYXRvcjI5W19pMzErK107XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfaTMxID0gX2l0ZXJhdG9yMjkubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoX2kzMS5kb25lKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZjI4ID0gX2kzMS52YWx1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgX2ZpbGU1ID0gX3JlZjI4O1xyXG5cclxuICAgICAgICAgIHRoaXMuZW1pdChcInVwbG9hZHByb2dyZXNzXCIsIF9maWxlNSwgcHJvZ3Jlc3MsIF9maWxlNS51cGxvYWQuYnl0ZXNTZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2ZpbmlzaGVkVXBsb2FkaW5nXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaGVkVXBsb2FkaW5nKGZpbGVzLCB4aHIsIGUpIHtcclxuICAgICAgdmFyIHJlc3BvbnNlID0gdm9pZCAwO1xyXG5cclxuICAgICAgaWYgKGZpbGVzWzBdLnN0YXR1cyA9PT0gRHJvcHpvbmUuQ0FOQ0VMRUQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgIT09ICdhcnJheWJ1ZmZlcicgJiYgeGhyLnJlc3BvbnNlVHlwZSAhPT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG5cclxuICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpICYmIH54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBlID0gZXJyb3I7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gXCJJbnZhbGlkIEpTT04gcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzKGZpbGVzKTtcclxuXHJcbiAgICAgIGlmICghKDIwMCA8PSB4aHIuc3RhdHVzICYmIHhoci5zdGF0dXMgPCAzMDApKSB7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgcmVzcG9uc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkge1xyXG4gICAgICAgICAgZmlsZXNbMF0udXBsb2FkLmZpbmlzaGVkQ2h1bmtVcGxvYWQodGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhocikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9maW5pc2hlZChmaWxlcywgcmVzcG9uc2UsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfaGFuZGxlVXBsb2FkRXJyb3JcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgcmVzcG9uc2UpIHtcclxuICAgICAgaWYgKGZpbGVzWzBdLnN0YXR1cyA9PT0gRHJvcHpvbmUuQ0FOQ0VMRUQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCAmJiB0aGlzLm9wdGlvbnMucmV0cnlDaHVua3MpIHtcclxuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKTtcclxuICAgICAgICBpZiAoY2h1bmsucmV0cmllcysrIDwgdGhpcy5vcHRpb25zLnJldHJ5Q2h1bmtzTGltaXQpIHtcclxuICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEoZmlsZXMsIFtjaHVuay5kYXRhQmxvY2tdKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXRyaWVkIHRoaXMgY2h1bmsgdG9vIG9mdGVuLiBHaXZpbmcgdXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzMCA9IGZpbGVzLCBfaXNBcnJheTMwID0gdHJ1ZSwgX2kzMiA9IDAsIF9pdGVyYXRvcjMwID0gX2lzQXJyYXkzMCA/IF9pdGVyYXRvcjMwIDogX2l0ZXJhdG9yMzBbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjI5O1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkzMCkge1xyXG4gICAgICAgICAgaWYgKF9pMzIgPj0gX2l0ZXJhdG9yMzAubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYyOSA9IF9pdGVyYXRvcjMwW19pMzIrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMzIgPSBfaXRlcmF0b3IzMC5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kzMi5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYyOSA9IF9pMzIudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYyOTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXJyb3JQcm9jZXNzaW5nKGZpbGVzLCByZXNwb25zZSB8fCB0aGlzLm9wdGlvbnMuZGljdFJlc3BvbnNlRXJyb3IucmVwbGFjZShcInt7c3RhdHVzQ29kZX19XCIsIHhoci5zdGF0dXMpLCB4aHIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInN1Ym1pdFJlcXVlc3RcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJtaXRSZXF1ZXN0KHhociwgZm9ybURhdGEsIGZpbGVzKSB7XHJcbiAgICAgIHhoci5zZW5kKGZvcm1EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHByb2Nlc3NpbmcgaXMgZmluaXNoZWQuXHJcbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfZmluaXNoZWRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoZWQoZmlsZXMsIHJlc3BvbnNlVGV4dCwgZSkge1xyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzMSA9IGZpbGVzLCBfaXNBcnJheTMxID0gdHJ1ZSwgX2kzMyA9IDAsIF9pdGVyYXRvcjMxID0gX2lzQXJyYXkzMSA/IF9pdGVyYXRvcjMxIDogX2l0ZXJhdG9yMzFbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjMwO1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkzMSkge1xyXG4gICAgICAgICAgaWYgKF9pMzMgPj0gX2l0ZXJhdG9yMzEubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYzMCA9IF9pdGVyYXRvcjMxW19pMzMrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMzMgPSBfaXRlcmF0b3IzMS5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kzMy5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYzMCA9IF9pMzMudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYzMDtcclxuXHJcbiAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5TVUNDRVNTO1xyXG4gICAgICAgIHRoaXMuZW1pdChcInN1Y2Nlc3NcIiwgZmlsZSwgcmVzcG9uc2VUZXh0LCBlKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc211bHRpcGxlXCIsIGZpbGVzLCByZXNwb25zZVRleHQsIGUpO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlbXVsdGlwbGVcIiwgZmlsZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZC5cclxuICAgIC8vIEluZGl2aWR1YWwgY2FsbGJhY2tzIGhhdmUgdG8gYmUgY2FsbGVkIGluIHRoZSBhcHByb3ByaWF0ZSBzZWN0aW9ucy5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9lcnJvclByb2Nlc3NpbmdcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXJyb3JQcm9jZXNzaW5nKGZpbGVzLCBtZXNzYWdlLCB4aHIpIHtcclxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMzIgPSBmaWxlcywgX2lzQXJyYXkzMiA9IHRydWUsIF9pMzQgPSAwLCBfaXRlcmF0b3IzMiA9IF9pc0FycmF5MzIgPyBfaXRlcmF0b3IzMiA6IF9pdGVyYXRvcjMyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgICAgdmFyIF9yZWYzMTtcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5MzIpIHtcclxuICAgICAgICAgIGlmIChfaTM0ID49IF9pdGVyYXRvcjMyLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMzEgPSBfaXRlcmF0b3IzMltfaTM0KytdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfaTM0ID0gX2l0ZXJhdG9yMzIubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pMzQuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMzEgPSBfaTM0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMzE7XHJcblxyXG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuRVJST1I7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZmlsZSwgbWVzc2FnZSwgeGhyKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JtdWx0aXBsZVwiLCBmaWxlcywgbWVzc2FnZSwgeGhyKTtcclxuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZW11bHRpcGxlXCIsIGZpbGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XSwgW3tcclxuICAgIGtleTogXCJ1dWlkdjRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1dWlkdjQoKSB7XHJcbiAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxyXG4gICAgICAgICAgICB2ID0gYyA9PT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBEcm9wem9uZTtcclxufShFbWl0dGVyKTtcclxuXHJcbkRyb3B6b25lLmluaXRDbGFzcygpO1xyXG5cclxuRHJvcHpvbmUudmVyc2lvbiA9IFwiNS40LjBcIjtcclxuXHJcbi8vIFRoaXMgaXMgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgeW91ciBkaWZmZXJlbnQgZHJvcHpvbmVzLiBBZGQgY29uZmlndXJhdGlvbnNcclxuLy8gdG8gdGhpcyBvYmplY3QgZm9yIHlvdXIgZGlmZmVyZW50IGRyb3B6b25lIGVsZW1lbnMuXHJcbi8vXHJcbi8vIEV4YW1wbGU6XHJcbi8vXHJcbi8vICAgICBEcm9wem9uZS5vcHRpb25zLm15RHJvcHpvbmVFbGVtZW50SWQgPSB7IG1heEZpbGVzaXplOiAxIH07XHJcbi8vXHJcbi8vIFRvIGRpc2FibGUgYXV0b0Rpc2NvdmVyIGZvciBhIHNwZWNpZmljIGVsZW1lbnQsIHlvdSBjYW4gc2V0IGBmYWxzZWAgYXMgYW4gb3B0aW9uOlxyXG4vL1xyXG4vLyAgICAgRHJvcHpvbmUub3B0aW9ucy5teURpc2FibGVkRWxlbWVudElkID0gZmFsc2U7XHJcbi8vXHJcbi8vIEFuZCBpbiBodG1sOlxyXG4vL1xyXG4vLyAgICAgPGZvcm0gYWN0aW9uPVwiL3VwbG9hZFwiIGlkPVwibXktZHJvcHpvbmUtZWxlbWVudC1pZFwiIGNsYXNzPVwiZHJvcHpvbmVcIj48L2Zvcm0+XHJcbkRyb3B6b25lLm9wdGlvbnMgPSB7fTtcclxuXHJcbi8vIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIGFuIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgYXZhaWxhYmxlLlxyXG5Ecm9wem9uZS5vcHRpb25zRm9yRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgLy8gR2V0IHRoZSBgRHJvcHpvbmUub3B0aW9ucy5lbGVtZW50SWRgIGZvciB0aGlzIGVsZW1lbnQgaWYgaXQgZXhpc3RzXHJcbiAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpIHtcclxuICAgIHJldHVybiBEcm9wem9uZS5vcHRpb25zW2NhbWVsaXplKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpXTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn07XHJcblxyXG4vLyBIb2xkcyBhIGxpc3Qgb2YgYWxsIGRyb3B6b25lIGluc3RhbmNlc1xyXG5Ecm9wem9uZS5pbnN0YW5jZXMgPSBbXTtcclxuXHJcbi8vIFJldHVybnMgdGhlIGRyb3B6b25lIGZvciBnaXZlbiBlbGVtZW50IGlmIGFueVxyXG5Ecm9wem9uZS5mb3JFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xyXG4gIH1cclxuICBpZiAoKGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuZHJvcHpvbmUgOiB1bmRlZmluZWQpID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIERyb3B6b25lIGZvdW5kIGZvciBnaXZlbiBlbGVtZW50LiBUaGlzIGlzIHByb2JhYmx5IGJlY2F1c2UgeW91J3JlIHRyeWluZyB0byBhY2Nlc3MgaXQgYmVmb3JlIERyb3B6b25lIGhhZCB0aGUgdGltZSB0byBpbml0aWFsaXplLiBVc2UgdGhlIGBpbml0YCBvcHRpb24gdG8gc2V0dXAgYW55IGFkZGl0aW9uYWwgb2JzZXJ2ZXJzIG9uIHlvdXIgRHJvcHpvbmUuXCIpO1xyXG4gIH1cclxuICByZXR1cm4gZWxlbWVudC5kcm9wem9uZTtcclxufTtcclxuXHJcbi8vIFNldCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCBEcm9wem9uZSB0byBhdXRvbWF0aWNhbGx5IGZpbmQgYW5kIGF0dGFjaCB0byAuZHJvcHpvbmUgZWxlbWVudHMuXHJcbkRyb3B6b25lLmF1dG9EaXNjb3ZlciA9IHRydWU7XHJcblxyXG4vLyBMb29rcyBmb3IgYWxsIC5kcm9wem9uZSBlbGVtZW50cyBhbmQgY3JlYXRlcyBhIGRyb3B6b25lIGZvciB0aGVtXHJcbkRyb3B6b25lLmRpc2NvdmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBkcm9wem9uZXMgPSB2b2lkIDA7XHJcbiAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcclxuICAgIGRyb3B6b25lcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZHJvcHpvbmVcIik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRyb3B6b25lcyA9IFtdO1xyXG4gICAgLy8gSUUgOihcclxuICAgIHZhciBjaGVja0VsZW1lbnRzID0gZnVuY3Rpb24gY2hlY2tFbGVtZW50cyhlbGVtZW50cykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzMyA9IGVsZW1lbnRzLCBfaXNBcnJheTMzID0gdHJ1ZSwgX2kzNSA9IDAsIF9pdGVyYXRvcjMzID0gX2lzQXJyYXkzMyA/IF9pdGVyYXRvcjMzIDogX2l0ZXJhdG9yMzNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICAgIHZhciBfcmVmMzI7XHJcblxyXG4gICAgICAgICAgaWYgKF9pc0FycmF5MzMpIHtcclxuICAgICAgICAgICAgaWYgKF9pMzUgPj0gX2l0ZXJhdG9yMzMubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgICAgX3JlZjMyID0gX2l0ZXJhdG9yMzNbX2kzNSsrXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9pMzUgPSBfaXRlcmF0b3IzMy5uZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChfaTM1LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgICBfcmVmMzIgPSBfaTM1LnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBlbCA9IF9yZWYzMjtcclxuXHJcbiAgICAgICAgICBpZiAoLyhefCApZHJvcHpvbmUoJHwgKS8udGVzdChlbC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRyb3B6b25lcy5wdXNoKGVsKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KCk7XHJcbiAgICB9O1xyXG4gICAgY2hlY2tFbGVtZW50cyhkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSk7XHJcbiAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZm9ybVwiKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMzQgPSBkcm9wem9uZXMsIF9pc0FycmF5MzQgPSB0cnVlLCBfaTM2ID0gMCwgX2l0ZXJhdG9yMzQgPSBfaXNBcnJheTM0ID8gX2l0ZXJhdG9yMzQgOiBfaXRlcmF0b3IzNFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICB2YXIgX3JlZjMzO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5MzQpIHtcclxuICAgICAgICBpZiAoX2kzNiA+PSBfaXRlcmF0b3IzNC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYzMyA9IF9pdGVyYXRvcjM0W19pMzYrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kzNiA9IF9pdGVyYXRvcjM0Lm5leHQoKTtcclxuICAgICAgICBpZiAoX2kzNi5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmMzMgPSBfaTM2LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZHJvcHpvbmUgPSBfcmVmMzM7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSBkcm9wem9uZSB1bmxlc3MgYXV0byBkaXNjb3ZlciBoYXMgYmVlbiBkaXNhYmxlZCBmb3Igc3BlY2lmaWMgZWxlbWVudFxyXG4gICAgICBpZiAoRHJvcHpvbmUub3B0aW9uc0ZvckVsZW1lbnQoZHJvcHpvbmUpICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEcm9wem9uZShkcm9wem9uZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSgpO1xyXG59O1xyXG5cclxuLy8gU2luY2UgdGhlIHdob2xlIERyYWcnbidEcm9wIEFQSSBpcyBwcmV0dHkgbmV3LCBzb21lIGJyb3dzZXJzIGltcGxlbWVudCBpdCxcclxuLy8gYnV0IG5vdCBjb3JyZWN0bHkuXHJcbi8vIFNvIEkgY3JlYXRlZCBhIGJsYWNrbGlzdCBvZiB1c2VyQWdlbnRzLiBZZXMsIHllcy4gQnJvd3NlciBzbmlmZmluZywgSSBrbm93LlxyXG4vLyBCdXQgd2hhdCB0byBkbyB3aGVuIGJyb3dzZXJzICp0aGVvcmV0aWNhbGx5KiBzdXBwb3J0IGFuIEFQSSwgYnV0IGNyYXNoXHJcbi8vIHdoZW4gdXNpbmcgaXQuXHJcbi8vXHJcbi8vIFRoaXMgaXMgYSBsaXN0IG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGVzdGVkIGFnYWluc3QgbmF2aWdhdG9yLnVzZXJBZ2VudFxyXG4vL1xyXG4vLyAqKiBJdCBzaG91bGQgb25seSBiZSB1c2VkIG9uIGJyb3dzZXIgdGhhdCAqZG8qIHN1cHBvcnQgdGhlIEFQSSwgYnV0XHJcbi8vIGluY29ycmVjdGx5ICoqXHJcbi8vXHJcbkRyb3B6b25lLmJsYWNrbGlzdGVkQnJvd3NlcnMgPSBbXHJcbi8vIFRoZSBtYWMgb3MgYW5kIHdpbmRvd3MgcGhvbmUgdmVyc2lvbiBvZiBvcGVyYSAxMiBzZWVtcyB0byBoYXZlIGEgcHJvYmxlbSB3aXRoIHRoZSBGaWxlIGRyYWcnbidkcm9wIEFQSS5cclxuL29wZXJhLiooTWFjaW50b3NofFdpbmRvd3MgUGhvbmUpLip2ZXJzaW9uXFwvMTIvaV07XHJcblxyXG4vLyBDaGVja3MgaWYgdGhlIGJyb3dzZXIgaXMgc3VwcG9ydGVkXHJcbkRyb3B6b25lLmlzQnJvd3NlclN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY2FwYWJsZUJyb3dzZXIgPSB0cnVlO1xyXG5cclxuICBpZiAod2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5Gb3JtRGF0YSAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XHJcbiAgICBpZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKSkge1xyXG4gICAgICBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSSwgYnV0IG1heSBiZSBibGFja2xpc3RlZC5cclxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMzUgPSBEcm9wem9uZS5ibGFja2xpc3RlZEJyb3dzZXJzLCBfaXNBcnJheTM1ID0gdHJ1ZSwgX2kzNyA9IDAsIF9pdGVyYXRvcjM1ID0gX2lzQXJyYXkzNSA/IF9pdGVyYXRvcjM1IDogX2l0ZXJhdG9yMzVbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjM0O1xyXG5cclxuICAgICAgICBpZiAoX2lzQXJyYXkzNSkge1xyXG4gICAgICAgICAgaWYgKF9pMzcgPj0gX2l0ZXJhdG9yMzUubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIF9yZWYzNCA9IF9pdGVyYXRvcjM1W19pMzcrK107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9pMzcgPSBfaXRlcmF0b3IzNS5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kzNy5kb25lKSBicmVhaztcclxuICAgICAgICAgIF9yZWYzNCA9IF9pMzcudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVnZXggPSBfcmVmMzQ7XHJcblxyXG4gICAgICAgIGlmIChyZWdleC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgICBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhcGFibGVCcm93c2VyID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2FwYWJsZUJyb3dzZXI7XHJcbn07XHJcblxyXG5Ecm9wem9uZS5kYXRhVVJJdG9CbG9iID0gZnVuY3Rpb24gKGRhdGFVUkkpIHtcclxuICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZ1xyXG4gIC8vIGRvZXNuJ3QgaGFuZGxlIFVSTEVuY29kZWQgRGF0YVVSSXMgLSBzZWUgU08gYW5zd2VyICM2ODUwMjc2IGZvciBjb2RlIHRoYXQgZG9lcyB0aGlzXHJcbiAgdmFyIGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkkuc3BsaXQoJywnKVsxXSk7XHJcblxyXG4gIC8vIHNlcGFyYXRlIG91dCB0aGUgbWltZSBjb21wb25lbnRcclxuICB2YXIgbWltZVN0cmluZyA9IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XHJcblxyXG4gIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXHJcbiAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcclxuICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShhYik7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGVuZCA9IGJ5dGVTdHJpbmcubGVuZ3RoLCBhc2MgPSAwIDw9IGVuZDsgYXNjID8gaSA8PSBlbmQgOiBpID49IGVuZDsgYXNjID8gaSsrIDogaS0tKSB7XHJcbiAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICB9XHJcblxyXG4gIC8vIHdyaXRlIHRoZSBBcnJheUJ1ZmZlciB0byBhIGJsb2JcclxuICByZXR1cm4gbmV3IEJsb2IoW2FiXSwgeyB0eXBlOiBtaW1lU3RyaW5nIH0pO1xyXG59O1xyXG5cclxuLy8gUmV0dXJucyBhbiBhcnJheSB3aXRob3V0IHRoZSByZWplY3RlZCBpdGVtXHJcbnZhciB3aXRob3V0ID0gZnVuY3Rpb24gd2l0aG91dChsaXN0LCByZWplY3RlZEl0ZW0pIHtcclxuICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHJldHVybiBpdGVtICE9PSByZWplY3RlZEl0ZW07XHJcbiAgfSkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9KTtcclxufTtcclxuXHJcbi8vIGFiYy1kZWZfZ2hpIC0+IGFiY0RlZkdoaVxyXG52YXIgY2FtZWxpemUgPSBmdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcclxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1fXShcXHcpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgcmV0dXJuIG1hdGNoLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLy8gQ3JlYXRlcyBhbiBlbGVtZW50IGZyb20gc3RyaW5nXHJcbkRyb3B6b25lLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgZGl2LmlubmVySFRNTCA9IHN0cmluZztcclxuICByZXR1cm4gZGl2LmNoaWxkTm9kZXNbMF07XHJcbn07XHJcblxyXG4vLyBUZXN0cyBpZiBnaXZlbiBlbGVtZW50IGlzIGluc2lkZSAob3Igc2ltcGx5IGlzKSB0aGUgY29udGFpbmVyXHJcbkRyb3B6b25lLmVsZW1lbnRJbnNpZGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyKSB7XHJcbiAgaWYgKGVsZW1lbnQgPT09IGNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBDb2ZmZWVzY3JpcHQgZG9lc24ndCBzdXBwb3J0IGRvL3doaWxlIGxvb3BzXHJcbiAgd2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpIHtcclxuICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkRyb3B6b25lLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcclxuICBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgfSBlbHNlIGlmIChlbC5ub2RlVHlwZSAhPSBudWxsKSB7XHJcbiAgICBlbGVtZW50ID0gZWw7XHJcbiAgfVxyXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYFwiICsgbmFtZSArIFwiYCBvcHRpb24gcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIGEgQ1NTIHNlbGVjdG9yIG9yIGEgcGxhaW4gSFRNTCBlbGVtZW50LlwiKTtcclxuICB9XHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5Ecm9wem9uZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbHMsIG5hbWUpIHtcclxuICB2YXIgZWwgPSB2b2lkIDAsXHJcbiAgICAgIGVsZW1lbnRzID0gdm9pZCAwO1xyXG4gIGlmIChlbHMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgZWxlbWVudHMgPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjM2ID0gZWxzLCBfaXNBcnJheTM2ID0gdHJ1ZSwgX2kzOCA9IDAsIF9pdGVyYXRvcjM2ID0gX2lzQXJyYXkzNiA/IF9pdGVyYXRvcjM2IDogX2l0ZXJhdG9yMzZbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICBpZiAoX2lzQXJyYXkzNikge1xyXG4gICAgICAgICAgaWYgKF9pMzggPj0gX2l0ZXJhdG9yMzYubGVuZ3RoKSBicmVhaztcclxuICAgICAgICAgIGVsID0gX2l0ZXJhdG9yMzZbX2kzOCsrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX2kzOCA9IF9pdGVyYXRvcjM2Lm5leHQoKTtcclxuICAgICAgICAgIGlmIChfaTM4LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgZWwgPSBfaTM4LnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmdldEVsZW1lbnQoZWwsIG5hbWUpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlbGVtZW50cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBlbGVtZW50cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMzcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVscyksIF9pc0FycmF5MzcgPSB0cnVlLCBfaTM5ID0gMCwgX2l0ZXJhdG9yMzcgPSBfaXNBcnJheTM3ID8gX2l0ZXJhdG9yMzcgOiBfaXRlcmF0b3IzN1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICBpZiAoX2lzQXJyYXkzNykge1xyXG4gICAgICAgIGlmIChfaTM5ID49IF9pdGVyYXRvcjM3Lmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgZWwgPSBfaXRlcmF0b3IzN1tfaTM5KytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pMzkgPSBfaXRlcmF0b3IzNy5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pMzkuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgZWwgPSBfaTM5LnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50cy5wdXNoKGVsKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGVscy5ub2RlVHlwZSAhPSBudWxsKSB7XHJcbiAgICBlbGVtZW50cyA9IFtlbHNdO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVsZW1lbnRzID09IG51bGwgfHwgIWVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgXCIgKyBuYW1lICsgXCJgIG9wdGlvbiBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgYSBDU1Mgc2VsZWN0b3IsIGEgcGxhaW4gSFRNTCBlbGVtZW50IG9yIGEgbGlzdCBvZiB0aG9zZS5cIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudHM7XHJcbn07XHJcblxyXG4vLyBBc2tzIHRoZSB1c2VyIHRoZSBxdWVzdGlvbiBhbmQgY2FsbHMgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYWNjb3JkaW5nbHlcclxuLy9cclxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCB1c2VzIGB3aW5kb3cuY29uZmlybWAgYW5kIHRoZW4gY2FsbHMgdGhlXHJcbi8vIGFwcHJvcHJpYXRlIGNhbGxiYWNrLlxyXG5Ecm9wem9uZS5jb25maXJtID0gZnVuY3Rpb24gKHF1ZXN0aW9uLCBhY2NlcHRlZCwgcmVqZWN0ZWQpIHtcclxuICBpZiAod2luZG93LmNvbmZpcm0ocXVlc3Rpb24pKSB7XHJcbiAgICByZXR1cm4gYWNjZXB0ZWQoKTtcclxuICB9IGVsc2UgaWYgKHJlamVjdGVkICE9IG51bGwpIHtcclxuICAgIHJldHVybiByZWplY3RlZCgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFZhbGlkYXRlcyB0aGUgbWltZSB0eXBlIGxpa2UgdGhpczpcclxuLy9cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci1hY2NlcHRcclxuRHJvcHpvbmUuaXNWYWxpZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgYWNjZXB0ZWRGaWxlcykge1xyXG4gIGlmICghYWNjZXB0ZWRGaWxlcykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSAvLyBJZiB0aGVyZSBhcmUgbm8gYWNjZXB0ZWQgbWltZSB0eXBlcywgaXQncyBPS1xyXG4gIGFjY2VwdGVkRmlsZXMgPSBhY2NlcHRlZEZpbGVzLnNwbGl0KFwiLFwiKTtcclxuXHJcbiAgdmFyIG1pbWVUeXBlID0gZmlsZS50eXBlO1xyXG4gIHZhciBiYXNlTWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC9cXC8uKiQvLCBcIlwiKTtcclxuXHJcbiAgZm9yICh2YXIgX2l0ZXJhdG9yMzggPSBhY2NlcHRlZEZpbGVzLCBfaXNBcnJheTM4ID0gdHJ1ZSwgX2k0MCA9IDAsIF9pdGVyYXRvcjM4ID0gX2lzQXJyYXkzOCA/IF9pdGVyYXRvcjM4IDogX2l0ZXJhdG9yMzhbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgIHZhciBfcmVmMzU7XHJcblxyXG4gICAgaWYgKF9pc0FycmF5MzgpIHtcclxuICAgICAgaWYgKF9pNDAgPj0gX2l0ZXJhdG9yMzgubGVuZ3RoKSBicmVhaztcclxuICAgICAgX3JlZjM1ID0gX2l0ZXJhdG9yMzhbX2k0MCsrXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9pNDAgPSBfaXRlcmF0b3IzOC5uZXh0KCk7XHJcbiAgICAgIGlmIChfaTQwLmRvbmUpIGJyZWFrO1xyXG4gICAgICBfcmVmMzUgPSBfaTQwLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YWxpZFR5cGUgPSBfcmVmMzU7XHJcblxyXG4gICAgdmFsaWRUeXBlID0gdmFsaWRUeXBlLnRyaW0oKTtcclxuICAgIGlmICh2YWxpZFR5cGUuY2hhckF0KDApID09PSBcIi5cIikge1xyXG4gICAgICBpZiAoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxpZFR5cGUudG9Mb3dlckNhc2UoKSwgZmlsZS5uYW1lLmxlbmd0aCAtIHZhbGlkVHlwZS5sZW5ndGgpICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKC9cXC9cXCokLy50ZXN0KHZhbGlkVHlwZSkpIHtcclxuICAgICAgLy8gVGhpcyBpcyBzb21ldGhpbmcgbGlrZSBhIGltYWdlLyogbWltZSB0eXBlXHJcbiAgICAgIGlmIChiYXNlTWltZVR5cGUgPT09IHZhbGlkVHlwZS5yZXBsYWNlKC9cXC8uKiQvLCBcIlwiKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobWltZVR5cGUgPT09IHZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vLyBBdWdtZW50IGpRdWVyeVxyXG5pZiAodHlwZW9mIGpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgalF1ZXJ5ICE9PSBudWxsKSB7XHJcbiAgalF1ZXJ5LmZuLmRyb3B6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IERyb3B6b25lKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAhPT0gbnVsbCkge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRHJvcHpvbmU7XHJcbn0gZWxzZSB7XHJcbiAgd2luZG93LkRyb3B6b25lID0gRHJvcHpvbmU7XHJcbn1cclxuXHJcbi8vIERyb3B6b25lIGZpbGUgc3RhdHVzIGNvZGVzXHJcbkRyb3B6b25lLkFEREVEID0gXCJhZGRlZFwiO1xyXG5cclxuRHJvcHpvbmUuUVVFVUVEID0gXCJxdWV1ZWRcIjtcclxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBOb3csIGlmIGEgZmlsZSBpcyBhY2NlcHRlZCwgaXQncyBlaXRoZXIgcXVldWVkXHJcbi8vIG9yIHVwbG9hZGluZy5cclxuRHJvcHpvbmUuQUNDRVBURUQgPSBEcm9wem9uZS5RVUVVRUQ7XHJcblxyXG5Ecm9wem9uZS5VUExPQURJTkcgPSBcInVwbG9hZGluZ1wiO1xyXG5Ecm9wem9uZS5QUk9DRVNTSU5HID0gRHJvcHpvbmUuVVBMT0FESU5HOyAvLyBhbGlhc1xyXG5cclxuRHJvcHpvbmUuQ0FOQ0VMRUQgPSBcImNhbmNlbGVkXCI7XHJcbkRyb3B6b25lLkVSUk9SID0gXCJlcnJvclwiO1xyXG5Ecm9wem9uZS5TVUNDRVNTID0gXCJzdWNjZXNzXCI7XHJcblxyXG4vKlxyXG5cclxuIEJ1Z2ZpeCBmb3IgaU9TIDYgYW5kIDdcclxuIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTkyOTA5OS9odG1sNS1jYW52YXMtZHJhd2ltYWdlLXJhdGlvLWJ1Zy1pb3NcclxuIGJhc2VkIG9uIHRoZSB3b3JrIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9zdG9taXRhL2lvcy1pbWFnZWZpbGUtbWVnYXBpeGVsXHJcblxyXG4gKi9cclxuXHJcbi8vIERldGVjdGluZyB2ZXJ0aWNhbCBzcXVhc2ggaW4gbG9hZGVkIGltYWdlLlxyXG4vLyBGaXhlcyBhIGJ1ZyB3aGljaCBzcXVhc2ggaW1hZ2UgdmVydGljYWxseSB3aGlsZSBkcmF3aW5nIGludG8gY2FudmFzIGZvciBzb21lIGltYWdlcy5cclxuLy8gVGhpcyBpcyBhIGJ1ZyBpbiBpT1M2IGRldmljZXMuIFRoaXMgZnVuY3Rpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3RvbWl0YS9pb3MtaW1hZ2VmaWxlLW1lZ2FwaXhlbFxyXG52YXIgZGV0ZWN0VmVydGljYWxTcXVhc2ggPSBmdW5jdGlvbiBkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcpIHtcclxuICB2YXIgaXcgPSBpbWcubmF0dXJhbFdpZHRoO1xyXG4gIHZhciBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0O1xyXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gIGNhbnZhcy53aWR0aCA9IDE7XHJcbiAgY2FudmFzLmhlaWdodCA9IGloO1xyXG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcclxuXHJcbiAgdmFyIF9jdHgkZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgxLCAwLCAxLCBpaCksXHJcbiAgICAgIGRhdGEgPSBfY3R4JGdldEltYWdlRGF0YS5kYXRhO1xyXG5cclxuICAvLyBzZWFyY2ggaW1hZ2UgZWRnZSBwaXhlbCBwb3NpdGlvbiBpbiBjYXNlIGl0IGlzIHNxdWFzaGVkIHZlcnRpY2FsbHkuXHJcblxyXG5cclxuICB2YXIgc3kgPSAwO1xyXG4gIHZhciBleSA9IGloO1xyXG4gIHZhciBweSA9IGloO1xyXG4gIHdoaWxlIChweSA+IHN5KSB7XHJcbiAgICB2YXIgYWxwaGEgPSBkYXRhWyhweSAtIDEpICogNCArIDNdO1xyXG5cclxuICAgIGlmIChhbHBoYSA9PT0gMCkge1xyXG4gICAgICBleSA9IHB5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3kgPSBweTtcclxuICAgIH1cclxuXHJcbiAgICBweSA9IGV5ICsgc3kgPj4gMTtcclxuICB9XHJcbiAgdmFyIHJhdGlvID0gcHkgLyBpaDtcclxuXHJcbiAgaWYgKHJhdGlvID09PSAwKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHJhdGlvO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEEgcmVwbGFjZW1lbnQgZm9yIGNvbnRleHQuZHJhd0ltYWdlXHJcbi8vIChhcmdzIGFyZSBmb3Igc291cmNlIGFuZCBkZXN0aW5hdGlvbikuXHJcbnZhciBkcmF3SW1hZ2VJT1NGaXggPSBmdW5jdGlvbiBkcmF3SW1hZ2VJT1NGaXgoY3R4LCBpbWcsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHksIGR3LCBkaCkge1xyXG4gIHZhciB2ZXJ0U3F1YXNoUmF0aW8gPSBkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcpO1xyXG4gIHJldHVybiBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoIC8gdmVydFNxdWFzaFJhdGlvKTtcclxufTtcclxuXHJcbi8vIEJhc2VkIG9uIE1pbmlmeUpwZWdcclxuLy8gU291cmNlOiBodHRwOi8vd3d3LnBlcnJ5LmN6L2ZpbGVzL0V4aWZSZXN0b3Jlci5qc1xyXG4vLyBodHRwOi8vZWxpY29uLmJsb2c1Ny5mYzIuY29tL2Jsb2ctZW50cnktMjA2Lmh0bWxcclxuXHJcbnZhciBFeGlmUmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBFeGlmUmVzdG9yZSgpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeGlmUmVzdG9yZSk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoRXhpZlJlc3RvcmUsIG51bGwsIFt7XHJcbiAgICBrZXk6IFwiaW5pdENsYXNzXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENsYXNzKCkge1xyXG4gICAgICB0aGlzLktFWV9TVFIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJlbmNvZGU2NFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZTY0KGlucHV0KSB7XHJcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgICAgdmFyIGNocjEgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBjaHIyID0gdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgY2hyMyA9ICcnO1xyXG4gICAgICB2YXIgZW5jMSA9IHVuZGVmaW5lZDtcclxuICAgICAgdmFyIGVuYzIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBlbmMzID0gdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgZW5jNCA9ICcnO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY2hyMSA9IGlucHV0W2krK107XHJcbiAgICAgICAgY2hyMiA9IGlucHV0W2krK107XHJcbiAgICAgICAgY2hyMyA9IGlucHV0W2krK107XHJcbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcclxuICAgICAgICBlbmMyID0gKGNocjEgJiAzKSA8PCA0IHwgY2hyMiA+PiA0O1xyXG4gICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xyXG4gICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XHJcbiAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XHJcbiAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcclxuICAgICAgICAgIGVuYzQgPSA2NDtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMxKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMikgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzMpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmM0KTtcclxuICAgICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSAnJztcclxuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XHJcbiAgICAgICAgaWYgKCEoaSA8IGlucHV0Lmxlbmd0aCkpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJyZXN0b3JlXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZShvcmlnRmlsZUJhc2U2NCwgcmVzaXplZEZpbGVCYXNlNjQpIHtcclxuICAgICAgaWYgKCFvcmlnRmlsZUJhc2U2NC5tYXRjaCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnKSkge1xyXG4gICAgICAgIHJldHVybiByZXNpemVkRmlsZUJhc2U2NDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmF3SW1hZ2UgPSB0aGlzLmRlY29kZTY0KG9yaWdGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpKTtcclxuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zbGljZTJTZWdtZW50cyhyYXdJbWFnZSk7XHJcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuZXhpZk1hbmlwdWxhdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpO1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiICsgdGhpcy5lbmNvZGU2NChpbWFnZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImV4aWZNYW5pcHVsYXRpb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGlmTWFuaXB1bGF0aW9uKHJlc2l6ZWRGaWxlQmFzZTY0LCBzZWdtZW50cykge1xyXG4gICAgICB2YXIgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpO1xyXG4gICAgICB2YXIgbmV3SW1hZ2VBcnJheSA9IHRoaXMuaW5zZXJ0RXhpZihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KTtcclxuICAgICAgdmFyIGFCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdJbWFnZUFycmF5KTtcclxuICAgICAgcmV0dXJuIGFCdWZmZXI7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldEV4aWZBcnJheVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aWZBcnJheShzZWdtZW50cykge1xyXG4gICAgICB2YXIgc2VnID0gdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgeCA9IDA7XHJcbiAgICAgIHdoaWxlICh4IDwgc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc2VnID0gc2VnbWVudHNbeF07XHJcbiAgICAgICAgaWYgKHNlZ1swXSA9PT0gMjU1ICYgc2VnWzFdID09PSAyMjUpIHtcclxuICAgICAgICAgIHJldHVybiBzZWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHgrKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImluc2VydEV4aWZcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpIHtcclxuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlc2l6ZWRGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpO1xyXG4gICAgICB2YXIgYnVmID0gdGhpcy5kZWNvZGU2NChpbWFnZURhdGEpO1xyXG4gICAgICB2YXIgc2VwYXJhdGVQb2ludCA9IGJ1Zi5pbmRleE9mKDI1NSwgMyk7XHJcbiAgICAgIHZhciBtYWUgPSBidWYuc2xpY2UoMCwgc2VwYXJhdGVQb2ludCk7XHJcbiAgICAgIHZhciBhdG8gPSBidWYuc2xpY2Uoc2VwYXJhdGVQb2ludCk7XHJcbiAgICAgIHZhciBhcnJheSA9IG1hZTtcclxuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZXhpZkFycmF5KTtcclxuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoYXRvKTtcclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJzbGljZTJTZWdtZW50c1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlQXJyYXkpIHtcclxuICAgICAgdmFyIGhlYWQgPSAwO1xyXG4gICAgICB2YXIgc2VnbWVudHMgPSBbXTtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoO1xyXG4gICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PT0gMjE4KSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTYpIHtcclxuICAgICAgICAgIGhlYWQgKz0gMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGVuZ3RoID0gcmF3SW1hZ2VBcnJheVtoZWFkICsgMl0gKiAyNTYgKyByYXdJbWFnZUFycmF5W2hlYWQgKyAzXTtcclxuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGhlYWQgKyBsZW5ndGggKyAyO1xyXG4gICAgICAgICAgdmFyIHNlZyA9IHJhd0ltYWdlQXJyYXkuc2xpY2UoaGVhZCwgZW5kUG9pbnQpO1xyXG4gICAgICAgICAgc2VnbWVudHMucHVzaChzZWcpO1xyXG4gICAgICAgICAgaGVhZCA9IGVuZFBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGVhZCA+IHJhd0ltYWdlQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlZ21lbnRzO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJkZWNvZGU2NFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZTY0KGlucHV0KSB7XHJcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgICAgdmFyIGNocjEgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBjaHIyID0gdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgY2hyMyA9ICcnO1xyXG4gICAgICB2YXIgZW5jMSA9IHVuZGVmaW5lZDtcclxuICAgICAgdmFyIGVuYzIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciBlbmMzID0gdW5kZWZpbmVkO1xyXG4gICAgICB2YXIgZW5jNCA9ICcnO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBidWYgPSBbXTtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XHJcbiAgICAgIHZhciBiYXNlNjR0ZXN0ID0gL1teQS1aYS16MC05XFwrXFwvXFw9XS9nO1xyXG4gICAgICBpZiAoYmFzZTY0dGVzdC5leGVjKGlucHV0KSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LlxcblZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCBcXCcrXFwnLCBcXCcvXFwnLGFuZCBcXCc9XFwnXFxuRXhwZWN0IGVycm9ycyBpbiBkZWNvZGluZy4nKTtcclxuICAgICAgfVxyXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgZW5jMSA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBlbmMyID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xyXG4gICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XHJcbiAgICAgICAgZW5jNCA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xyXG4gICAgICAgIGNocjIgPSAoZW5jMiAmIDE1KSA8PCA0IHwgZW5jMyA+PiAyO1xyXG4gICAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xyXG4gICAgICAgIGJ1Zi5wdXNoKGNocjEpO1xyXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xyXG4gICAgICAgICAgYnVmLnB1c2goY2hyMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xyXG4gICAgICAgICAgYnVmLnB1c2goY2hyMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xyXG4gICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcclxuICAgICAgICBpZiAoIShpIDwgaW5wdXQubGVuZ3RoKSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBidWY7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gRXhpZlJlc3RvcmU7XHJcbn0oKTtcclxuXHJcbkV4aWZSZXN0b3JlLmluaXRDbGFzcygpO1xyXG5cclxuLypcclxuICogY29udGVudGxvYWRlZC5qc1xyXG4gKlxyXG4gKiBBdXRob3I6IERpZWdvIFBlcmluaSAoZGllZ28ucGVyaW5pIGF0IGdtYWlsLmNvbSlcclxuICogU3VtbWFyeTogY3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBET01Db250ZW50TG9hZGVkXHJcbiAqIFVwZGF0ZWQ6IDIwMTAxMDIwXHJcbiAqIExpY2Vuc2U6IE1JVFxyXG4gKiBWZXJzaW9uOiAxLjJcclxuICpcclxuICogVVJMOlxyXG4gKiBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vQ29udGVudExvYWRlZC9cclxuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvTUlULUxJQ0VOU0VcclxuICovXHJcblxyXG4vLyBAd2luIHdpbmRvdyByZWZlcmVuY2VcclxuLy8gQGZuIGZ1bmN0aW9uIHJlZmVyZW5jZVxyXG52YXIgY29udGVudExvYWRlZCA9IGZ1bmN0aW9uIGNvbnRlbnRMb2FkZWQod2luLCBmbikge1xyXG4gIHZhciBkb25lID0gZmFsc2U7XHJcbiAgdmFyIHRvcCA9IHRydWU7XHJcbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcclxuICB2YXIgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgdmFyIGFkZCA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcImF0dGFjaEV2ZW50XCI7XHJcbiAgdmFyIHJlbSA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgOiBcImRldGFjaEV2ZW50XCI7XHJcbiAgdmFyIHByZSA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJcIiA6IFwib25cIjtcclxuICB2YXIgaW5pdCA9IGZ1bmN0aW9uIGluaXQoZSkge1xyXG4gICAgaWYgKGUudHlwZSA9PT0gXCJyZWFkeXN0YXRlY2hhbmdlXCIgJiYgZG9jLnJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAoZS50eXBlID09PSBcImxvYWRcIiA/IHdpbiA6IGRvYylbcmVtXShwcmUgKyBlLnR5cGUsIGluaXQsIGZhbHNlKTtcclxuICAgIGlmICghZG9uZSAmJiAoZG9uZSA9IHRydWUpKSB7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHdpbiwgZS50eXBlIHx8IGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBwb2xsID0gZnVuY3Rpb24gcG9sbCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJvb3QuZG9TY3JvbGwoXCJsZWZ0XCIpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBzZXRUaW1lb3V0KHBvbGwsIDUwKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluaXQoXCJwb2xsXCIpO1xyXG4gIH07XHJcblxyXG4gIGlmIChkb2MucmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XHJcbiAgICBpZiAoZG9jLmNyZWF0ZUV2ZW50T2JqZWN0ICYmIHJvb3QuZG9TY3JvbGwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0b3AgPSAhd2luLmZyYW1lRWxlbWVudDtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XHJcbiAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICBwb2xsKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGRvY1thZGRdKHByZSArIFwiRE9NQ29udGVudExvYWRlZFwiLCBpbml0LCBmYWxzZSk7XHJcbiAgICBkb2NbYWRkXShwcmUgKyBcInJlYWR5c3RhdGVjaGFuZ2VcIiwgaW5pdCwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIHdpblthZGRdKHByZSArIFwibG9hZFwiLCBpbml0LCBmYWxzZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQXMgYSBzaW5nbGUgZnVuY3Rpb24gdG8gYmUgYWJsZSB0byB3cml0ZSB0ZXN0cy5cclxuRHJvcHpvbmUuX2F1dG9EaXNjb3ZlckZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmIChEcm9wem9uZS5hdXRvRGlzY292ZXIpIHtcclxuICAgIHJldHVybiBEcm9wem9uZS5kaXNjb3ZlcigpO1xyXG4gIH1cclxufTtcclxuY29udGVudExvYWRlZCh3aW5kb3csIERyb3B6b25lLl9hdXRvRGlzY292ZXJGdW5jdGlvbik7XHJcblxyXG5mdW5jdGlvbiBfX2d1YXJkX18odmFsdWUsIHRyYW5zZm9ybSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsID8gdHJhbnNmb3JtKHZhbHVlKSA6IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBfX2d1YXJkTWV0aG9kX18ob2JqLCBtZXRob2ROYW1lLCB0cmFuc2Zvcm0pIHtcclxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmpbbWV0aG9kTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm0ob2JqLCBtZXRob2ROYW1lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./Modules/Galleries/node_modules/dropzone/dist/dropzone.js\n");

/***/ }),

/***/ "./Modules/Galleries/Resources/assets/admin/js/ImagePicker.js":
/*!********************************************************************!*\
  !*** ./Modules/Galleries/Resources/assets/admin/js/ImagePicker.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _default)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// import GalleriesPicker from './GalleriesPicker';\nvar _default = /*#__PURE__*/function () {\n  function _default() {\n    var _this = this;\n    _classCallCheck(this, _default);\n    $('.image-picker').on('click', function (e) {\n      _this.pickImage(e);\n    });\n    this.sortable();\n    this.removeImageEventListener();\n  }\n  _createClass(_default, [{\n    key: \"pickImage\",\n    value: function pickImage(e) {\n      var _this2 = this;\n      var inputName = e.currentTarget.dataset.inputName;\n      var multiple = e.currentTarget.hasAttribute('data-multiple');\n      var picker = new GalleriesPicker({\n        type: 'image',\n        multiple: multiple\n      });\n      picker.on('select', function (file) {\n        _this2.addImage(inputName, file, multiple, e.currentTarget);\n      });\n    }\n  }, {\n    key: \"addImage\",\n    value: function addImage(inputName, file, multiple, target) {\n      var html = this.getTemplate(inputName, file);\n      if (multiple) {\n        var multipleImagesWrapper = $(target).next('.multiple-images');\n        multipleImagesWrapper.find('.image-holder.placeholder').remove();\n        multipleImagesWrapper.find('.image-list').append(html);\n      } else {\n        $(target).siblings('.single-image').html(html);\n      }\n    }\n  }, {\n    key: \"getTemplate\",\n    value: function getTemplate(inputName, file) {\n      return $(\"\\n            <div class=\\\"image-holder\\\">\\n                <img src=\\\"\".concat(file.path, \"\\\">\\n                <button type=\\\"button\\\" class=\\\"btn remove-image\\\"></button>\\n                <input type=\\\"hidden\\\" name=\\\"\").concat(inputName, \"\\\" value=\\\"\").concat(file.id, \"\\\">\\n            </div>\\n        \"));\n    }\n  }, {\n    key: \"sortable\",\n    value: function sortable() {\n      var imageList = $('.image-list');\n      if (imageList.length > 0) {\n        Sortable.create(imageList[0], {\n          animation: 150\n        });\n      }\n    }\n  }, {\n    key: \"removeImageEventListener\",\n    value: function removeImageEventListener() {\n      var _this3 = this;\n      $('.image-holder-wrapper').on('click', '.remove-image', function (e) {\n        e.preventDefault();\n        var imageHolderWrapper = $(e.currentTarget).closest('.image-holder-wrapper');\n        if (imageHolderWrapper.find('.image-holder').length === 1) {\n          imageHolderWrapper.html(_this3.getImagePlaceholder(e.currentTarget.dataset.inputName));\n        }\n        $(e.currentTarget).parent().remove();\n      });\n    }\n  }, {\n    key: \"getImagePlaceholder\",\n    value: function getImagePlaceholder(inputName) {\n      return \"\\n            <div class=\\\"image-holder placeholder cursor-auto\\\">\\n                <i class=\\\"fa fa-picture-o\\\"></i>\\n                <input type=\\\"hidden\\\" name=\\\"\".concat(inputName, \"\\\">\\n            </div>\\n        \");\n    }\n  }]);\n  return _default;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL0dhbGxlcmllcy9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL0ltYWdlUGlja2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBLElBQUFBLFFBQUE7RUFHSSxTQUFBQSxTQUFBLEVBQWM7SUFBQSxJQUFBQyxLQUFBO0lBQUFDLGVBQUEsT0FBQUYsUUFBQTtJQUNWRyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUNDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBQ0MsQ0FBQyxFQUFLO01BQ2xDSixLQUFJLENBQUNLLFNBQVMsQ0FBQ0QsQ0FBQyxDQUFDO0lBQ3JCLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQ0UsUUFBUSxDQUFDLENBQUM7SUFDZixJQUFJLENBQUNDLHdCQUF3QixDQUFDLENBQUM7RUFDbkM7RUFBQ0MsWUFBQSxDQUFBVCxRQUFBO0lBQUFVLEdBQUE7SUFBQUMsS0FBQSxFQUVELFNBQUFMLFVBQVVELENBQUMsRUFBRTtNQUFBLElBQUFPLE1BQUE7TUFDVCxJQUFJQyxTQUFTLEdBQUdSLENBQUMsQ0FBQ1MsYUFBYSxDQUFDQyxPQUFPLENBQUNGLFNBQVM7TUFDakQsSUFBSUcsUUFBUSxHQUFHWCxDQUFDLENBQUNTLGFBQWEsQ0FBQ0csWUFBWSxDQUFDLGVBQWUsQ0FBQztNQUU1RCxJQUFJQyxNQUFNLEdBQUcsSUFBSUMsZUFBZSxDQUFDO1FBQUVDLElBQUksRUFBRSxPQUFPO1FBQUVKLFFBQVEsRUFBUkE7TUFBUyxDQUFDLENBQUM7TUFFN0RFLE1BQU0sQ0FBQ2QsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFDaUIsSUFBSSxFQUFLO1FBQzFCVCxNQUFJLENBQUNVLFFBQVEsQ0FBQ1QsU0FBUyxFQUFFUSxJQUFJLEVBQUVMLFFBQVEsRUFBRVgsQ0FBQyxDQUFDUyxhQUFhLENBQUM7TUFDN0QsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBSixHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBVyxTQUFTVCxTQUFTLEVBQUVRLElBQUksRUFBRUwsUUFBUSxFQUFFTyxNQUFNLEVBQUU7TUFDeEMsSUFBSUMsSUFBSSxHQUFHLElBQUksQ0FBQ0MsV0FBVyxDQUFDWixTQUFTLEVBQUVRLElBQUksQ0FBQztNQUU1QyxJQUFJTCxRQUFRLEVBQUU7UUFDVixJQUFJVSxxQkFBcUIsR0FBR3ZCLENBQUMsQ0FBQ29CLE1BQU0sQ0FBQyxDQUFDSSxJQUFJLENBQUMsa0JBQWtCLENBQUM7UUFFOURELHFCQUFxQixDQUFDRSxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQ0MsTUFBTSxDQUFDLENBQUM7UUFDaEVILHFCQUFxQixDQUFDRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUNFLE1BQU0sQ0FBQ04sSUFBSSxDQUFDO01BQzFELENBQUMsTUFBTTtRQUNIckIsQ0FBQyxDQUFDb0IsTUFBTSxDQUFDLENBQUNRLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQ1AsSUFBSSxDQUFDQSxJQUFJLENBQUM7TUFDbEQ7SUFDSjtFQUFDO0lBQUFkLEdBQUE7SUFBQUMsS0FBQSxFQUVELFNBQUFjLFlBQVlaLFNBQVMsRUFBRVEsSUFBSSxFQUFFO01BQ3pCLE9BQU9sQixDQUFDLDJFQUFBNkIsTUFBQSxDQUVZWCxJQUFJLENBQUNZLElBQUksdUlBQUFELE1BQUEsQ0FFUW5CLFNBQVMsaUJBQUFtQixNQUFBLENBQVlYLElBQUksQ0FBQ2EsRUFBRSxzQ0FFaEUsQ0FBQztJQUNOO0VBQUM7SUFBQXhCLEdBQUE7SUFBQUMsS0FBQSxFQUVELFNBQUFKLFNBQUEsRUFBVztNQUNQLElBQUk0QixTQUFTLEdBQUdoQyxDQUFDLENBQUMsYUFBYSxDQUFDO01BRWhDLElBQUlnQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDdEJDLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDSCxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7VUFBRUksU0FBUyxFQUFFO1FBQUksQ0FBQyxDQUFDO01BQ3JEO0lBQ0o7RUFBQztJQUFBN0IsR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQUgseUJBQUEsRUFBMkI7TUFBQSxJQUFBZ0MsTUFBQTtNQUN2QnJDLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDQyxFQUFFLENBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxVQUFDQyxDQUFDLEVBQUs7UUFDM0RBLENBQUMsQ0FBQ29DLGNBQWMsQ0FBQyxDQUFDO1FBRWxCLElBQUlDLGtCQUFrQixHQUFHdkMsQ0FBQyxDQUFDRSxDQUFDLENBQUNTLGFBQWEsQ0FBQyxDQUFDNkIsT0FBTyxDQUFDLHVCQUF1QixDQUFDO1FBRTVFLElBQUlELGtCQUFrQixDQUFDZCxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUNRLE1BQU0sS0FBSyxDQUFDLEVBQUU7VUFDdkRNLGtCQUFrQixDQUFDbEIsSUFBSSxDQUNuQmdCLE1BQUksQ0FBQ0ksbUJBQW1CLENBQUN2QyxDQUFDLENBQUNTLGFBQWEsQ0FBQ0MsT0FBTyxDQUFDRixTQUFTLENBQzlELENBQUM7UUFDTDtRQUVBVixDQUFDLENBQUNFLENBQUMsQ0FBQ1MsYUFBYSxDQUFDLENBQUMrQixNQUFNLENBQUMsQ0FBQyxDQUFDaEIsTUFBTSxDQUFDLENBQUM7TUFDeEMsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBbkIsR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQWlDLG9CQUFvQi9CLFNBQVMsRUFBRTtNQUMzQiwrS0FBQW1CLE1BQUEsQ0FHcUNuQixTQUFTO0lBR2xEO0VBQUM7RUFBQSxPQUFBYixRQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGVldGNhcnQvLi9Nb2R1bGVzL0dhbGxlcmllcy9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL0ltYWdlUGlja2VyLmpzPzg3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IEdhbGxlcmllc1BpY2tlciBmcm9tICcuL0dhbGxlcmllc1BpY2tlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAkKCcuaW1hZ2UtcGlja2VyJykub24oJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5waWNrSW1hZ2UoZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc29ydGFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUltYWdlRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHBpY2tJbWFnZShlKSB7XHJcbiAgICAgICAgbGV0IGlucHV0TmFtZSA9IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmlucHV0TmFtZTtcclxuICAgICAgICBsZXQgbXVsdGlwbGUgPSBlLmN1cnJlbnRUYXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLW11bHRpcGxlJyk7XHJcblxyXG4gICAgICAgIGxldCBwaWNrZXIgPSBuZXcgR2FsbGVyaWVzUGlja2VyKHsgdHlwZTogJ2ltYWdlJywgbXVsdGlwbGUgfSk7XHJcblxyXG4gICAgICAgIHBpY2tlci5vbignc2VsZWN0JywgKGZpbGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbWFnZShpbnB1dE5hbWUsIGZpbGUsIG11bHRpcGxlLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEltYWdlKGlucHV0TmFtZSwgZmlsZSwgbXVsdGlwbGUsIHRhcmdldCkge1xyXG4gICAgICAgIGxldCBodG1sID0gdGhpcy5nZXRUZW1wbGF0ZShpbnB1dE5hbWUsIGZpbGUpO1xyXG5cclxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgbGV0IG11bHRpcGxlSW1hZ2VzV3JhcHBlciA9ICQodGFyZ2V0KS5uZXh0KCcubXVsdGlwbGUtaW1hZ2VzJyk7XHJcblxyXG4gICAgICAgICAgICBtdWx0aXBsZUltYWdlc1dyYXBwZXIuZmluZCgnLmltYWdlLWhvbGRlci5wbGFjZWhvbGRlcicpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBtdWx0aXBsZUltYWdlc1dyYXBwZXIuZmluZCgnLmltYWdlLWxpc3QnKS5hcHBlbmQoaHRtbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCh0YXJnZXQpLnNpYmxpbmdzKCcuc2luZ2xlLWltYWdlJykuaHRtbChodG1sKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGVtcGxhdGUoaW5wdXROYW1lLCBmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuICQoYFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW1hZ2UtaG9sZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7ZmlsZS5wYXRofVwiPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gcmVtb3ZlLWltYWdlXCI+PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCIke2lucHV0TmFtZX1cIiB2YWx1ZT1cIiR7ZmlsZS5pZH1cIj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYCk7XHJcbiAgICB9XHJcblxyXG4gICAgc29ydGFibGUoKSB7XHJcbiAgICAgICAgbGV0IGltYWdlTGlzdCA9ICQoJy5pbWFnZS1saXN0Jyk7XHJcblxyXG4gICAgICAgIGlmIChpbWFnZUxpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBTb3J0YWJsZS5jcmVhdGUoaW1hZ2VMaXN0WzBdLCB7IGFuaW1hdGlvbjogMTUwIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVJbWFnZUV2ZW50TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgJCgnLmltYWdlLWhvbGRlci13cmFwcGVyJykub24oJ2NsaWNrJywgJy5yZW1vdmUtaW1hZ2UnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaW1hZ2VIb2xkZXJXcmFwcGVyID0gJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJy5pbWFnZS1ob2xkZXItd3JhcHBlcicpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGltYWdlSG9sZGVyV3JhcHBlci5maW5kKCcuaW1hZ2UtaG9sZGVyJykubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZUhvbGRlcldyYXBwZXIuaHRtbChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlUGxhY2Vob2xkZXIoZS5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaW5wdXROYW1lKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudCgpLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEltYWdlUGxhY2Vob2xkZXIoaW5wdXROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImltYWdlLWhvbGRlciBwbGFjZWhvbGRlciBjdXJzb3ItYXV0b1wiPlxyXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1waWN0dXJlLW9cIj48L2k+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCIke2lucHV0TmFtZX1cIj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJfdGhpcyIsIl9jbGFzc0NhbGxDaGVjayIsIiQiLCJvbiIsImUiLCJwaWNrSW1hZ2UiLCJzb3J0YWJsZSIsInJlbW92ZUltYWdlRXZlbnRMaXN0ZW5lciIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiX3RoaXMyIiwiaW5wdXROYW1lIiwiY3VycmVudFRhcmdldCIsImRhdGFzZXQiLCJtdWx0aXBsZSIsImhhc0F0dHJpYnV0ZSIsInBpY2tlciIsIkdhbGxlcmllc1BpY2tlciIsInR5cGUiLCJmaWxlIiwiYWRkSW1hZ2UiLCJ0YXJnZXQiLCJodG1sIiwiZ2V0VGVtcGxhdGUiLCJtdWx0aXBsZUltYWdlc1dyYXBwZXIiLCJuZXh0IiwiZmluZCIsInJlbW92ZSIsImFwcGVuZCIsInNpYmxpbmdzIiwiY29uY2F0IiwicGF0aCIsImlkIiwiaW1hZ2VMaXN0IiwibGVuZ3RoIiwiU29ydGFibGUiLCJjcmVhdGUiLCJhbmltYXRpb24iLCJfdGhpczMiLCJwcmV2ZW50RGVmYXVsdCIsImltYWdlSG9sZGVyV3JhcHBlciIsImNsb3Nlc3QiLCJnZXRJbWFnZVBsYWNlaG9sZGVyIiwicGFyZW50IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Galleries/Resources/assets/admin/js/ImagePicker.js\n");

/***/ }),

/***/ "./Modules/Galleries/Resources/assets/admin/js/Uploader.js":
/*!*****************************************************************!*\
  !*** ./Modules/Galleries/Resources/assets/admin/js/Uploader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _default)\n/* harmony export */ });\n/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dropzone */ \"./Modules/Galleries/node_modules/dropzone/dist/dropzone.js\");\n/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dropzone__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar _default = /*#__PURE__*/function () {\n  function _default() {\n    _classCallCheck(this, _default);\n    (dropzone__WEBPACK_IMPORTED_MODULE_0___default().autoDiscover) = false;\n    this.dropzone = new (dropzone__WEBPACK_IMPORTED_MODULE_0___default())('.dropzone', {\n      url: route('admin.galleries.store'),\n      autoProcessQueue: true,\n      maxFilesize: FleetCart.maxFileSize\n    });\n    this.dropzone.on('sending', this.sending);\n    this.dropzone.on('success', this.success);\n    this.dropzone.on('error', this.error);\n  }\n  _createClass(_default, [{\n    key: \"sending\",\n    value: function sending(file, xhr) {\n      xhr.timeout = 3600000;\n      $('.alert-danger').remove();\n    }\n  }, {\n    key: \"success\",\n    value: function success() {\n      if (this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0) {\n        setTimeout(DataTable.reload, 1000, '#galleries-table .table');\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(file, response) {\n      $('.dz-progress').css('z-index', 1);\n      $(file.previewElement).find('.dz-error-message').text(response.message);\n    }\n  }]);\n  return _default;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL0dhbGxlcmllcy9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL1VwbG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnQztBQUFBLElBQUFDLFFBQUE7RUFHNUIsU0FBQUEsU0FBQSxFQUFjO0lBQUFDLGVBQUEsT0FBQUQsUUFBQTtJQUNWRCw4REFBcUIsR0FBRyxLQUFLO0lBRTdCLElBQUksQ0FBQ0ksUUFBUSxHQUFHLElBQUlKLGlEQUFRLENBQUMsV0FBVyxFQUFFO01BQ3RDSyxHQUFHLEVBQUVDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQztNQUNuQ0MsZ0JBQWdCLEVBQUUsSUFBSTtNQUN0QkMsV0FBVyxFQUFFQyxTQUFTLENBQUNDO0lBQzNCLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQ04sUUFBUSxDQUFDTyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxDQUFDO0lBQ3pDLElBQUksQ0FBQ1IsUUFBUSxDQUFDTyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ0UsT0FBTyxDQUFDO0lBQ3pDLElBQUksQ0FBQ1QsUUFBUSxDQUFDTyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQ0csS0FBSyxDQUFDO0VBQ3pDO0VBQUNDLFlBQUEsQ0FBQWQsUUFBQTtJQUFBZSxHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBTCxRQUFRTSxJQUFJLEVBQUVDLEdBQUcsRUFBRTtNQUNmQSxHQUFHLENBQUNDLE9BQU8sR0FBRyxPQUFPO01BRXJCQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxDQUFDO0lBQy9CO0VBQUM7SUFBQU4sR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQUosUUFBQSxFQUFVO01BQ04sSUFBSSxJQUFJLENBQUNVLGlCQUFpQixDQUFDLENBQUMsQ0FBQ0MsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQyxDQUFDLENBQUNELE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDN0VFLFVBQVUsQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLEVBQUUsSUFBSSxFQUFFLHlCQUF5QixDQUFDO01BQ2pFO0lBQ0o7RUFBQztJQUFBWixHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBSCxNQUFNSSxJQUFJLEVBQUVXLFFBQVEsRUFBRTtNQUNsQlIsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDUyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztNQUNuQ1QsQ0FBQyxDQUFDSCxJQUFJLENBQUNhLGNBQWMsQ0FBQyxDQUFDQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRLENBQUNLLE9BQU8sQ0FBQztJQUMzRTtFQUFDO0VBQUEsT0FBQWpDLFFBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Y2FydC8uL01vZHVsZXMvR2FsbGVyaWVzL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvVXBsb2FkZXIuanM/ZDhhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRHJvcHpvbmUgZnJvbSAnZHJvcHpvbmUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgRHJvcHpvbmUuYXV0b0Rpc2NvdmVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZHJvcHpvbmUgPSBuZXcgRHJvcHpvbmUoJy5kcm9wem9uZScsIHtcclxuICAgICAgICAgICAgdXJsOiByb3V0ZSgnYWRtaW4uZ2FsbGVyaWVzLnN0b3JlJyksXHJcbiAgICAgICAgICAgIGF1dG9Qcm9jZXNzUXVldWU6IHRydWUsXHJcbiAgICAgICAgICAgIG1heEZpbGVzaXplOiBGbGVldENhcnQubWF4RmlsZVNpemUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZHJvcHpvbmUub24oJ3NlbmRpbmcnLCB0aGlzLnNlbmRpbmcpO1xyXG4gICAgICAgIHRoaXMuZHJvcHpvbmUub24oJ3N1Y2Nlc3MnLCB0aGlzLnN1Y2Nlc3MpO1xyXG4gICAgICAgIHRoaXMuZHJvcHpvbmUub24oJ2Vycm9yJywgdGhpcy5lcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgc2VuZGluZyhmaWxlLCB4aHIpIHtcclxuICAgICAgICB4aHIudGltZW91dCA9IDM2MDAwMDA7XHJcblxyXG4gICAgICAgICQoJy5hbGVydC1kYW5nZXInKS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdWNjZXNzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldFVwbG9hZGluZ0ZpbGVzKCkubGVuZ3RoID09PSAwICYmIHRoaXMuZ2V0UXVldWVkRmlsZXMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChEYXRhVGFibGUucmVsb2FkLCAxMDAwLCAnI2dhbGxlcmllcy10YWJsZSAudGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXJyb3IoZmlsZSwgcmVzcG9uc2UpIHtcclxuICAgICAgICAkKCcuZHotcHJvZ3Jlc3MnKS5jc3MoJ3otaW5kZXgnLCAxKTtcclxuICAgICAgICAkKGZpbGUucHJldmlld0VsZW1lbnQpLmZpbmQoJy5kei1lcnJvci1tZXNzYWdlJykudGV4dChyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiRHJvcHpvbmUiLCJfZGVmYXVsdCIsIl9jbGFzc0NhbGxDaGVjayIsImF1dG9EaXNjb3ZlciIsImRyb3B6b25lIiwidXJsIiwicm91dGUiLCJhdXRvUHJvY2Vzc1F1ZXVlIiwibWF4RmlsZXNpemUiLCJGbGVldENhcnQiLCJtYXhGaWxlU2l6ZSIsIm9uIiwic2VuZGluZyIsInN1Y2Nlc3MiLCJlcnJvciIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiZmlsZSIsInhociIsInRpbWVvdXQiLCIkIiwicmVtb3ZlIiwiZ2V0VXBsb2FkaW5nRmlsZXMiLCJsZW5ndGgiLCJnZXRRdWV1ZWRGaWxlcyIsInNldFRpbWVvdXQiLCJEYXRhVGFibGUiLCJyZWxvYWQiLCJyZXNwb25zZSIsImNzcyIsInByZXZpZXdFbGVtZW50IiwiZmluZCIsInRleHQiLCJtZXNzYWdlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Galleries/Resources/assets/admin/js/Uploader.js\n");

/***/ }),

/***/ "./Modules/Galleries/Resources/assets/admin/js/main.js":
/*!*************************************************************!*\
  !*** ./Modules/Galleries/Resources/assets/admin/js/main.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ImagePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImagePicker */ \"./Modules/Galleries/Resources/assets/admin/js/ImagePicker.js\");\n/* harmony import */ var _Uploader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Uploader */ \"./Modules/Galleries/Resources/assets/admin/js/Uploader.js\");\n\n// import GalleriesPicker from './GalleriesPicker';\n\nwindow.GalleriesPicker = GalleriesPicker;\nif ($('.image-picker').length !== 0) {\n  new _ImagePicker__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n}\nif ($('.dropzone').length !== 0) {\n  new _Uploader__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9Nb2R1bGVzL0dhbGxlcmllcy9SZXNvdXJjZXMvYXNzZXRzL2FkbWluL2pzL21haW4uanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXdDO0FBQ3hDO0FBQ2tDO0FBRWxDRSxNQUFNLENBQUNDLGVBQWUsR0FBR0EsZUFBZTtBQUV4QyxJQUFJQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUNDLE1BQU0sS0FBSyxDQUFDLEVBQUU7RUFDakMsSUFBSUwsb0RBQVcsQ0FBQyxDQUFDO0FBQ3JCO0FBRUEsSUFBSUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0VBQzdCLElBQUlKLGlEQUFRLENBQUMsQ0FBQztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZsZWV0Y2FydC8uL01vZHVsZXMvR2FsbGVyaWVzL1Jlc291cmNlcy9hc3NldHMvYWRtaW4vanMvbWFpbi5qcz83NDMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbWFnZVBpY2tlciBmcm9tICcuL0ltYWdlUGlja2VyJztcclxuLy8gaW1wb3J0IEdhbGxlcmllc1BpY2tlciBmcm9tICcuL0dhbGxlcmllc1BpY2tlcic7XHJcbmltcG9ydCBVcGxvYWRlciBmcm9tICcuL1VwbG9hZGVyJztcclxuXHJcbndpbmRvdy5HYWxsZXJpZXNQaWNrZXIgPSBHYWxsZXJpZXNQaWNrZXI7XHJcblxyXG5pZiAoJCgnLmltYWdlLXBpY2tlcicpLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgbmV3IEltYWdlUGlja2VyKCk7XHJcbn1cclxuXHJcbmlmICgkKCcuZHJvcHpvbmUnKS5sZW5ndGggIT09IDApIHtcclxuICAgIG5ldyBVcGxvYWRlcigpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJJbWFnZVBpY2tlciIsIlVwbG9hZGVyIiwid2luZG93IiwiR2FsbGVyaWVzUGlja2VyIiwiJCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./Modules/Galleries/Resources/assets/admin/js/main.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./Modules/Galleries/Resources/assets/admin/js/main.js");
/******/ 	
/******/ })()
;